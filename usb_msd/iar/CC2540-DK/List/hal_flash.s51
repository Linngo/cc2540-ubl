///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V9.20.1.2476 for 8051               14/Dec/2018  10:02:59
// Copyright 2004-2015 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\hal_flash.c
//    Command line       =  
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\hal_flash.c
//        -D HAL_SB_BOOT_CODE -D UBL_BUILD -D UBL_SECURE -D UBL_SIGNER -lC
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\List\
//        -lA
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\List\
//        --remarks -o
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\Obj\
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -I
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\app\
//        -I
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal\
//        -I
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\
//        -I
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\class_msd\
//        -I
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\library\
//        -Ohz --require_prototypes --mfc
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_exec.c
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_main.c
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_descriptor_parser.c
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_framework.c
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_interrupt.c
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_standard_requests.c
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_suspend.c
//    List file          =  
//        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\List\hal_flash.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME hal_flash

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V1
        EXTERN ?V2
        EXTERN ?V3
        EXTERN ?V4
        EXTERN ?V5
        EXTERN ?V6
        EXTERN ?V7
        EXTERN ?V8
        EXTERN ?V9
        EXTERN ?V10
        EXTERN ?V11
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?C_GPTR_LOAD
        EXTERN ?C_GPTR_STORE
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?FUNC_ENTER_XDATA
        EXTERN ?FUNC_LEAVE_XDATA
        EXTERN ?G_EQ
        EXTERN ?L_ADD_X
        EXTERN ?L_EQ
        EXTERN ?L_MOV_TO_X
        EXTERN ?L_MOV_X
        EXTERN ?L_MUL
        EXTERN ?L_SHL
        EXTERN ?L_SUB_FROM_X
        EXTERN ?MOVE_LONG8_XDATA_XDATA
        EXTERN ?PUSH_XSTACK8_X_THREE
        EXTERN ?PUSH_XSTACK_I_THREE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?S_SHL
        EXTERN ?UL_DIV_MOD
        EXTERN ?UL_GT_X
        EXTERN ?US_SHR
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTACK_DISP101_8
        EXTERN ?XSTACK_DISP102_8
        EXTERN __INIT_DATA_Z
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z
        EXTERN __low_level_init_call

        FUNCTION ??ChangeFeature,021203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 9, STACK
        FUNCTION `??ChangeFeature::?relay`,0203H
        FUNCTION ??ConfigureEndpoints,0a1203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 19, STACK
        FUNCTION `??ConfigureEndpoints::?relay`,0203H
        PUBLIC `??HalFlashErase::?relay`
        FUNCTION `??HalFlashErase::?relay`,0203H
        PUBLIC `??HalFlashRead::?relay`
        FUNCTION `??HalFlashRead::?relay`,0203H
        PUBLIC `??HalFlashWrite::?relay`
        FUNCTION `??HalFlashWrite::?relay`,0203H
        FUNCTION ??aesInitSig,0a1203H
        ARGFRAME XSTACK, 59, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 50, STACK
        FUNCTION `??aesInitSig::?relay`,0203H
        FUNCTION ??aesLoadKey,080203H
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION `??aesLoadKey::?relay`,0203H
        FUNCTION ??gpioInit,080203H
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        FUNCTION `??gpioInit::?relay`,0203H
        PUBLIC `??main::?relay`
        FUNCTION `??main::?relay`,0203H
        PUBLIC `??ublAesAuth::?relay`
        FUNCTION `??ublAesAuth::?relay`,0203H
        PUBLIC `??ublAesCrypt::?relay`
        FUNCTION `??ublAesCrypt::?relay`,0203H
        PUBLIC `??ublCfg::?relay`
        FUNCTION `??ublCfg::?relay`,0203H
        PUBLIC `??ublExec::?relay`
        FUNCTION `??ublExec::?relay`,0203H
        PUBLIC `??ublInit::?relay`
        FUNCTION `??ublInit::?relay`,0203H
        PUBLIC `??ublJump::?relay`
        FUNCTION `??ublJump::?relay`,0203H
        PUBLIC `??ublMassErase::?relay`
        FUNCTION `??ublMassErase::?relay`,0203H
        PUBLIC `??usbdpFindNext::?relay`
        FUNCTION `??usbdpFindNext::?relay`,0203H
        PUBLIC `??usbdpGetConfigurationDesc::?relay`
        FUNCTION `??usbdpGetConfigurationDesc::?relay`,0203H
        PUBLIC `??usbdpGetDeviceDesc::?relay`
        FUNCTION `??usbdpGetDeviceDesc::?relay`,0203H
        PUBLIC `??usbdpGetInterfaceDesc::?relay`
        FUNCTION `??usbdpGetInterfaceDesc::?relay`,0203H
        PUBLIC `??usbdpGetStringDesc::?relay`
        FUNCTION `??usbdpGetStringDesc::?relay`,0203H
        PUBLIC `??usbdpInit::?relay`
        FUNCTION `??usbdpInit::?relay`,0203H
        PUBLIC `??usbfwInit::?relay`
        FUNCTION `??usbfwInit::?relay`,0203H
        PUBLIC `??usbfwReadFifo::?relay`
        FUNCTION `??usbfwReadFifo::?relay`,0203H
        PUBLIC `??usbfwResetHandler::?relay`
        FUNCTION `??usbfwResetHandler::?relay`,0203H
        PUBLIC `??usbfwSetAllEpStatus::?relay`
        FUNCTION `??usbfwSetAllEpStatus::?relay`,0203H
        PUBLIC `??usbfwSetupHandler::?relay`
        FUNCTION `??usbfwSetupHandler::?relay`,0203H
        PUBLIC `??usbfwWriteFifo::?relay`
        FUNCTION `??usbfwWriteFifo::?relay`,0203H
        PUBLIC `??usbirqHandler::?relay`
        FUNCTION `??usbirqHandler::?relay`,0203H
        PUBLIC `??usbirqInit::?relay`
        FUNCTION `??usbirqInit::?relay`,0203H
        PUBLIC `??usbsrClearFeature::?relay`
        FUNCTION `??usbsrClearFeature::?relay`,0203H
        PUBLIC `??usbsrGetConfiguration::?relay`
        FUNCTION `??usbsrGetConfiguration::?relay`,0203H
        PUBLIC `??usbsrGetDescriptor::?relay`
        FUNCTION `??usbsrGetDescriptor::?relay`,0203H
        PUBLIC `??usbsrGetInterface::?relay`
        FUNCTION `??usbsrGetInterface::?relay`,0203H
        PUBLIC `??usbsrGetStatus::?relay`
        FUNCTION `??usbsrGetStatus::?relay`,0203H
        PUBLIC `??usbsrSetAddress::?relay`
        FUNCTION `??usbsrSetAddress::?relay`,0203H
        PUBLIC `??usbsrSetConfiguration::?relay`
        FUNCTION `??usbsrSetConfiguration::?relay`,0203H
        PUBLIC `??usbsrSetFeature::?relay`
        FUNCTION `??usbsrSetFeature::?relay`,0203H
        PUBLIC `??usbsrSetInterface::?relay`
        FUNCTION `??usbsrSetInterface::?relay`,0203H
        PUBLIC `??usbsuspDoRemoteWakeup::?relay`
        FUNCTION `??usbsuspDoRemoteWakeup::?relay`,0203H
        FUNCTION ??vddWait,0203H
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCTION `??vddWait::?relay`,0203H
        PUBWEAK ADCCON1
        PUBWEAK ADCCON3
        PUBWEAK ADCH
        PUBWEAK CLKCONCMD
        PUBWEAK DMA0CFGH
        PUBWEAK DMA0CFGL
        PUBWEAK DMAARM
        PUBWEAK DMAIRQ
        PUBWEAK ENCCS
        PUBWEAK ENCDI
        PUBWEAK ENCDO
        PUBLIC HalFlashErase
        FUNCTION HalFlashErase,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC HalFlashRead
        FUNCTION HalFlashRead,080203H
        ARGFRAME XSTACK, 61, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC HalFlashWrite
        FUNCTION HalFlashWrite,0a1203H
        ARGFRAME XSTACK, 61, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        PUBWEAK IEN2
        PUBWEAK MEMCTR
        PUBWEAK P0DIR
        PUBWEAK P0SEL
        PUBWEAK P1DIR
        PUBWEAK P1SEL
        PUBWEAK P2IFG
        PUBWEAK P2INP
        PUBWEAK SLEEPSTA
        PUBWEAK ST0
        PUBWEAK ST1
        PUBWEAK ST2
        PUBLIC UBL_RC_IMG_PG_BEG
        PUBLIC UBL_RC_IMG_PG_END
        PUBWEAK WDCTL
        PUBWEAK _A_IEN0
        PUBWEAK _A_IEN1
        PUBWEAK _A_IRCON2
        PUBWEAK _A_P0
        PUBWEAK _A_P1
        PUBWEAK __Constant_28000
        PUBWEAK __Constant_3000
        PUBWEAK __Constant_7d
        PUBWEAK __Constant_fffffff0
        PUBLIC __low_level_init
        FUNCTION __low_level_init,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC bbuuff
        PUBLIC dmaCh0
        PUBLIC hexDigit
        PUBLIC main
        FUNCTION main,021a03H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC pFnSuspendEnterHook
        PUBLIC pFnSuspendExitHook
        PUBLIC pgBuf
        PUBLIC testpoint
        PUBLIC ublAesAuth
        FUNCTION ublAesAuth,0a1203H
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 61, STACK
        PUBLIC ublAesCrypt
        FUNCTION ublAesCrypt,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 47, STACK
        PUBLIC ublCfg
        FUNCTION ublCfg,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC ublExec
        FUNCTION ublExec,0a1203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 24, STACK
        PUBLIC ublInit
        FUNCTION ublInit,0a1203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 54, STACK
        PUBLIC ublJump
        FUNCTION ublJump,080203H
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUBLIC ublMD
        PUBLIC ublMassErase
        FUNCTION ublMassErase,0203H
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 3, STACK
        PUBLIC usbSetupData
        PUBLIC usbSetupHeader
        PUBLIC usbdpFindNext
        FUNCTION usbdpFindNext,0203H
        ARGFRAME XSTACK, 19, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbdpGetConfigurationDesc
        FUNCTION usbdpGetConfigurationDesc,0a1203H
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbdpGetDeviceDesc
        FUNCTION usbdpGetDeviceDesc,021203H
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbdpGetInterfaceDesc
        FUNCTION usbdpGetInterfaceDesc,0a1203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        PUBLIC usbdpGetStringDesc
        FUNCTION usbdpGetStringDesc,0203H
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 17, STACK
        PUBLIC usbdpInit
        FUNCTION usbdpInit,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbfwData
        PUBLIC usbfwInit
        FUNCTION usbfwInit,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbfwReadFifo
        FUNCTION usbfwReadFifo,0203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC usbfwResetHandler
        FUNCTION usbfwResetHandler,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbfwSetAllEpStatus
        FUNCTION usbfwSetAllEpStatus,0203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbfwSetupHandler
        FUNCTION usbfwSetupHandler,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC usbfwWriteFifo
        FUNCTION usbfwWriteFifo,0203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC usbirqData
        PUBLIC usbirqHandler
        FUNCTION usbirqHandler,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbirqInit
        FUNCTION usbirqInit,080203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbsrClearFeature
        FUNCTION usbsrClearFeature,021203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrGetConfiguration
        FUNCTION usbsrGetConfiguration,0203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrGetDescriptor
        FUNCTION usbsrGetDescriptor,0a1203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 15, STACK
        PUBLIC usbsrGetInterface
        FUNCTION usbsrGetInterface,080203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 11, STACK
        PUBLIC usbsrGetStatus
        FUNCTION usbsrGetStatus,0203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrSetAddress
        FUNCTION usbsrSetAddress,0203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrSetConfiguration
        FUNCTION usbsrSetConfiguration,0a1203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        PUBLIC usbsrSetFeature
        FUNCTION usbsrSetFeature,021203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrSetInterface
        FUNCTION usbsrSetInterface,0a1203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC usbsuspDoRemoteWakeup
        FUNCTION usbsuspDoRemoteWakeup,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
          CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-2
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B SameValue
          CFI A SameValue
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 SameValue
          CFI R1 SameValue
          CFI R2 SameValue
          CFI R3 SameValue
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT SameValue
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon1
        
        
          CFI Common cfiCommon2 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-2
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT SameValue
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon2
        
        
          CFI Common cfiCommon3 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` Undefined
          CFI `B.BR0` Undefined
          CFI `B.BR1` Undefined
          CFI `B.BR2` Undefined
          CFI `B.BR3` Undefined
          CFI `B.BR4` Undefined
          CFI `B.BR5` Undefined
          CFI `B.BR6` Undefined
          CFI `B.BR7` Undefined
          CFI `VB.BR8` Undefined
          CFI `VB.BR9` Undefined
          CFI `VB.BR10` Undefined
          CFI `VB.BR11` Undefined
          CFI `VB.BR12` Undefined
          CFI `VB.BR13` Undefined
          CFI `VB.BR14` Undefined
          CFI `VB.BR15` Undefined
          CFI VB Undefined
          CFI B Undefined
          CFI A Undefined
          CFI PSW Undefined
          CFI DPL0 Undefined
          CFI DPH0 Undefined
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 Undefined
          CFI R7 Undefined
          CFI V0 Undefined
          CFI V1 Undefined
          CFI V2 Undefined
          CFI V3 Undefined
          CFI V4 Undefined
          CFI V5 Undefined
          CFI V6 Undefined
          CFI V7 Undefined
          CFI V8 Undefined
          CFI V9 Undefined
          CFI V10 Undefined
          CFI V11 Undefined
          CFI V12 Undefined
          CFI V13 Undefined
          CFI V14 Undefined
          CFI V15 Undefined
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon3
        
halMcuWaitMs        SYMBOL "halMcuWaitMs"
`??halMcuWaitMs::?relay` SYMBOL "?relay", halMcuWaitMs
memcmp              SYMBOL "memcmp"
`??memcmp::?relay`  SYMBOL "?relay", memcmp
memcpy              SYMBOL "memcpy"
`??memcpy::?relay`  SYMBOL "?relay", memcpy
usb_msd_init        SYMBOL "usb_msd_init"
`??usb_msd_init::?relay` SYMBOL "?relay", usb_msd_init
usb_msd_poll        SYMBOL "usb_msd_poll"
`??usb_msd_poll::?relay` SYMBOL "?relay", usb_msd_poll
usb_msd_uninit      SYMBOL "usb_msd_uninit"
`??usb_msd_uninit::?relay` SYMBOL "?relay", usb_msd_uninit
usbcrHookProcessIn  SYMBOL "usbcrHookProcessIn"
`??usbcrHookProcessIn::?relay` SYMBOL "?relay", usbcrHookProcessIn
usbcrHookProcessOut SYMBOL "usbcrHookProcessOut"
`??usbcrHookProcessOut::?relay` SYMBOL "?relay", usbcrHookProcessOut
usbirqHookProcessEvents SYMBOL "usbirqHookProcessEvents"
`??usbirqHookProcessEvents::?relay` SYMBOL "?relay", usbirqHookProcessEvents
usbsrHookClearFeature SYMBOL "usbsrHookClearFeature"
`??usbsrHookClearFeature::?relay` SYMBOL "?relay", usbsrHookClearFeature
usbsrHookProcessEvent SYMBOL "usbsrHookProcessEvent"
`??usbsrHookProcessEvent::?relay` SYMBOL "?relay", usbsrHookProcessEvent
usbsrHookSetFeature SYMBOL "usbsrHookSetFeature"
`??usbsrHookSetFeature::?relay` SYMBOL "?relay", usbsrHookSetFeature
usbvrHookProcessIn  SYMBOL "usbvrHookProcessIn"
`??usbvrHookProcessIn::?relay` SYMBOL "?relay", usbvrHookProcessIn
usbvrHookProcessOut SYMBOL "usbvrHookProcessOut"
`??usbvrHookProcessOut::?relay` SYMBOL "?relay", usbvrHookProcessOut
HalFlashErase       SYMBOL "HalFlashErase"
`??HalFlashErase::?relay` SYMBOL "?relay", HalFlashErase
HalFlashRead        SYMBOL "HalFlashRead"
`??HalFlashRead::?relay` SYMBOL "?relay", HalFlashRead
HalFlashWrite       SYMBOL "HalFlashWrite"
`??HalFlashWrite::?relay` SYMBOL "?relay", HalFlashWrite
main                SYMBOL "main"
`??main::?relay`    SYMBOL "?relay", main
ublAesAuth          SYMBOL "ublAesAuth"
`??ublAesAuth::?relay` SYMBOL "?relay", ublAesAuth
ublAesCrypt         SYMBOL "ublAesCrypt"
`??ublAesCrypt::?relay` SYMBOL "?relay", ublAesCrypt
ublCfg              SYMBOL "ublCfg"
`??ublCfg::?relay`  SYMBOL "?relay", ublCfg
ublExec             SYMBOL "ublExec"
`??ublExec::?relay` SYMBOL "?relay", ublExec
ublInit             SYMBOL "ublInit"
`??ublInit::?relay` SYMBOL "?relay", ublInit
ublJump             SYMBOL "ublJump"
`??ublJump::?relay` SYMBOL "?relay", ublJump
ublMassErase        SYMBOL "ublMassErase"
`??ublMassErase::?relay` SYMBOL "?relay", ublMassErase
usbdpFindNext       SYMBOL "usbdpFindNext"
`??usbdpFindNext::?relay` SYMBOL "?relay", usbdpFindNext
usbdpGetConfigurationDesc SYMBOL "usbdpGetConfigurationDesc"
`??usbdpGetConfigurationDesc::?relay` SYMBOL "?relay", usbdpGetConfigurationDesc
usbdpGetDeviceDesc  SYMBOL "usbdpGetDeviceDesc"
`??usbdpGetDeviceDesc::?relay` SYMBOL "?relay", usbdpGetDeviceDesc
usbdpGetInterfaceDesc SYMBOL "usbdpGetInterfaceDesc"
`??usbdpGetInterfaceDesc::?relay` SYMBOL "?relay", usbdpGetInterfaceDesc
usbdpGetStringDesc  SYMBOL "usbdpGetStringDesc"
`??usbdpGetStringDesc::?relay` SYMBOL "?relay", usbdpGetStringDesc
usbdpInit           SYMBOL "usbdpInit"
`??usbdpInit::?relay` SYMBOL "?relay", usbdpInit
usbfwInit           SYMBOL "usbfwInit"
`??usbfwInit::?relay` SYMBOL "?relay", usbfwInit
usbfwReadFifo       SYMBOL "usbfwReadFifo"
`??usbfwReadFifo::?relay` SYMBOL "?relay", usbfwReadFifo
usbfwResetHandler   SYMBOL "usbfwResetHandler"
`??usbfwResetHandler::?relay` SYMBOL "?relay", usbfwResetHandler
usbfwSetAllEpStatus SYMBOL "usbfwSetAllEpStatus"
`??usbfwSetAllEpStatus::?relay` SYMBOL "?relay", usbfwSetAllEpStatus
usbfwSetupHandler   SYMBOL "usbfwSetupHandler"
`??usbfwSetupHandler::?relay` SYMBOL "?relay", usbfwSetupHandler
usbfwWriteFifo      SYMBOL "usbfwWriteFifo"
`??usbfwWriteFifo::?relay` SYMBOL "?relay", usbfwWriteFifo
usbirqHandler       SYMBOL "usbirqHandler"
`??usbirqHandler::?relay` SYMBOL "?relay", usbirqHandler
usbirqInit          SYMBOL "usbirqInit"
`??usbirqInit::?relay` SYMBOL "?relay", usbirqInit
usbsrClearFeature   SYMBOL "usbsrClearFeature"
`??usbsrClearFeature::?relay` SYMBOL "?relay", usbsrClearFeature
usbsrGetConfiguration SYMBOL "usbsrGetConfiguration"
`??usbsrGetConfiguration::?relay` SYMBOL "?relay", usbsrGetConfiguration
usbsrGetDescriptor  SYMBOL "usbsrGetDescriptor"
`??usbsrGetDescriptor::?relay` SYMBOL "?relay", usbsrGetDescriptor
usbsrGetInterface   SYMBOL "usbsrGetInterface"
`??usbsrGetInterface::?relay` SYMBOL "?relay", usbsrGetInterface
usbsrGetStatus      SYMBOL "usbsrGetStatus"
`??usbsrGetStatus::?relay` SYMBOL "?relay", usbsrGetStatus
usbsrSetAddress     SYMBOL "usbsrSetAddress"
`??usbsrSetAddress::?relay` SYMBOL "?relay", usbsrSetAddress
usbsrSetConfiguration SYMBOL "usbsrSetConfiguration"
`??usbsrSetConfiguration::?relay` SYMBOL "?relay", usbsrSetConfiguration
usbsrSetFeature     SYMBOL "usbsrSetFeature"
`??usbsrSetFeature::?relay` SYMBOL "?relay", usbsrSetFeature
usbsrSetInterface   SYMBOL "usbsrSetInterface"
`??usbsrSetInterface::?relay` SYMBOL "?relay", usbsrSetInterface
usbsuspDoRemoteWakeup SYMBOL "usbsuspDoRemoteWakeup"
`??usbsuspDoRemoteWakeup::?relay` SYMBOL "?relay", usbsuspDoRemoteWakeup

        EXTERN `??halMcuWaitMs::?relay`
        FUNCTION `??halMcuWaitMs::?relay`,00H
        EXTERN `??memcmp::?relay`
        FUNCTION `??memcmp::?relay`,00H
        EXTERN `??memcpy::?relay`
        FUNCTION `??memcpy::?relay`,00H
        EXTERN `??usb_msd_init::?relay`
        FUNCTION `??usb_msd_init::?relay`,00H
        EXTERN `??usb_msd_poll::?relay`
        FUNCTION `??usb_msd_poll::?relay`,00H
        EXTERN `??usb_msd_uninit::?relay`
        FUNCTION `??usb_msd_uninit::?relay`,00H
        EXTERN `??usbcrHookProcessIn::?relay`
        FUNCTION `??usbcrHookProcessIn::?relay`,00H
        EXTERN `??usbcrHookProcessOut::?relay`
        FUNCTION `??usbcrHookProcessOut::?relay`,00H
        EXTERN `??usbirqHookProcessEvents::?relay`
        FUNCTION `??usbirqHookProcessEvents::?relay`,00H
        EXTERN `??usbsrHookClearFeature::?relay`
        FUNCTION `??usbsrHookClearFeature::?relay`,00H
        EXTERN `??usbsrHookProcessEvent::?relay`
        FUNCTION `??usbsrHookProcessEvent::?relay`,00H
        EXTERN `??usbsrHookSetFeature::?relay`
        FUNCTION `??usbsrHookSetFeature::?relay`,00H
        EXTERN `??usbvrHookProcessIn::?relay`
        FUNCTION `??usbvrHookProcessIn::?relay`,00H
        EXTERN `??usbvrHookProcessOut::?relay`
        FUNCTION `??usbvrHookProcessOut::?relay`,00H
        EXTERN halMcuWaitMs
        FUNCTION halMcuWaitMs,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcmp
        FUNCTION memcmp,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 54, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcpy
        FUNCTION memcpy,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 61, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbDescriptorMarker
        EXTERN usb_msd_init
        FUNCTION usb_msd_init,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usb_msd_poll
        FUNCTION usb_msd_poll,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usb_msd_uninit
        FUNCTION usb_msd_uninit,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbcrHookProcessIn
        FUNCTION usbcrHookProcessIn,0602H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbcrHookProcessOut
        FUNCTION usbcrHookProcessOut,0602H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbirqHookProcessEvents
        FUNCTION usbirqHookProcessEvents,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbsrHookClearFeature
        FUNCTION usbsrHookClearFeature,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbsrHookProcessEvent
        FUNCTION usbsrHookProcessEvent,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbsrHookSetFeature
        FUNCTION usbsrHookSetFeature,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbvrHookProcessIn
        FUNCTION usbvrHookProcessIn,0602H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbvrHookProcessOut
        FUNCTION usbvrHookProcessOut,0602H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\hal_flash.c
//    1 /******************************************************************************
//    2 
//    3  @file  hal_flash.c
//    4 
//    5  @brief This file contains the interface to the H/W Flash driver.
//    6 
//    7  Group: WCS, BTS
//    8  Target Device: CC2540, CC2541
//    9 
//   10  ******************************************************************************
//   11  
//   12  Copyright (c) 2006-2016, Texas Instruments Incorporated
//   13  All rights reserved.
//   14 
//   15  IMPORTANT: Your use of this Software is limited to those specific rights
//   16  granted under the terms of a software license agreement between the user
//   17  who downloaded the software, his/her employer (which must be your employer)
//   18  and Texas Instruments Incorporated (the "License"). You may not use this
//   19  Software unless you agree to abide by the terms of the License. The License
//   20  limits your use, and you acknowledge, that the Software may not be modified,
//   21  copied or distributed unless embedded on a Texas Instruments microcontroller
//   22  or used solely and exclusively in conjunction with a Texas Instruments radio
//   23  frequency transceiver, which is integrated into your product. Other than for
//   24  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   25  works of, modify, distribute, perform, display or sell this Software and/or
//   26  its documentation for any purpose.
//   27 
//   28  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   29  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   30  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   31  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   32  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   33  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   34  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   35  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   36  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   37  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   38  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   39 
//   40  Should you have any questions regarding your right to use this Software,
//   41  contact Texas Instruments Incorporated at www.TI.com.
//   42 
//   43  ******************************************************************************
//   44  Release Name: ble_sdk_1.4.2.2
//   45  Release Date: 2016-06-09 06:57:10
//   46  *****************************************************************************/
//   47 
//   48 /* ------------------------------------------------------------------------------------------------
//   49  *                                          Includes
//   50  * ------------------------------------------------------------------------------------------------
//   51  */
//   52 
//   53 #include "hal_board_cfg.h"

        ASEGN SFR_AN:DATA:NOROOT,080H
// union <unnamed> volatile __sfr _A_P0
_A_P0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,08bH
// unsigned char volatile __sfr P2IFG
P2IFG:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,090H
// union <unnamed> volatile __sfr _A_P1
_A_P1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,095H
// unsigned char volatile __sfr ST0
ST0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,096H
// unsigned char volatile __sfr ST1
ST1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,097H
// unsigned char volatile __sfr ST2
ST2:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09aH
// unsigned char volatile __sfr IEN2
IEN2:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09dH
// unsigned char volatile __sfr SLEEPSTA
SLEEPSTA:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b1H
// unsigned char volatile __sfr ENCDI
ENCDI:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b2H
// unsigned char volatile __sfr ENCDO
ENCDO:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b3H
// unsigned char volatile __sfr ENCCS
ENCCS:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b4H
// unsigned char volatile __sfr ADCCON1
ADCCON1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b6H
// unsigned char volatile __sfr ADCCON3
ADCCON3:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b8H
// union <unnamed> volatile __sfr _A_IEN1
_A_IEN1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0bbH
// unsigned char volatile __sfr ADCH
ADCH:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c6H
// unsigned char volatile __sfr CLKCONCMD
CLKCONCMD:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c7H
// unsigned char volatile __sfr MEMCTR
MEMCTR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c9H
// unsigned char volatile __sfr WDCTL
WDCTL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d1H
// unsigned char volatile __sfr DMAIRQ
DMAIRQ:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d4H
// unsigned char volatile __sfr DMA0CFGL
DMA0CFGL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d5H
// unsigned char volatile __sfr DMA0CFGH
DMA0CFGH:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d6H
// unsigned char volatile __sfr DMAARM
DMAARM:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e8H
// union <unnamed> volatile __sfr _A_IRCON2
_A_IRCON2:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0f3H
// unsigned char volatile __sfr P0SEL
P0SEL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0f4H
// unsigned char volatile __sfr P1SEL
P1SEL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0f7H
// unsigned char volatile __sfr P2INP
P2INP:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0fdH
// unsigned char volatile __sfr P0DIR
P0DIR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0feH
// unsigned char volatile __sfr P1DIR
P1DIR:
        DATA8
        DS 1
//   54 #include "hal_dma.h"
//   55 #include "hal_flash.h"
//   56 #include "hal_mcu.h"
//   57 #include "hal_types.h"
//   58 #include "string.h"
//   59 
//   60 /**************************************************************************************************
//   61  * @fn          HalFlashRead
//   62  *
//   63  * @brief       This function reads 'cnt' bytes from the internal flash.
//   64  *
//   65  * input parameters
//   66  *
//   67  * @param       pg - A valid flash page number.
//   68  * @param       offset - A valid offset into the page.
//   69  * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
//   70  * @param       cnt - A valid number of bytes to read.
//   71  *
//   72  * output parameters
//   73  *
//   74  * None.
//   75  *
//   76  * @return      None.
//   77  **************************************************************************************************
//   78  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   79 void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
HalFlashRead:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HalFlashRead
        CODE
//   80 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
        MOV     ?V2,R1
//   81   // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
//   82   uint8 *pData = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
//   83                  ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
        MOV     A,#0xf
        ANL     A,?V2
        MOV     ?V0,A
        MOV     ?V1,#0x0
        MOV     A,#0xb
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     A,R2
        ADD     A,#0x0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,#-0x80
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x0
        MOV     A,R1
        ADDC    A,?V1
        MOV     R1,A
//   84   uint8 memctr = MEMCTR;  // Save to restore.
        MOV     ?V1,0xc7+0x0
//   85 
//   86 #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
//   87   halIntState_t is;
//   88 #endif
//   89 
//   90   pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
//   91 
//   92 #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
//   93   HAL_ENTER_CRITICAL_SECTION(is);
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     ?V0,A
        CLR     0xa8.7
//   94 #endif
//   95 
//   96   // Calculate and map the containing flash bank into XDATA.
//   97   MEMCTR = (MEMCTR & 0xF8) | pg;
        MOV     A,?V2
        SWAP    A
        ANL     A,#0xf
        MOV     R2,A
        MOV     A,0xc7
        ANL     A,#0xf8
        ORL     A,R2
        MOV     0xc7,A
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        LCALL   ??Subroutine36_0 & 0xFFFF
??CrossCallReturnLabel_45:
        SJMP    ??HalFlashRead_0
//   98 
//   99   while (cnt--)
//  100   {
//  101     *buf++ = *pData++;
??HalFlashRead_1:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    @DPTR,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R4,DPL
        MOV     R5,DPH
//  102   }
??HalFlashRead_0:
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     A,R6
        ADD     A,#-0x1
        DEC     R2
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R3,A
        MOV     A,R6
        ORL     A,R7
        JNZ     ??HalFlashRead_1
//  103 
//  104   MEMCTR = memctr;
        MOV     0xc7,?V1
//  105 
//  106 #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
//  107   HAL_EXIT_CRITICAL_SECTION(is);
        MOV     A,?V0
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
//  108 #endif
//  109 }
        LJMP    ??Subroutine33_0 & 0xFFFF
          CFI EndBlock cfiBlock0
        REQUIRE MEMCTR
        REQUIRE _A_IEN0
//  110 
//  111 /**************************************************************************************************
//  112  * @fn          HalFlashWrite
//  113  *
//  114  * @brief       This function writes 'cnt' bytes to the internal flash.
//  115  *
//  116  * input parameters
//  117  *
//  118  * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
//  119  * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
//  120  * @param       cnt - Number of 4-byte blocks to write.
//  121  *
//  122  * output parameters
//  123  *
//  124  * None.
//  125  *
//  126  * @return      None.
//  127  **************************************************************************************************
//  128  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  129 uint8 bbuuff[256];
bbuuff:
        DS 256
        REQUIRE __INIT_XDATA_Z
//  130 extern bool testpoint;

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  131 void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
HalFlashWrite:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function HalFlashWrite
        CODE
//  132 {
        FUNCALL HalFlashWrite, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  133   uint8 i=0;
        MOV     ?V0,#0x0
//  134   halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
//  135 
//  136   if(testpoint)
        MOV     DPTR,#testpoint
        MOVX    A,@DPTR
        JNZ     ??HalFlashWrite_0
//  137   {
//  138 //    (void)memcpy(bbuuff, buf, 256);  
//  139     while(*buf == 0xE5)
//  140     {
//  141       buf += 32;
//  142       i++;
//  143     }
//  144     (void)memcpy(bbuuff, buf, 255-i*32);
//  145     bbuuff[255] = 0x01;
//  146     HAL_DMA_SET_SOURCE(ch, bbuuff);
//  147   }
//  148   else
//  149     HAL_DMA_SET_SOURCE(ch, buf);
        MOV     A,R5
        MOV     DPTR,#dmaCh0
        MOVX    @DPTR,A
        MOV     A,R4
        INC     DPTR
??HalFlashWrite_1:
        MOVX    @DPTR,A
//  150   HAL_DMA_SET_DEST(ch, &FWDATA);
        INC     DPTR
        MOV     A,#0x62
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x73
        MOVX    @DPTR,A
//  151   HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine13 & 0xFFFF
//  152   HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
??CrossCallReturnLabel_13:
        MOV     A,?V0
        RLC     A
        RLC     A
        ANL     A,#0xfc
        MOV     DPTR,#dmaCh0 + 5
        MOVX    @DPTR,A
        MOV     A,#0x6
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        MOV     DPTR,#dmaCh0 + 4
        MOVX    @DPTR,A
//  153   HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
//  154   HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
//  155   HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
        MOV     DPTR,#dmaCh0 + 6
        MOV     A,#0x12
        MOVX    @DPTR,A
//  156   HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
//  157   HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
//  158   // The DMA is to be polled and shall not issue an IRQ upon completion.
//  159   HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
//  160   HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
//  161   HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
        INC     DPTR
        MOV     A,#0x42
        MOVX    @DPTR,A
//  162   HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
        MOV     0xd1,#-0x2
//  163   HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
        MOV     0xd6,#0x1
//  164 
//  165   FADDRL = (uint8)addr;
        MOV     A,R6
        MOV     DPTR,#0x6271
        MOVX    @DPTR,A
//  166   FADDRH = (uint8)(addr >> 8);
        MOV     A,R7
        INC     DPTR
        MOVX    @DPTR,A
//  167   FCTL |= 0x02;         // Trigger the DMA writes.
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.1
        MOVX    @DPTR,A
//  168   while (FCTL & 0x80);  // Wait until writing is done.
??HalFlashWrite_2:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.7
        JC      ??HalFlashWrite_2
//  169 }
        LJMP    ??Subroutine29_0 & 0xFFFF
??HalFlashWrite_3:
        MOV     A,R4
        ADD     A,#0x20
        MOV     R4,A
        JNC     ??HalFlashWrite_4
        INC     R5
??HalFlashWrite_4:
        INC     ?V0
??HalFlashWrite_0:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        XRL     A,#0xe5
        JZ      ??HalFlashWrite_3
        ; Setup parameters for call to function memcpy
        MOV     ?V1,#0x0
        MOV     A,#0x5
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     A,#-0x1
        CLR     C
        SUBB    A,?V0
        MOV     ?V0,A
        CLR     A
        SUBB    A,?V1
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     R2,#bbuuff & 0xff
        MOV     R3,#(bbuuff >> 8) & 0xff
        LCALL   `??memcpy::?relay`   ; Banked call to: memcpy
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
        MOV     DPTR,#bbuuff + 255
        MOV     A,#0x1
        MOVX    @DPTR,A
        MOV     A,#(bbuuff >> 8) & 0xff
        MOV     DPTR,#dmaCh0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#bbuuff & 0xff
        LJMP    ??HalFlashWrite_1 & 0xFFFF
          CFI EndBlock cfiBlock1
        REQUIRE DMAIRQ
        REQUIRE DMAARM
//  170 
//  171 /**************************************************************************************************
//  172  * @fn          HalFlashErase
//  173  *
//  174  * @brief       This function erases the specified page of the internal flash.
//  175  *
//  176  * input parameters
//  177  *
//  178  * @param       pg - A valid flash page number to erase.
//  179  *
//  180  * output parameters
//  181  *
//  182  * None.
//  183  *
//  184  * @return      None.
//  185  **************************************************************************************************
//  186  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  187 void HalFlashErase(uint8 pg)
HalFlashErase:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HalFlashErase
        CODE
//  188 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  189   FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
        MOV     A,R1
        CLR     C
        RLC     A
        MOV     DPTR,#0x6272
        LJMP    ?Subroutine2 & 0xFFFF
//  190   FCTL |= 0x01;
//  191 }
          CFI EndBlock cfiBlock2
//  192 
//  193 /**************************************************************************************************
//  194 */
// C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_exec.c
//    1 /******************************************************************************
//    2 
//    3  @file  ubl_exec.c
//    4 
//    5  @brief This module implements the executive functionality of a Universal Boot
//    6         Loader for an 8051-based SOC using the USB transport by MSD.
//    7 
//    8  Group: WCS, BTS
//    9  Target Device: CC2540, CC2541
//   10 
//   11  ******************************************************************************
//   12  
//   13  Copyright (c) 2011-2016, Texas Instruments Incorporated
//   14  All rights reserved.
//   15 
//   16  IMPORTANT: Your use of this Software is limited to those specific rights
//   17  granted under the terms of a software license agreement between the user
//   18  who downloaded the software, his/her employer (which must be your employer)
//   19  and Texas Instruments Incorporated (the "License"). You may not use this
//   20  Software unless you agree to abide by the terms of the License. The License
//   21  limits your use, and you acknowledge, that the Software may not be modified,
//   22  copied or distributed unless embedded on a Texas Instruments microcontroller
//   23  or used solely and exclusively in conjunction with a Texas Instruments radio
//   24  frequency transceiver, which is integrated into your product. Other than for
//   25  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   26  works of, modify, distribute, perform, display or sell this Software and/or
//   27  its documentation for any purpose.
//   28 
//   29  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   30  PROVIDED “AS ISWITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   31  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   32  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   33  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   34  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   35  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   36  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   37  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   38  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   39  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   40 
//   41  Should you have any questions regarding your right to use this Software,
//   42  contact Texas Instruments Incorporated at www.TI.com.
//   43 
//   44  ******************************************************************************
//   45  Release Name: ble_sdk_1.4.2.2
//   46  Release Date: 2016-06-09 06:57:10
//   47  *****************************************************************************/
//   48 
//   49 /* ------------------------------------------------------------------------------------------------
//   50  *                                          Includes
//   51  * ------------------------------------------------------------------------------------------------
//   52  */
//   53 
//   54 #include <stddef.h>
//   55 #include <string.h>
//   56 
//   57 #include "hal_board_cfg.h"
//   58 #include "hal_dma.h"
//   59 #include "hal_flash.h"
//   60 #include "hal_types.h"
//   61 #include "ubl_app.h"
//   62 #include "ubl_exec.h"
//   63 #include "usb_msd.h"
//   64 
//   65 /* ------------------------------------------------------------------------------------------------
//   66  *                                          Constants
//   67  * ------------------------------------------------------------------------------------------------
//   68  */
//   69 
//   70 #if !defined HAL_DONGLE_NANO
//   71 #define UBL_GPIO_USE
//   72 #endif
//   73 
//   74 // Define the checksum-subset of the Meta Data for checksum calculation and copying so as not to
//   75 // overwrite ong.
//   76 #define UBL_MD_CHKLEN  (offsetof(ublMetaData_t, cntDnForced) - offsetof(ublMetaData_t, chkMD))
//   77 

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//   78 static const uint8 unlockedSecKey[32] =
??unlockedSecKey:
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
//   79 {
//   80   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
//   81   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
//   82 };
//   83 
//   84 /***                 The following are "Write" addresses for HalFlashWrite().                  ***/
//   85 #define UBL_META_DATA_ADDR_WR  \ 
//   86   ((uint16)(UBL_META_DATA_PAGE * ((uint16)(HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE))) + \ 
//   87                                   (uint16)(UBL_META_DATA_IDX / HAL_FLASH_WORD_SIZE))
//   88 
//   89 #define UBL_CNTDN_FORCED_ADDR (UBL_META_DATA_ADDR_WR + \ 
//   90                               (offsetof(ublMetaData_t, cntDnForced) / HAL_FLASH_WORD_SIZE))
//   91 #define UBL_CNTDN_SECKEY_ADDR (UBL_META_DATA_ADDR_WR + \ 
//   92                               (offsetof(ublMetaData_t, cntDnSecKey) / HAL_FLASH_WORD_SIZE))
//   93 /***                  The above are "Write" addresses for HalFlashWrite().                    ***/
//   94 
//   95 // Allow test & development with final structures and memeory map without the burden of having to
//   96 // encrypt and sign every image to download until ready with the production build.
//   97 #if !defined UBL_SECURE
//   98 #define UBL_SECURE                  FALSE
//   99 #endif
//  100 
//  101 #if UBL_SECURE

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  102 static const uint8 aesKey[KEY_BLENGTH] = {
??aesKey:
        DB 89
        DB 48
        DB 84
        DB 112
        DB 97
        DB 70
        DB 117
        DB 114
        DB 81
        DB 89
        DB 103
        DB 76
        DB 73
        DB 33
        DB 102
        DB 53
//  103   // This dummy key must be replaced by a randomly generated key that is kept secret.
//  104  // 0xab, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
//  105   'Y','0','T','p','a','F','u','r','Q','Y','g','L','I','!','f','5'
//  106 };
//  107 #endif
//  108 
//  109 // Set UBL_SIGNER=TRUE in order to create a special boot loader that will accept
//  110 // an un-encrypted/un-authenticated image via download and then sign it and send it back
//  111 // with encryption on the read back.
//  112 #if !defined UBL_SIGNER
//  113 #define UBL_SIGNER                   FALSE
//  114 #endif
//  115 
//  116 #if UBL_SIGNER
//  117 #if !UBL_SECURE
//  118 #error Mismatched definitions for UBL_SIGNER and UBL_SECURE.
//  119 #else
//  120 #warning You built a special "Signing" boot loader - do not release to market ... internal use only.
//  121 #endif
//  122 #endif
//  123 
//  124 /* ------------------------------------------------------------------------------------------------
//  125  *                                           Macros
//  126  * ------------------------------------------------------------------------------------------------
//  127  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  128 static bool have_data = 0;
??have_data:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  129 #define UBL_READ_ST(STCNT) st (             \ 
//  130   do {  /* Get the sleep timer count; ST0 must be read first & re-read to verify. */\ 
//  131     ((uint8 *) &(STCNT))[0] = ST0;          \ 
//  132   } while (((uint8 *) &(STCNT))[0] != ST0); \ 
//  133   ((uint8 *) &(STCNT))[1] = ST1;            \ 
//  134   ((uint8 *) &(STCNT))[2] = ST2;            \ 
//  135   ((uint8 *) &(STCNT))[3] = 0;              \ 
//  136 )
//  137 
//  138 /* ------------------------------------------------------------------------------------------------
//  139  *                                       Global Variables
//  140  * ------------------------------------------------------------------------------------------------
//  141  */
//  142 

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  143 const uint8 UBL_RC_IMG_PG_BEG = UBL_PAGE_FIRST;
UBL_RC_IMG_PG_BEG:
        DB 1

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  144 const uint8 UBL_RC_IMG_PG_END = UBL_PAGE_LAST;
UBL_RC_IMG_PG_END:
        DB 118
//  145 
//  146 /* ------------------------------------------------------------------------------------------------
//  147  *                                       Global Variables
//  148  * ------------------------------------------------------------------------------------------------
//  149  */
//  150 

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA8
//  151 __no_init uint8 pgBuf[HAL_FLASH_PAGE_SIZE];  // RAM (XDATA) buffer for an Rx/Tx flash page.
pgBuf:
        DS 2048

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA8
//  152 __no_init ublMetaData_t ublMD;
ublMD:
        DS 100
//  153 
//  154 /* ------------------------------------------------------------------------------------------------
//  155  *                                       Local Variables
//  156  * ------------------------------------------------------------------------------------------------
//  157  */
//  158 
//  159 #if defined UBL_GPIO_USE

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA16
//  160 static __no_init volatile uint8 *pForcePort;
??pForcePort:
        DS 2

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA8
//  161 static __no_init uint8 forcePin;
??forcePin:
        DS 1
//  162 #endif

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA32
//  163 static __no_init uint32 stStart, stDelay;
??stStart:
        DS 4

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA32
??stDelay:
        DS 4
//  164 
//  165 #if UBL_SECURE
//  166 // Flag when built with UBL_SIGNER=TRUE to encrypt the read back.

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  167 static bool signMode;
??signMode:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  168 #endif
//  169 
//  170 /* ------------------------------------------------------------------------------------------------
//  171  *                                       Local Functions
//  172  * ------------------------------------------------------------------------------------------------
//  173  */
//  174 
//  175 #if UBL_SECURE
//  176 static uint8 aesCheckCtrl(void *pBuf);
//  177 static void  aesLoadKey(void);
//  178 static void  aesInitSig(void);
//  179 #endif
//  180 
//  181 static bool cntDnForcedDecr(void);
//  182 #if defined UBL_GPIO_USE
//  183 static bool gpioInit(void);
//  184 #endif
//  185 static void vddWait(void);
//  186 
//  187 /**************************************************************************************************
//  188  * @fn          ublAesAuth
//  189  *
//  190  * @brief       Run the AES CRC-MAC authentication calculation over the RC image according to the
//  191  *              AES Control Block parameters and update the control block accordingly.
//  192  *              Just set CRC shadow equal to CRC when no valid security key built into the UBL.
//  193  *
//  194  * input parameters
//  195  *
//  196  * None.
//  197  *
//  198  * output parameters
//  199  *
//  200  * None.
//  201  *
//  202  * @return      TRUE or FALSE whether the AES signature of the image in flash is valid.
//  203  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  204 bool testpoint=0;
testpoint:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  205 uint8 ublAesAuth(void)
ublAesAuth:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function ublAesAuth
        CODE
//  206 {
        FUNCALL ublAesAuth, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 61, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 61, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublAesAuth, ??aesInitSig
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 59, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 59, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublAesAuth, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 61, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 61, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublAesAuth, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 61, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 61, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublAesAuth, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 61, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 61, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublAesAuth, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 61, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 61, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 49
        MOV     A,#-0x31
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 59)
//  207 #if UBL_SECURE
//  208   uint8 pgCnt = 0;
        MOV     R7,#0x0
//  209   uint8 sigBuf[KEY_BLENGTH];
//  210 
//  211   aes_ctrl_blk_t ctrlBlk;
//  212   UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x20
        MOV     ?V1,R7
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 61)
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP102_8
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     R1,#0x1
        LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 59)
//  213   
//  214   aesInitSig();
        ; Setup parameters for call to function aesInitSig
        LCALL   `??aesInitSig::?relay`; Banked call to: aesInitSig
//  215 
//  216   have_data = 1;
        MOV     DPTR,#??have_data
        MOV     A,#0x1
        MOVX    @DPTR,A
//  217   for (uint8 pgNum = UBL_PAGE_FIRST; pgNum <= UBL_PAGE_LAST; pgNum++)
        MOV     R6,#0x1
//  218   {
//  219     if (!GET_BIT(ublMD.writeEn, pgNum))
??ublAesAuth_0:
        MOV     A,R6
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     R0,A
        MOV     A,#(ublMD + 56) & 0xff
        ADD     A,R0
        MOV     DPL,A
        CLR     A
        ADDC    A,#((ublMD + 56) >> 8) & 0xff
        MOV     DPH,A
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0x7
        ANL     A,R6
        MOV     R0,A
        POP     A
          CFI CFA_SP SP+0
        CJNE    R0,#0x0,??ublAesAuth_1
        SJMP    ??ublAesAuth_2
??ublAesAuth_1:
        CLR     C
        RRC     A
        DJNZ    R0,??ublAesAuth_1
??ublAesAuth_2:
        MOV     C,0xE0 /* A   */.0
        JNC     ??ublAesAuth_3
//  220     {
//  221       continue;
//  222     }
//  223 
//  224     pgCnt++;
        INC     R7
//  225 
//  226     HalFlashRead(pgNum, 0, pgBuf, HAL_FLASH_PAGE_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x0
        MOV     ?V1,#0x8
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 61)
        MOV     R4,#pgBuf & 0xff
        MOV     R5,#(pgBuf >> 8) & 0xff
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     A,R6
        MOV     R1,A
        LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 59)
//  227 
//  228     for (uint16 oset = 0; oset < HAL_FLASH_PAGE_SIZE; )
        MOV     R0,#0x0
        MOV     R1,#0x0
//  229     {
//  230       if ((pgCnt == 1) && (oset == 0))
??ublAesAuth_4:
        MOV     A,#0x1
        XRL     A,R7
        JNZ     ??ublAesAuth_5
        MOV     A,R0
        ORL     A,R1
        JNZ     ??ublAesAuth_5
//  231       {
//  232         oset += KEY_BLENGTH;  // Must not include the signature bytes in the signature calculation.22;//
        MOV     R0,#0x10
        MOV     R1,#0x0
//  233         pgBuf[21] = 0xff;
        MOV     DPTR,#pgBuf + 21
        MOV     A,#-0x1
        MOVX    @DPTR,A
        SJMP    ??ublAesAuth_6
//  234       }
//  235       else if ((pgCnt == ctrlBlk.imageLen) && (oset == (HAL_FLASH_PAGE_SIZE - KEY_BLENGTH)))
??ublAesAuth_5:
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R7
        JNZ     ??ublAesAuth_6
        MOV     A,#-0x10
        XRL     A,R0
        JNZ     ??ublAesAuth_7
        MOV     A,#0x7
        XRL     A,R1
??ublAesAuth_7:
        JZ      ??ublAesAuth_8
//  236       {
//  237         break;  // Need to change mode to CBC-MAC for the last block.
//  238       }
//  239 
//  240       ENCCS |= 0x01;
??ublAesAuth_6:
        ORL     0xb3,#0x1
//  241       for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
        MOV     R2,#0x10
//  242       {
//  243         ENCDI = pgBuf[oset++];
??ublAesAuth_9:
        LCALL   ?Subroutine20 & 0xFFFF
//  244       }
??CrossCallReturnLabel_27:
        JNZ     ??ublAesAuth_10
        INC     R1
??ublAesAuth_10:
        DEC     R2
        MOV     A,R2
        JNZ     ??ublAesAuth_9
//  245       while ((ENCCS & BV(3)) == 0);
??ublAesAuth_11:
        MOV     A,0xb3
        MOV     C,0xE0 /* A   */.3
        JNC     ??ublAesAuth_11
//  246     }
        CLR     C
        MOV     A,R1
        SUBB    A,#0x8
        JC      ??ublAesAuth_4
//  247 
//  248     if (pgCnt >= ctrlBlk.imageLen)
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R7
        CLR     C
        SUBB    A,R0
        JNC     ??ublAesAuth_8
//  249     {
//  250       break;
//  251     }
//  252   }
??ublAesAuth_3:
        INC     R6
        MOV     A,R6
        CLR     C
        SUBB    A,#0x77
        JNC     $+5
        LJMP    ??ublAesAuth_0 & 0xFFFF
//  253 
//  254   ENCCS = CBC | AES_ENCRYPT | 0x01;  // Switch to CBC mode for the last block.
??ublAesAuth_8:
        MOV     0xb3,#0x1
//  255 
//  256   // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  257   // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  258   ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
//  259 
//  260   for (uint16 oset = (HAL_FLASH_PAGE_SIZE - KEY_BLENGTH); oset < HAL_FLASH_PAGE_SIZE; oset++)
        MOV     R0,#-0x10
        MOV     R1,#0x7
//  261   {
//  262     ENCDI = pgBuf[oset];
??ublAesAuth_12:
        LCALL   ?Subroutine20 & 0xFFFF
//  263   }
??CrossCallReturnLabel_26:
        JNZ     ??ublAesAuth_13
        INC     R1
??ublAesAuth_13:
        CLR     C
        MOV     A,R1
        SUBB    A,#0x8
        JC      ??ublAesAuth_12
//  264   HAL_AES_DELAY();  // Delay required for non-DMA AES as RDY bit only goes hi after read out below.
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0xf
        MOVX    @DPTR,A
??ublAesAuth_14:
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#-0x1
        ADD     A,R0
        MOVX    @DPTR,A
        INC     A
        JNZ     ??ublAesAuth_14
//  265 
//  266   // CBC-MAC generates output on the last block.
//  267   for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
        MOV     R2,#0x0
//  268   {
//  269     sigBuf[cnt] = ENCDO;
??ublAesAuth_15:
        MOV     A,0xb2
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R2
        MOV     R0,A
        MOV     A,#0x21
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine21 & 0xFFFF
//  270   }
??CrossCallReturnLabel_28:
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        INC     R2
        MOV     A,R2
        CLR     C
        SUBB    A,#0x10
        JC      ??ublAesAuth_15
//  271 
//  272   if (ctrlBlk.allowSignCmd != 0)  // If requested to sign this image.
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JZ      ??ublAesAuth_16
//  273   {
//  274     ctrlBlk.allowSignCmd = 0;
        CLR     A
        MOVX    @DPTR,A
//  275     (void)memcpy(ctrlBlk.signature, sigBuf, KEY_BLENGTH);
        ; Setup parameters for call to function memcpy
        MOV     ?V0,#0x10
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 61)
        MOV     A,#0x23
        LCALL   ?XSTACK_DISP102_8
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP101_8
        LCALL   `??memcpy::?relay`   ; Banked call to: memcpy
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 59)
//  276     UBL_NVM_SET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
        ; Setup parameters for call to function HalFlashWrite
        MOV     ?V0,#0x8
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 61)
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP102_8
        MOV     R2,#0x0
        MOV     R3,#0x2
        LCALL   `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 59)
//  277     UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x20
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 61)
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP102_8
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     R1,#0x1
        LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 59)
//  278   }
//  279 
//  280 #if UBL_SIGNER
//  281   signMode = TRUE;  // Now the Signer should encrypt the read back.
??ublAesAuth_16:
        MOV     DPTR,#??signMode
        MOV     A,#0x1
        MOVX    @DPTR,A
//  282 #else  // A signer must always return FALSE so that usb_msd.c does not save the file name to flash.
//  283   if (memcmp(ctrlBlk.signature, sigBuf, KEY_BLENGTH))
//  284 #endif
//  285   {
//  286     return FALSE;
        MOV     R1,#0x0
        MOV     A,#0x31
          CFI EndBlock cfiBlock3
        REQUIRE ?Subroutine5
        REQUIRE ENCCS
        REQUIRE ENCDI
        REQUIRE ENCDO
        ; // Fall through to label ?Subroutine5
//  287   }
//  288 #endif
//  289 
//  290   HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD.crcRC, 4);
//  291 
//  292   ublMD.crcShdw = ublMD.crcRC;
//  293   ublMD.crcRC = UBL_CRC_ERASED;  // Do not write zero to the same bits more than twice.
//  294   HalFlashWrite(UBL_META_DATA_ADDR_WR, (uint8 *)&ublMD.crcRC, 1);
//  295 
//  296   testpoint = 1;
//  297   return TRUE;
//  298 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine5:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 59)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI Invalid
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Valid
        LJMP    ??Subroutine29_0 & 0xFFFF
          CFI EndBlock cfiBlock4

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine20:
          CFI Block cfiCond5 Using cfiCommon0
          CFI Function ublAesAuth
          CFI Conditional ??CrossCallReturnLabel_27
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 59)
          CFI Block cfiCond6 Using cfiCommon0
          CFI (cfiCond6) Function ublAesAuth
          CFI (cfiCond6) Conditional ??CrossCallReturnLabel_26
          CFI (cfiCond6) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond6) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond6) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond6) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond6) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond6) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond6) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond6) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond6) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond6) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond6) CFA_SP SP+-2
          CFI (cfiCond6) CFA_XSP16 add(XSP16, 59)
          CFI Block cfiPicker7 Using cfiCommon1
          CFI (cfiPicker7) NoFunction
          CFI (cfiPicker7) Picker
        MOV     A,#pgBuf & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#(pgBuf >> 8) & 0xff
        LCALL   ??Subroutine28_0 & 0xFFFF
??CrossCallReturnLabel_38:
        INC     R0
        MOV     A,R0
        RET
          CFI (cfiCond5) CFA_SP SP+0
          CFI (cfiCond6) CFA_SP SP+0
          CFI (cfiPicker7) CFA_SP SP+0
          CFI EndBlock cfiCond5
          CFI EndBlock cfiCond6
          CFI EndBlock cfiPicker7
//  299 
//  300 /**************************************************************************************************
//  301  * @fn          ublAesCrypt
//  302  *
//  303  * @brief       UBL AES encryption/decyption for the low-level transport driver.
//  304  *              Just return when no valid security key built into the UBL.
//  305  *
//  306  * input parameters
//  307  *
//  308  * @param       pgNum - HAL Flash page number corresponding to the pgBuf.
//  309  * @param       pgBuf - Pointer to the page buffer to crypt in place.
//  310  *
//  311  * output parameters
//  312  *
//  313  * @param       pgBuf - Pointer to the page buffer of crypted bytes.
//  314  *
//  315  * @return      TRUE or FALSE whether the AES image page is valid (i.e. the ctrl block on 1st page).
//  316  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  317 uint8 ublAesCrypt(uint8 pgNum, uint8 *pgBuf)
ublAesCrypt:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function ublAesCrypt
        CODE
//  318 {
        FUNCALL ublAesCrypt, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 47, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 47, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 33
        MOV     A,#-0x21
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 45)
        MOV     ?V0,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  319 #if UBL_SECURE
//  320   if (!UBL_SIGNER || signMode)
        MOV     DPTR,#??signMode
        MOVX    A,@DPTR
        JNZ     $+5
        LJMP    ??ublAesCrypt_0 & 0xFFFF
//  321   {
//  322     // A0: L-encoding of L-1 = 2-1 = 1; starting 2-byte CTR at 1.
//  323     uint8 ivNonce[KEY_BLENGTH] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };//
        MOV     DPTR,#`?<Constant {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0`
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP102_8
        MOV     A,#0x10
        LCALL   ?MOVE_LONG8_XDATA_XDATA
//  324     uint8 *pBuf = pgBuf;
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
//  325 
//  326     ENCCS = CTR | AES_LOAD_IV | 0x01;
        MOV     0xb3,#0x37
//  327 
//  328     // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  329     // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  330     ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
//  331 
//  332     for (uint8 idx = 0; idx < KEY_BLENGTH; idx++)
        MOV     R4,#0x0
//  333     {
//  334       ENCDI = ivNonce[idx];
??ublAesCrypt_1:
        MOV     A,R4
        MOV     R2,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOV     A,DPL
        ADD     A,R2
        MOV     DPL,A
        CLR     A
        ADDC    A,DPH
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     0xb1,A
//  335     }
        INC     R4
        MOV     A,R4
        CLR     C
        SUBB    A,#0x10
        JC      ??ublAesCrypt_1
//  336     while ((ENCCS & BV(3)) == 0);
??ublAesCrypt_2:
        MOV     A,0xb3
        MOV     C,0xE0 /* A   */.3
        JNC     ??ublAesCrypt_2
//  337 
//  338     for (uint8 cnt = 0; cnt < (HAL_FLASH_PAGE_SIZE / KEY_BLENGTH); cnt++)
        MOV     R5,#-0x80
//  339     {
//  340       ENCCS = CTR | AES_ENCRYPT | 0x01;
??ublAesCrypt_3:
        MOV     0xb3,#0x31
//  341 
//  342       // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  343       // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  344       ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
//  345 
//  346       for (uint8 blk = 0; blk < 4; blk++)
        MOV     R4,#0x4
//  347       {
//  348         for (uint8 idx = 0; idx < 4; idx++)
??ublAesCrypt_4:
        MOV     ?V1,#0x0
//  349         {
//  350           ENCDI = pBuf[idx];
??ublAesCrypt_5:
        MOV     R2,?V1
        MOV     A,R0
        ADD     A,R2
        LCALL   ?Subroutine27 & 0xFFFF
//  351         }
??CrossCallReturnLabel_39:
        INC     ?V1
        MOV     A,?V1
        CLR     C
        SUBB    A,#0x4
        JC      ??ublAesCrypt_5
//  352 
//  353         HAL_AES_DELAY();  // Delay required for non-DMA AES as RDY bit only goes hi after read out.
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0xf
        MOVX    @DPTR,A
??ublAesCrypt_6:
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,#-0x1
        ADD     A,R2
        MOVX    @DPTR,A
        INC     A
        JNZ     ??ublAesCrypt_6
//  354 
//  355         for (uint8 idx = 0; idx < 4; idx++)
        MOV     ?V1,#0x0
//  356         {
//  357           pBuf[idx] = ENCDO;
??ublAesCrypt_7:
        MOV     A,0xb2
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     R2,?V1
        MOV     A,R0
        ADD     A,R2
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  358         }
        INC     ?V1
        MOV     A,?V1
        CLR     C
        SUBB    A,#0x4
        JC      ??ublAesCrypt_7
//  359 
//  360         pBuf += 4;
        MOV     A,R0
        ADD     A,#0x4
        MOV     R0,A
        JNC     ??ublAesCrypt_8
        INC     R1
//  361       }
??ublAesCrypt_8:
        DEC     R4
        MOV     A,R4
        JNZ     ??ublAesCrypt_4
//  362     }
        DEC     R5
        MOV     A,R5
        JNZ     ??ublAesCrypt_3
//  363 
//  364     if ((pgNum == UBL_PAGE_FIRST) && !aesCheckCtrl(pgBuf))
        MOV     A,#0x1
        XRL     A,?V0
        JNZ     ??ublAesCrypt_0
        MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP102_8
        MOV     A,#0x10
        LCALL   ?MOVE_LONG8_XDATA_XDATA
        ; Setup parameters for call to function memcmp
        MOV     ?V2,#0x10
        MOV     ?V3,A
        MOV     R0,#?V2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 47)
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP102_8
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   `??memcmp::?relay`   ; Banked call to: memcmp
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 45)
        MOV     ?V3,R3
        MOV     A,R2
        ORL     A,?V3
        JNZ     ??ublAesCrypt_9
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        JZ      ??ublAesCrypt_9
        CLR     C
        SUBB    A,#0x77
        JNC     ??ublAesCrypt_9
        MOV     A,R6
        ADD     A,#0x15
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        JNZ     ??ublAesCrypt_0
//  365     {
//  366       return FALSE;
??ublAesCrypt_9:
        MOV     R1,#0x0
        SJMP    ??ublAesCrypt_10
//  367     }
//  368   }
//  369 #else
//  370   (void)pgNum;
//  371   (void)pgBuf;
//  372 #endif
//  373 
//  374   return TRUE;
??ublAesCrypt_0:
        MOV     R1,#0x1
??ublAesCrypt_10:
        MOV     A,#0x21
        LJMP    ?Subroutine3 & 0xFFFF
          CFI EndBlock cfiBlock8
        REQUIRE ENCCS
        REQUIRE ENCDI
        REQUIRE ENCDO
//  375 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine27:
          CFI Block cfiCond9 Using cfiCommon0
          CFI Function ublAesCrypt
          CFI Conditional ??CrossCallReturnLabel_39
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 45)
          CFI Block cfiCond10 Using cfiCommon0
          CFI (cfiCond10) Function ??aesInitSig
          CFI (cfiCond10) Conditional ??CrossCallReturnLabel_40
          CFI (cfiCond10) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond10) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond10) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond10) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond10) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond10) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond10) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond10) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond10) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond10) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond10) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond10) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond10) CFA_SP SP+-2
          CFI (cfiCond10) CFA_XSP16 add(XSP16, 48)
          CFI Block cfiPicker11 Using cfiCommon1
          CFI (cfiPicker11) NoFunction
          CFI (cfiPicker11) Picker
        MOV     DPL,A
        CLR     A
          CFI EndBlock cfiCond9
          CFI EndBlock cfiCond10
          CFI EndBlock cfiPicker11
        REQUIRE ??Subroutine28_0
        ; // Fall through to label ??Subroutine28_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine28_0:
          CFI Block cfiCond12 Using cfiCommon0
          CFI Function ublAesAuth
          CFI Conditional ??CrossCallReturnLabel_38, ??CrossCallReturnLabel_27
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-4
          CFI CFA_XSP16 add(XSP16, 59)
          CFI Block cfiCond13 Using cfiCommon0
          CFI (cfiCond13) Function ublAesAuth
          CFI (cfiCond13) Conditional ??CrossCallReturnLabel_38, ??CrossCallReturnLabel_26
          CFI (cfiCond13) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond13) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond13) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond13) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond13) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond13) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond13) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond13) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond13) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond13) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond13) CFA_SP SP+-4
          CFI (cfiCond13) CFA_XSP16 add(XSP16, 59)
          CFI Block cfiCond14 Using cfiCommon0
          CFI (cfiCond14) Function ublAesCrypt
          CFI (cfiCond14) Conditional ??CrossCallReturnLabel_39
          CFI (cfiCond14) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond14) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond14) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond14) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond14) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond14) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond14) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond14) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond14) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond14) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond14) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond14) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond14) CFA_SP SP+-2
          CFI (cfiCond14) CFA_XSP16 add(XSP16, 45)
          CFI Block cfiCond15 Using cfiCommon0
          CFI (cfiCond15) Function ??aesInitSig
          CFI (cfiCond15) Conditional ??CrossCallReturnLabel_40
          CFI (cfiCond15) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond15) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond15) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond15) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond15) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond15) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond15) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond15) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond15) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond15) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond15) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond15) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond15) CFA_SP SP+-2
          CFI (cfiCond15) CFA_XSP16 add(XSP16, 48)
          CFI Block cfiPicker16 Using cfiCommon1
          CFI (cfiPicker16) NoFunction
          CFI (cfiPicker16) Picker
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     0xb1,A
        RET
          CFI (cfiCond12) CFA_SP SP+-2
          CFI (cfiCond13) CFA_SP SP+-2
          CFI (cfiCond14) CFA_SP SP+0
          CFI (cfiCond15) CFA_SP SP+0
          CFI (cfiPicker16) CFA_SP SP+0
          CFI EndBlock cfiCond12
          CFI EndBlock cfiCond13
          CFI EndBlock cfiCond14
          CFI EndBlock cfiCond15
          CFI EndBlock cfiPicker16
//  376 
//  377 /**************************************************************************************************
//  378  * @fn          ublCfg
//  379  *
//  380  * @brief       Configure according to the received meta-data file if it checks out.
//  381  *
//  382  * input parameters
//  383  *
//  384  * @param       pMD - Pointer to the received meta-data file.
//  385  *
//  386  * output parameters
//  387  *
//  388  * None.
//  389  *
//  390  * @return      TRUE if the cfg file is acceptable; FALSE otherwise.
//  391  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  392 bool ublCfg(ublMetaData_t *pMD)
ublCfg:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function ublCfg
        CODE
//  393 {
        FUNCALL ublCfg, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublCfg, ublMassErase
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublCfg, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublCfg, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  394   // Thwart an attempt to break-in by an exhaustive Security Key trial-and-error.
//  395   if (!UBL_UNLOCKED && (memcmp(&ublMD.secKey, &pMD->secKey, sizeof(ublMD.secKey)) != 0))
        MOV     DPTR,#ublMD + 99
        MOVX    A,@DPTR
        JZ      ??ublCfg_0
        ; Setup parameters for call to function memcmp
        MOV     ?V0,#0x20
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R6
        ADD     A,#0x8
        MOV     R4,A
        CLR     A
        ADDC    A,R7
        MOV     R5,A
        MOV     R2,#(ublMD + 8) & 0xff
        MOV     R3,#((ublMD + 8) >> 8) & 0xff
        LCALL   `??memcmp::?relay`   ; Banked call to: memcmp
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V1,R3
        MOV     A,R2
        ORL     A,?V1
        JZ      ??ublCfg_0
//  396   {
//  397     if (ublMD.cntDnSecKey == 0)
        MOV     DPTR,#ublMD + 96
        MOVX    A,@DPTR
        MOV     R1,A
        JNZ     ??ublCfg_1
//  398     {
//  399       ublMassErase(TRUE);  // Force the erase of all pages outside of the UBL image.
        ; Setup parameters for call to function ublMassErase
        MOV     R1,#0x1
        LCALL   `??ublMassErase::?relay`; Banked call to: ublMassErase
//  400       HAL_SYSTEM_RESET();
        CLR     0xa8.7
        MOV     0xc9,#-0x55
        MOV     0xc9,#0x5b
??ublCfg_2:
        SJMP    ??ublCfg_2
//  401     }
//  402     else
//  403     {
//  404       uint8 mask = 0x01;
??ublCfg_1:
        MOV     R0,#0x1
        SJMP    ??ublCfg_3
//  405 
//  406       while ((mask & ublMD.cntDnSecKey) == 0)
//  407       {
//  408         mask <<= 1;
??ublCfg_4:
        MOV     A,R0
        CLR     C
        RLC     A
        MOV     R0,A
//  409       }
??ublCfg_3:
        MOV     A,R0
        ANL     A,R1
        JZ      ??ublCfg_4
//  410       ublMD.cntDnSecKey ^= mask;
        MOVX    A,@DPTR
        XRL     A,R0
        MOVX    @DPTR,A
//  411 
//  412       // This will write zero to exactly one bit, so no bit is written to zero twice.
//  413       uint8 secKeyAndPad[4] = { 0xFF, 0xFF, 0xFF, 0xFF };
        MOV     DPTR,#`?<Constant {255, 255, 255, 255}>`
        MOV     R4,?XSP + 0
        MOV     R5,?XSP + 1
        MOV     A,#0x4
        LCALL   ?MOVE_LONG8_XDATA_XDATA
//  414       secKeyAndPad[0] ^= mask;
        LCALL   ?Subroutine14 & 0xFFFF
//  415       HalFlashWrite(UBL_CNTDN_SECKEY_ADDR, secKeyAndPad, 1);
//  416     }
//  417   }
??CrossCallReturnLabel_16:
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP102_8
        MOV     R2,#-0x41
        MOV     R3,#0x3
        LCALL   `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  418   else
//  419   {
//  420     UBL_UNLOCK();
//  421     (void)memcpy(&ublMD.chkMD, &pMD->chkMD, UBL_MD_CHKLEN);
//  422     ublMD.crcShdw = UBL_CRC_ZEROED;  // Receiving a "cfg" file is a de facto force of UBL mode.
//  423     return TRUE;
//  424   }
//  425 
//  426   return FALSE;
        MOV     R1,#0x0
        SJMP    ??ublCfg_5
??ublCfg_0:
        MOV     DPTR,#ublMD + 99
        CLR     A
        MOVX    @DPTR,A
        ; Setup parameters for call to function memcpy
        MOV     ?V0,#0x58
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R6
        ADD     A,#0x4
        MOV     R4,A
        CLR     A
        ADDC    A,R7
        MOV     R5,A
        MOV     R2,#(ublMD + 4) & 0xff
        MOV     R3,#((ublMD + 4) >> 8) & 0xff
        LCALL   `??memcpy::?relay`   ; Banked call to: memcpy
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     DPTR,#ublMD + 2
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
        MOV     R1,#0x1
??ublCfg_5:
        MOV     A,#0x4
        LJMP    ?Subroutine5 & 0xFFFF
          CFI EndBlock cfiBlock17
        REQUIRE _A_IEN0
        REQUIRE WDCTL
//  427 }
//  428 
//  429 /**************************************************************************************************
//  430  * @fn          ublExec
//  431  *
//  432  * @brief       UBL executive loop for polling and managing environment.
//  433  *
//  434  * input parameters
//  435  *
//  436  * None.
//  437  *
//  438  * output parameters
//  439  *
//  440  * None.
//  441  *
//  442  * @return      None.
//  443  */
//  444 void ublExec(void)
//  445 {

        RSEG XDATA_I:XDATA:NOROOT(0)
//  446   static int i = 1;
??i:
        DATA16
        DS 2
        REQUIRE `?<Initializer for i>`
        REQUIRE __INIT_XDATA_I
//  447   while (1)
//  448   {
//  449     // No continual waits for VDD_MIN_NV - Vdd is assumed to be stable on a USB-powered device.
//  450     vddWait();
//  451 
//  452     if (usb_msd_poll() == TRUE)  // TRUE == "Eject".
//  453     {
//  454       break;
//  455     }
//  456 
//  457     if ((ublMD.dlyJmp != 0))//(UBL_RC_VALID||(ublMD.crcShdw!=0xFFFF)) && 
//  458     {
//  459 /*#if defined UBL_GPIO_USE
//  460       if (!GET_BIT(ublMD.cfgDiscs+0, gpioUseNot) &&
//  461           (GET_BIT(ublMD.cfgDiscs+0, gpioPolarity) == ((*pForcePort & BV(forcePin)) != 0)))
//  462       {
//  463         ublMD.crcShdw = UBL_CRC_ZEROED;
//  464       }
//  465       else
//  466 #endif*/
//  467       {
//  468         uint32 stDelta;
//  469         UBL_READ_ST(stDelta);  // Get the free-running count of 30.5 usec timer ticks.
//  470         stDelta -= stStart;  // Calculate the elapsed ticks of the free-running timer.
//  471         ((uint8 *)&stDelta)[3] = 0;  // Adjust for a carry on the 24-bit ST counter.
//  472 
//  473 	if(stDelta/0x28000 == i) //(1 * 4096UL) / 125;  == 1ms
//  474         {
//  475           i++;
//  476           P0_6 ^= 1;
//  477         }
//  478         if ((stDelta > stDelay) && (have_data == 0))
//  479         {
//  480           P1_0 = 0x0;
//  481         }
//  482       }
//  483      if(UBL_RC_VALID)
//  484         break;
//  485     }
//  486   }
//  487 
//  488   if (UBL_RC_VALID)
//  489   {
//  490     usb_msd_uninit();
//  491     ublJump();
//  492   }
//  493 }
//  494 
//  495 /**************************************************************************************************
//  496  * @fn          ublInit
//  497  *
//  498  * @brief       UBL environment initialization in preparation for running.
//  499  *
//  500  * input parameters
//  501  *
//  502  * None.
//  503  *
//  504  * output parameters
//  505  *
//  506  * None.
//  507  *
//  508  * @return      None.
//  509  */
//  510 void ublInit(void)
//  511 {
//  512   HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD, sizeof(ublMetaData_t));
//  513 
//  514   // If the RC image area is erased or the Application doesn't care about security, unlock the UBL.
//  515   if (memcmp(ublMD.secKey, unlockedSecKey, sizeof(unlockedSecKey)) == 0)
//  516   {
//  517     UBL_UNLOCK();
//  518   }
//  519 
//  520   if (UBL_RC_VALID)
//  521   {
//  522     if ((ublMD.cntDnForced == 0) || (cntDnForcedDecr() == FALSE))
//  523     {
//  524 #if defined UBL_GPIO_USE
//  525       if (GET_BIT(ublMD.cfgDiscs+0, gpioUseNot) || (gpioInit() == FALSE))
//  526 #endif
//  527       {
//  528 //       if (ublMD.dlyJmp == 0)
//  529         {
//  530           ublJump();
//  531         }
//  532 //        else
//  533 //        {
//  534 //          stDelay = (ublMD.dlyJmp * 4096UL) / 125;
//  535 //          UBL_READ_ST(stStart);
//  536 //        }
//  537       }
//  538     }
//  539   }
//  540     if(ublMD.dlyJmp == 0x00||ublMD.dlyJmp == 0xFFFF)
//  541       ublMD.dlyJmp = 60000;
//  542   
//  543     stDelay = 3*(ublMD.dlyJmp * 4096UL) / 125;
//  544     UBL_READ_ST(stStart);
//  545 
//  546   vddWait();  // Stricter wait then in main, looking for safe Vdd for writing flash.
//  547 
//  548 #if UBL_SECURE
//  549   aesLoadKey();
//  550 
//  551   aes_ctrl_blk_t ctrlBlk;
//  552   UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
//  553 
//  554   if ((ctrlBlk.allowSignCmd != 0) && (ctrlBlk.imageLen != 0xFF)) // If requested to sign this image.
//  555   {
//  556     // Signing after checking UBL_RC_VALID ensures run as MSD again so encrypted image can be read.
//  557     (void)ublAesAuth();
//  558   }
//  559 
//  560 #if UBL_SIGNER  // A signer must allow image read back of what was written.
//  561   for (uint8 idx = 0; idx < 16; idx++)
//  562   {
//  563     ublMD.readLock[idx] = ublMD.writeEn[idx] ^ 0xFF;
//  564   }
//  565 #endif
//  566 #endif
//  567   
//  568   usb_msd_init();  // Initialize USB-MSD as late as possible for time limits after enabling D+ line.
//  569   ublMassErase(1);
//  570 }
//  571 
//  572 /**************************************************************************************************
//  573  * @fn          ublJump
//  574  *
//  575  * @brief       Execute a simple long jump from non-banked UBL code to non-banked RC code space.
//  576  *
//  577  * input parameters
//  578  *
//  579  * None.
//  580  *
//  581  * output parameters
//  582  *
//  583  * None.
//  584  *
//  585  * @return      None.
//  586  */
//  587 void ublJump(void)
//  588 {
//  589   asm("LJMP 0x820\n");  // Immediate jump to run-code.
//  590   HAL_SYSTEM_RESET();
//  591 }
//  592 
//  593 /**************************************************************************************************
//  594  * @fn          ublMassErase
//  595  *
//  596  * @brief       Erase all pages enabled for mass-erase (not including UBL pages or lock bits page).
//  597  *
//  598  * input parameters
//  599  *
//  600  * @param       eraseAll - Flag to override the 'eraseEn' bits of the Meta Data.
//  601  *
//  602  * output parameters
//  603  *
//  604  * None.
//  605  *
//  606  * @return      None.
//  607  */
//  608 void ublMassErase(bool eraseAll)
//  609 {
//  610   for (uint8 pg = UBL_RC_IMG_PG_BEG+1; pg <= UBL_PAGE_LAST; pg++)
//  611   {
//  612     if (eraseAll || GET_BIT(ublMD.eraseEn, pg))
//  613     {
//  614       FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
//  615       FCTL |= 0x01;
//  616     }
//  617   }
//  618 
//  619   // Now erase the page with the filename.
//  620   FADDRH = UBL_RC_IMG_PG_BEG * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
//  621   FCTL |= 0x01;
//  622 }
//  623 
//  624 #if UBL_SECURE
//  625 /**************************************************************************************************
//  626  * @fn          aesCheckCtrl
//  627  *
//  628  * @brief       Check validity of a AES Control Block before writing it to flash.
//  629  *
//  630  * input parameters
//  631  *
//  632  * @param       pBuf - Pointer to the buffer containing the control block.
//  633  *
//  634  * output parameters
//  635  *
//  636  * None.
//  637  *
//  638  * @return      TRUE or FALSE for control block valid.
//  639  */
//  640 static uint8 aesCheckCtrl(void *pBuf)
//  641 {
//  642   uint8 sigBuf[KEY_BLENGTH] =
//  643    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
//  644   aes_ctrl_blk_t *pCtl = (aes_ctrl_blk_t *)pBuf;
//  645 
//  646 #if UBL_SIGNER
//  647   if ( memcmp(pCtl->signature, sigBuf, sizeof(sigBuf))
//  648           || (pCtl->imageLen == 0)
//  649           || (pCtl->imageLen > UBL_PAGE_LAST)
//  650           || (pCtl->allowSignCmd == 0))
//  651 #else
//  652   if (!memcmp(pCtl->signature, sigBuf, sizeof(sigBuf))
//  653           || (pCtl->imageLen == 0)
//  654           || (pCtl->imageLen > UBL_PAGE_LAST)
//  655           || (pCtl->allowSignCmd != 0))
//  656 #endif
//  657   {
//  658     return FALSE;
//  659   }
//  660 
//  661   return TRUE;
//  662 }
//  663 
//  664 /**************************************************************************************************
//  665  * @fn          aesLoadKey
//  666  *
//  667  * @brief       Load the shared secret key into the AES for operations.
//  668  *
//  669  * input parameters
//  670  *
//  671  * None.
//  672  *
//  673  * output parameters
//  674  *
//  675  * None.
//  676  *
//  677  * @return      None.
//  678  */
//  679 static void aesLoadKey(void)
//  680 {
//  681   // Read the security key from flash 1 byte at a time to thwart an interrupt & read XDATA attack.
//  682   uint8 *keyPtr = (uint8 *)aesKey;
//  683 
//  684   ENCCS = ECB | AES_LOAD_KEY | 0x01;
//  685 
//  686   // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  687   // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  688   ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
//  689 
//  690   for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
//  691   {
//  692     ENCDI = *keyPtr++;
//  693   } 
//  694 }
//  695 
//  696 /**************************************************************************************************
//  697  * @fn          aesInitSig
//  698  *
//  699  * @brief       Initialize the AES for signature calculation.
//  700  *
//  701  * input parameters
//  702  *
//  703  * None.
//  704  *
//  705  * output parameters
//  706  *
//  707  * None.
//  708  *
//  709  * @return      None.
//  710  */
//  711 static void aesInitSig(void)
//  712 {
//  713   aes_ctrl_blk_t ctrlBlk;
//  714   UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
//  715 
//  716   ENCCS = CBC_MAC | AES_LOAD_IV | 0x01;
//  717 
//  718   // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  719   // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  720   ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
//  721 
//  722   for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
//  723   {
//  724     ENCDI = 0;
//  725   }
//  726 
//  727   ENCCS = CBC_MAC | AES_ENCRYPT | 0x01;
//  728 
//  729   // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  730   // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  731   ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
//  732 
//  733   ENCDI = 0x3A;  // B0 Flag: Res=0, A_Data=0, (M-2)/2=7, (L-1)=2.
//  734 
//  735   ENCDI = LO_UINT16(ctrlBlk.spare[0]);
//  736   ENCDI = HI_UINT16(ctrlBlk.spare[0]);
//  737   for (uint8 idx = 0; idx < 10; idx++)
//  738   {
//  739     ENCDI = ctrlBlk.nonce10[idx];
//  740   }
//  741 
//  742   // Image length in 3 bytes, MSB to LSB order - the Signature bytes are not to be included.
//  743   uint32 imageLen = 2048UL * ctrlBlk.imageLen - KEY_BLENGTH;
//  744   ENCDI = ((uint8 *)&imageLen)[2];
//  745   ENCDI = ((uint8 *)&imageLen)[1];
//  746   ENCDI = ((uint8 *)&imageLen)[0];
//  747   
//  748   while ((ENCCS & BV(3)) == 0);
//  749 }
//  750 #endif
//  751 
//  752 /**************************************************************************************************
//  753  * @fn          cntDnForcedDecr
//  754  *
//  755  * @brief       Decrement the cntDnForced.
//  756  *
//  757  * input parameters
//  758  *
//  759  * None.
//  760  *
//  761  * output parameters
//  762  *
//  763  * None.
//  764  *
//  765  * @return      TRUE if the dlyJmp decrements to zero; FALSE otherwise.
//  766  */
//  767 static bool cntDnForcedDecr(void)
//  768 {
//  769   uint8 mask = 0x01;
//  770 
//  771   while ((mask & ublMD.cntDnForced) == 0)
//  772   {
//  773     mask <<= 1;
//  774   }
//  775   ublMD.cntDnForced ^= mask;
//  776 
//  777   if (ublMD.cntDnForced == 0)
//  778   {
//  779     // Don't write the zero to flash in case of another cold-boot before re-programming, just
//  780     // force boot now by faking the CRC-shdw as zeroed.
//  781     ublMD.crcShdw = UBL_CRC_ZEROED;  // No need to zero crcShdw in flash, this will always run.
//  782     return TRUE;
//  783   }
//  784   else
//  785   {
//  786     // This will write zero to exactly one bit, so no bit is written to zero twice.
//  787     uint8 forcedAndPad[4] = { 0xFF, 0xFF, 0xFF, 0xFF };
//  788     forcedAndPad[0] ^= mask;
//  789     HalFlashWrite(UBL_CNTDN_FORCED_ADDR, forcedAndPad, 1);
//  790     return FALSE;
//  791   }
//  792 }
//  793 
//  794 #if defined UBL_GPIO_USE
//  795 /**************************************************************************************************
//  796  * @fn          gpioInit
//  797  *
//  798  * @brief       Initialize the generic GPIO force configuration.
//  799  *
//  800  * input parameters
//  801  *
//  802  * None.
//  803  *
//  804  * output parameters
//  805  *
//  806  * None.
//  807  *
//  808  * @return      TRUE if the GPIO is already forcing UBL mode; FALSE otherwise.
//  809  */
//  810 static bool gpioInit(void)
//  811 {
//  812   volatile uint8 *ptr;
//  813   uint8 port = ublMD.gpioPort / 8;
//  814   uint8 pin = ublMD.gpioPort % 8;
//  815 
//  816   ptr = ((port == 0) ? &X_P0SEL : ((port == 1) ? &X_P1SEL : &X_P2SEL));
//  817   *ptr &= ~BV(pin);
//  818 
//  819   ptr = ((port == 0) ? &X_P0DIR : ((port == 1) ? &X_P1DIR : &X_P2DIR));
//  820   *ptr &= ~BV(pin);
//  821 
//  822   ptr = ((port == 0) ? &X_P0INP : ((port == 1) ? &X_P1INP : &X_P2INP));
//  823   if (GET_BIT(ublMD.cfgDiscs+0, gpioPullTri))     // If pulling.
//  824   {
//  825     if (GET_BIT(ublMD.cfgDiscs+0, gpioPullUpDn))  // If pulling up.
//  826     {
//  827       P2INP &= ~BV(port + 5);
//  828     }
//  829     else                                          // If pulling down.
//  830     {
//  831       P2INP |= BV(port + 5); \ 
//  832     }
//  833     *ptr &= ~BV(pin);
//  834   }
//  835   else                                            // Tri-state.
//  836   {
//  837     *ptr |=  BV(pin);
//  838   }
//  839 
//  840   forcePin = pin;
//  841   pForcePort = ((port == 0) ? &X_P0 : ((port == 1) ? &X_P1 : &X_P2));
//  842 
//  843   if (GET_BIT(ublMD.cfgDiscs+0, gpioPolarity) == ((*pForcePort & BV(forcePin)) != 0))
//  844   {
//  845     ublMD.crcShdw = UBL_CRC_ZEROED;
//  846     return TRUE;
//  847   }
//  848 
//  849   return FALSE;
//  850 }
//  851 #endif
//  852 
//  853 /**************************************************************************************************
//  854  * @fn          vddWait
//  855  *
//  856  * @brief       Loop waiting for 16 reads of the Vdd over the safe minimum to erase/write flash.
//  857  *
//  858  * input parameters
//  859  *
//  860  * None.
//  861  *
//  862  * output parameters
//  863  *
//  864  * None.
//  865  *
//  866  * @return      None.
//  867  */
//  868 static void vddWait(void)
//  869 {
//  870   uint8 cnt = 16;
//  871 
//  872   do {
//  873     do {
//  874       ADCCON3 = 0x0F;
//  875       while (!(ADCCON1 & 0x80));
//  876     } while (ADCH < VDD_MIN_NV);
//  877   } while (--cnt);
//  878 }
//  879 
//  880 /**************************************************************************************************
//  881 */
// C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_main.c
//    1 /******************************************************************************
//    2 
//    3  @file  ubl_main.c
//    4 
//    5  @brief This module implements the main functionality of a Universal Boot
//    6         Loader for an 8051-based SOC via the USB by MSD. The functionality is
//    7         similar to ZStack OnBoard.c and hal_startup.c.
//    8 
//    9  Group: WCS, BTS
//   10  Target Device: CC2540, CC2541
//   11 
//   12  ******************************************************************************
//   13  
//   14  Copyright (c) 2011-2016, Texas Instruments Incorporated
//   15  All rights reserved.
//   16 
//   17  IMPORTANT: Your use of this Software is limited to those specific rights
//   18  granted under the terms of a software license agreement between the user
//   19  who downloaded the software, his/her employer (which must be your employer)
//   20  and Texas Instruments Incorporated (the "License"). You may not use this
//   21  Software unless you agree to abide by the terms of the License. The License
//   22  limits your use, and you acknowledge, that the Software may not be modified,
//   23  copied or distributed unless embedded on a Texas Instruments microcontroller
//   24  or used solely and exclusively in conjunction with a Texas Instruments radio
//   25  frequency transceiver, which is integrated into your product. Other than for
//   26  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   27  works of, modify, distribute, perform, display or sell this Software and/or
//   28  its documentation for any purpose.
//   29 
//   30  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   31  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   32  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   33  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   34  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   35  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   36  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   37  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   38  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   39  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   40  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   41 
//   42  Should you have any questions regarding your right to use this Software,
//   43  contact Texas Instruments Incorporated at www.TI.com.
//   44 
//   45  ******************************************************************************
//   46  Release Name: ble_sdk_1.4.2.2
//   47  Release Date: 2016-06-09 06:57:10
//   48  *****************************************************************************/
//   49 
//   50 /* ------------------------------------------------------------------------------------------------
//   51  *                                          Includes
//   52  * ------------------------------------------------------------------------------------------------
//   53  */
//   54 
//   55 #include "hal_board_cfg.h"
//   56 #include "hal_dma.h"
//   57 #include "hal_flash.h"
//   58 #include "ubl_app.h"
//   59 #include "ubl_exec.h"
//   60 #include "usb_interrupt.h"
//   61 
//   62 /* ------------------------------------------------------------------------------------------------
//   63  *                                       Global Variables
//   64  * ------------------------------------------------------------------------------------------------
//   65  */
//   66 

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA8
//   67 __no_init halDMADesc_t dmaCh0;  // Needed by the HAL flash write.
dmaCh0:
        DS 8

        RSEG NEAR_CODE:CODE:ROOT(0)
__low_level_init:
          CFI Block cfiBlock18 Using cfiCommon2
          CFI Function __low_level_init
        CODE
        REQUIRE __low_level_init_call
        FUNCALL __low_level_init, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL __low_level_init, ublJump
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        ORL     0xc7,#0x7
        MOV     A,0x9d
        ANL     A,#0x18
        XRL     A,#0x10
        JNZ     ??__low_level_init_0
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x4
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 11)
        MOV     R4,#ublMD & 0xff
        MOV     R5,#(ublMD >> 8) & 0xff
        MOV     R2,#-0x64
        MOV     R3,#0x6
        MOV     R1,#0x1
        LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 9)
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??__low_level_init_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??__low_level_init_1:
        JNZ     ??__low_level_init_0
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        CPL     A
        JNZ     ??__low_level_init_2
        INC     DPTR
        MOVX    A,@DPTR
        CPL     A
??__low_level_init_2:
        JZ      ??__low_level_init_0
        MOV     A,R0
        ORL     A,R1
        JZ      ??__low_level_init_0
        ; Setup parameters for call to function ublJump
        LCALL   `??ublJump::?relay`  ; Banked call to: ublJump
??__low_level_init_0:
        MOV     R0,#0x10
??__low_level_init_3:
        MOV     0xb6,#0xf
??__low_level_init_4:
        MOV     A,0xb4
        MOV     C,0xE0 /* A   */.7
        JNC     ??__low_level_init_4
        MOV     A,0xbb
        CLR     C
        SUBB    A,#0x4a
        JC      ??__low_level_init_3
        DEC     R0
        MOV     A,R0
        JNZ     ??__low_level_init_3
        MOV     0xa8,#0x0
        MOV     0xb8,#0x0
        MOV     0x9a,#0x0
        MOV     0xc6,#-0x80
        MOV     DPTR,#0x6270
        MOV     A,#0x8
        MOVX    @DPTR,A
        MOV     R1,#0x1
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
          CFI R6 SameValue
          CFI VB SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI R7 SameValue
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 XSP16+0
          CFI EndBlock cfiBlock18
        REQUIRE MEMCTR
        REQUIRE SLEEPSTA
        REQUIRE _A_IEN0
        REQUIRE _A_IEN1
        REQUIRE IEN2
        REQUIRE CLKCONCMD
        REQUIRE ADCCON3
        REQUIRE ADCCON1
        REQUIRE ADCH

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
??usbdpData:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
??languageId:
        DATA8
        DB 4
        DB 3
        DB 9
        DB 4

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
??manufacturer:
        DB 36
        DB 3
        DB 84
        DB 0
        DB 101
        DB 0
        DB 120
        DB 0
        DB 97
        DB 0
        DB 115
        DB 0
        DB 32
        DB 0
        DB 73
        DB 0
        DB 110
        DB 0
        DB 115
        DB 0
        DB 116
        DB 0
        DB 114
        DB 0
        DB 117
        DB 0
        DB 109
        DB 0
        DB 101
        DB 0
        DB 110
        DB 0
        DB 116
        DB 0
        DB 115
        DB 0

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
??product:
        DB 36
        DB 3
        DB 84
        DB 0
        DB 73
        DB 0
        DB 32
        DB 0
        DB 67
        DB 0
        DB 67
        DB 0
        DB 50
        DB 0
        DB 53
        DB 0
        DB 51
        DB 0
        DB 49
        DB 0
        DB 32
        DB 0
        DB 85
        DB 0
        DB 83
        DB 0
        DB 66
        DB 0
        DB 32
        DB 0
        DB 77
        DB 0
        DB 83
        DB 0
        DB 68
        DB 0

        RSEG XDATA_I:XDATA:NOROOT(0)
??serialNumber:
        DATA8
        DS 42
        REQUIRE `?<Initializer for serialNumber>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
hexDigit:
        DB 48
        DB 49
        DB 50
        DB 51
        DB 52
        DB 53
        DB 54
        DB 55
        DB 56
        DB 57
        DB 65
        DB 66
        DB 67
        DB 68
        DB 69
        DB 70

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
// USBFW_DATA usbfwData
usbfwData:
        DS 20
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
// USB_SETUP_DATA usbSetupData
usbSetupData:
        DS 5
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
// USB_SETUP_HEADER usbSetupHeader
usbSetupHeader:
        DS 8
        REQUIRE __INIT_XDATA_Z

        RSEG DATA_Z:DATA:NOROOT(0)
        DATA16
??ProcessFunc:
        DS 2
        REQUIRE __INIT_DATA_Z

        RSEG DATA_Z:DATA:NOROOT(0)
        DATA8
// USBIRQ_DATA __data usbirqData
usbirqData:
        DS 5
        REQUIRE __INIT_DATA_Z

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     0x8b,#0x0
        CLR     0xe8.0
          CFI EndBlock cfiBlock19
        REQUIRE ??Subroutine29_0
        ; // Fall through to label ??Subroutine29_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine29_0:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI CFA_SP SP+-3
          CFI CFA_XSP16 XSP16+0
          CFI VB SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndBlock cfiBlock20

        RSEG BANKED_CODE:CODE:NOROOT(0)
ublExec:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function ublExec
        CODE
        FUNCALL ublExec, ??vddWait
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublExec, usb_msd_poll
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublExec, usb_msd_uninit
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublExec, ublJump
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        REQUIRE ?V10
        REQUIRE ?V11
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
??ublExec_0:
        ; Setup parameters for call to function vddWait
        LCALL   `??vddWait::?relay`  ; Banked call to: vddWait
        ; Setup parameters for call to function usb_msd_poll
        LCALL   `??usb_msd_poll::?relay`; Banked call to: usb_msd_poll
        MOV     A,R1
        XRL     A,#0x1
        JNZ     $+5
        LJMP    ??ublExec_1 & 0xFFFF
        MOV     DPTR,#ublMD + 6
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_52:
        JZ      ??ublExec_0
??ublExec_2:
        MOV     A,0x95
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
        XRL     A,0x95
        JNZ     ??ublExec_2
        MOV     A,0x96
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     A,0x97
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#??stStart
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R0,#?V0
        LCALL   ?L_SUB_FROM_X
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#??i
        LCALL   ?Subroutine13 & 0xFFFF
??CrossCallReturnLabel_14:
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V2,A
        MOV     ?V3,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R0,#?V4
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_28000
        MOV     R0,#?V8
        LCALL   ?L_MOV_X
        MOV     R0,#?V4
        MOV     R1,#?V8
        LCALL   ?UL_DIV_MOD
        MOV     R0,#?V4
        MOV     R1,#?V0
        LCALL   ?L_EQ
        JNZ     ??ublExec_3
        MOV     DPTR,#??i
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
        XRL     0x80,#0x40
??ublExec_3:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPTR,#??stDelay
        MOV     R0,#?V0
        LCALL   ?UL_GT_X
        JNC     ??ublExec_4
        MOV     DPTR,#??have_data
        MOVX    A,@DPTR
        JNZ     ??ublExec_4
        CLR     0x90.0
??ublExec_4:
        LCALL   ?Subroutine10 & 0xFFFF
??CrossCallReturnLabel_4:
        JNZ     ??ublExec_5
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??ublExec_5:
        JZ      $+5
        LJMP    ??ublExec_0 & 0xFFFF
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        CPL     A
        JNZ     ??ublExec_6
        INC     DPTR
        MOVX    A,@DPTR
        CPL     A
??ublExec_6:
        JNZ     $+5
        LJMP    ??ublExec_0 & 0xFFFF
        MOV     A,R0
        ORL     A,R1
        JNZ     ??ublExec_7
        LJMP    ??ublExec_0 & 0xFFFF
??ublExec_1:
        LCALL   ?Subroutine10 & 0xFFFF
??CrossCallReturnLabel_5:
        JNZ     ??ublExec_8
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??ublExec_8:
        JNZ     ??ublExec_9
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        CPL     A
        JNZ     ??ublExec_10
        INC     DPTR
        MOVX    A,@DPTR
        CPL     A
??ublExec_10:
        JZ      ??ublExec_9
??ublExec_7:
        MOV     DPTR,#ublMD
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_53:
        JZ      ??ublExec_9
        ; Setup parameters for call to function usb_msd_uninit
        LCALL   `??usb_msd_uninit::?relay`; Banked call to: usb_msd_uninit
        ; Setup parameters for call to function ublJump
        LCALL   `??ublJump::?relay`  ; Banked call to: ublJump
??ublExec_9:
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
          CFI R6 SameValue
          CFI VB SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI R7 SameValue
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI CFA_SP SP+-3
          CFI CFA_XSP16 XSP16+0
          CFI EndBlock cfiBlock21
        REQUIRE ST0
        REQUIRE ST1
        REQUIRE ST2
        REQUIRE _A_P0
        REQUIRE _A_P1

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine13:
          CFI Block cfiCond22 Using cfiCommon0
          CFI Function HalFlashWrite
          CFI Conditional ??CrossCallReturnLabel_13
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond23 Using cfiCommon0
          CFI (cfiCond23) Function ublExec
          CFI (cfiCond23) Conditional ??CrossCallReturnLabel_14
          CFI (cfiCond23) R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI (cfiCond23) VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond23) V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond23) V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond23) V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond23) V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond23) V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond23) V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond23) V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond23) V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond23) V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond23) V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond23) V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond23) V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond23) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond23) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond23) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond23) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond23) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond23) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond23) CFA_SP SP+-2
          CFI (cfiCond23) CFA_XSP16 add(XSP16, 24)
          CFI Block cfiCond24 Using cfiCommon0
          CFI (cfiCond24) Function ublInit
          CFI (cfiCond24) Conditional ??CrossCallReturnLabel_15
          CFI (cfiCond24) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond24) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond24) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond24) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond24) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond24) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond24) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond24) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond24) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond24) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond24) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond24) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond24) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond24) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond24) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond24) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond24) CFA_SP SP+-2
          CFI (cfiCond24) CFA_XSP16 add(XSP16, 52)
          CFI Block cfiPicker25 Using cfiCommon1
          CFI (cfiPicker25) NoFunction
          CFI (cfiPicker25) Picker
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
        RET
          CFI (cfiCond22) CFA_SP SP+0
          CFI (cfiCond23) CFA_SP SP+0
          CFI (cfiCond24) CFA_SP SP+0
          CFI (cfiPicker25) CFA_SP SP+0
          CFI EndBlock cfiCond22
          CFI EndBlock cfiCond23
          CFI EndBlock cfiCond24
          CFI EndBlock cfiPicker25

        RSEG BANKED_CODE:CODE:NOROOT(0)
ublInit:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function ublInit
        CODE
        FUNCALL ublInit, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 54, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 54, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 54, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 54, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 54, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 54, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, ??gpioInit
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 52, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, ublJump
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 52, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, ??vddWait
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 52, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, ??aesLoadKey
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 52, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 54, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 54, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, ublAesAuth
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 52, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, usb_msd_init
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 52, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, ublMassErase
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 52, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 52, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 36
        MOV     A,#-0x24
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 52)
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x64
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 54)
        MOV     R4,#ublMD & 0xff
        MOV     R5,#(ublMD >> 8) & 0xff
        MOV     R2,#-0x64
        MOV     R3,#0x6
        MOV     R1,#0x1
        LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 52)
        ; Setup parameters for call to function memcmp
        MOV     ?V0,#0x20
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 54)
        MOV     R4,#??unlockedSecKey & 0xff
        MOV     R5,#(??unlockedSecKey >> 8) & 0xff
        MOV     R2,#(ublMD + 8) & 0xff
        MOV     R3,#((ublMD + 8) >> 8) & 0xff
        LCALL   `??memcmp::?relay`   ; Banked call to: memcmp
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 52)
        MOV     ?V1,R3
        MOV     A,R2
        ORL     A,?V1
        JNZ     ??ublInit_0
        MOV     DPTR,#ublMD + 99
        CLR     A
        MOVX    @DPTR,A
??ublInit_0:
        LCALL   ?Subroutine10 & 0xFFFF
??CrossCallReturnLabel_6:
        JNZ     ??ublInit_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??ublInit_1:
        JNZ     ??ublInit_2
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        CPL     A
        JNZ     ??ublInit_3
        INC     DPTR
        MOVX    A,@DPTR
        CPL     A
??ublInit_3:
        JZ      ??ublInit_2
        MOV     A,R0
        ORL     A,R1
        JZ      ??ublInit_2
        MOV     DPTR,#ublMD + 92
        MOVX    A,@DPTR
        MOV     R1,A
        JZ      ??ublInit_4
        MOV     R0,#0x1
        SJMP    ??ublInit_5
??ublInit_6:
        MOV     A,R0
        CLR     C
        RLC     A
        MOV     R0,A
??ublInit_5:
        MOV     A,R0
        ANL     A,R1
        JZ      ??ublInit_6
        MOVX    A,@DPTR
        XRL     A,R0
        MOVX    @DPTR,A
        JNZ     ??ublInit_7
        MOV     DPTR,#ublMD + 2
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
        SJMP    ??ublInit_2
??ublInit_7:
        MOV     DPTR,#`?<Constant {255, 255, 255, 255}>_1`
        MOV     R4,?XSP + 0
        MOV     R5,?XSP + 1
        MOV     A,#0x4
        LCALL   ?MOVE_LONG8_XDATA_XDATA
        LCALL   ?Subroutine14 & 0xFFFF
??CrossCallReturnLabel_17:
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 54)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP102_8
        MOV     R2,#-0x42
        MOV     R3,#0x3
        LCALL   `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 52)
??ublInit_4:
        MOV     DPTR,#ublMD + 88
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JC      ??ublInit_8
        ; Setup parameters for call to function gpioInit
        LCALL   `??gpioInit::?relay` ; Banked call to: gpioInit
        MOV     A,R1
        JNZ     ??ublInit_2
??ublInit_8:
        ; Setup parameters for call to function ublJump
        LCALL   `??ublJump::?relay`  ; Banked call to: ublJump
??ublInit_2:
        MOV     DPTR,#ublMD + 6
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_54:
        JZ      ??ublInit_9
        MOV     A,#-0x1
        XRL     A,R0
        JNZ     ??ublInit_10
        MOV     A,#-0x1
        XRL     A,R1
??ublInit_10:
        JNZ     ??ublInit_11
??ublInit_9:
        MOV     DPTR,#ublMD + 6
        MOV     A,#0x60
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x16
        MOVX    @DPTR,A
??ublInit_11:
        MOV     DPTR,#ublMD + 6
        LCALL   ?Subroutine13 & 0xFFFF
??CrossCallReturnLabel_15:
        CLR     A
        MOV     ?V2,A
        MOV     ?V3,A
        MOV     DPTR,#__Constant_3000
        MOV     R0,#?V4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0
        MOV     R1,#?V4
        LCALL   ?L_MUL
        MOV     DPTR,#__Constant_7d
        MOV     R0,#?V4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0
        MOV     R1,#?V4
        LCALL   ?UL_DIV_MOD
        MOV     DPTR,#??stDelay
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
??ublInit_12:
        MOV     A,0x95
        MOV     DPTR,#??stStart
        MOVX    @DPTR,A
        XRL     A,0x95
        JNZ     ??ublInit_12
        MOV     A,0x96
        INC     DPTR
        MOVX    @DPTR,A
        MOV     A,0x97
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        ; Setup parameters for call to function vddWait
        LCALL   `??vddWait::?relay`  ; Banked call to: vddWait
        ; Setup parameters for call to function aesLoadKey
        LCALL   `??aesLoadKey::?relay`; Banked call to: aesLoadKey
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x20
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 54)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP102_8
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     R1,#0x1
        LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 52)
        MOV     A,#0x19
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JZ      ??ublInit_13
        MOV     A,#0x18
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CPL     A
        JZ      ??ublInit_13
        ; Setup parameters for call to function ublAesAuth
        LCALL   `??ublAesAuth::?relay`; Banked call to: ublAesAuth
??ublInit_13:
        MOV     R2,#0x0
??ublInit_14:
        MOV     A,R2
        MOV     R0,A
        MOV     A,#ublMD & 0xff
        ADD     A,R0
        MOV     R0,A
        CLR     A
        ADDC    A,#(ublMD >> 8) & 0xff
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x38
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        CPL     A
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R0
        ADD     A,#0x48
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        INC     R2
        MOV     A,R2
        CLR     C
        SUBB    A,#0x10
        JC      ??ublInit_14
        ; Setup parameters for call to function usb_msd_init
        LCALL   `??usb_msd_init::?relay`; Banked call to: usb_msd_init
        ; Setup parameters for call to function ublMassErase
        MOV     R1,#0x1
        LCALL   `??ublMassErase::?relay`; Banked call to: ublMassErase
        MOV     A,#0x24
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI R6 SameValue
          CFI VB SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI R7 SameValue
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI CFA_SP SP+-3
          CFI CFA_XSP16 XSP16+0
          CFI EndBlock cfiBlock26
        REQUIRE ST0
        REQUIRE ST1
        REQUIRE ST2

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine14:
          CFI Block cfiCond27 Using cfiCommon0
          CFI Function ublCfg
          CFI Conditional ??CrossCallReturnLabel_16
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond28 Using cfiCommon0
          CFI (cfiCond28) Function ublInit
          CFI (cfiCond28) Conditional ??CrossCallReturnLabel_17
          CFI (cfiCond28) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond28) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond28) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond28) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond28) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond28) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond28) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond28) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond28) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond28) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond28) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond28) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond28) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond28) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond28) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond28) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond28) CFA_SP SP+-2
          CFI (cfiCond28) CFA_XSP16 add(XSP16, 52)
          CFI Block cfiPicker29 Using cfiCommon1
          CFI (cfiPicker29) NoFunction
          CFI (cfiPicker29) Picker
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,R0
        MOVX    @DPTR,A
        ; Setup parameters for call to function HalFlashWrite
        ; Setup parameters for call to function HalFlashWrite
        MOV     ?V0,#0x1
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        RET
          CFI (cfiCond27) CFA_SP SP+0
          CFI (cfiCond28) CFA_SP SP+0
          CFI (cfiPicker29) CFA_SP SP+0
          CFI EndBlock cfiCond27
          CFI EndBlock cfiCond28
          CFI EndBlock cfiPicker29

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine10:
          CFI Block cfiCond30 Using cfiCommon0
          CFI Function ublExec
          CFI Conditional ??CrossCallReturnLabel_4
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 24)
          CFI Block cfiCond31 Using cfiCommon0
          CFI (cfiCond31) Function ublExec
          CFI (cfiCond31) Conditional ??CrossCallReturnLabel_5
          CFI (cfiCond31) R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI (cfiCond31) VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond31) V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond31) V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond31) V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond31) V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond31) V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond31) V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond31) V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond31) V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond31) V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond31) V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond31) V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond31) V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond31) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond31) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond31) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond31) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond31) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond31) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond31) CFA_SP SP+-2
          CFI (cfiCond31) CFA_XSP16 add(XSP16, 24)
          CFI Block cfiCond32 Using cfiCommon0
          CFI (cfiCond32) Function ublInit
          CFI (cfiCond32) Conditional ??CrossCallReturnLabel_6
          CFI (cfiCond32) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond32) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond32) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond32) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond32) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond32) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond32) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond32) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond32) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond32) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond32) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond32) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond32) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond32) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond32) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond32) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond32) CFA_SP SP+-2
          CFI (cfiCond32) CFA_XSP16 add(XSP16, 52)
          CFI Block cfiPicker33 Using cfiCommon1
          CFI (cfiPicker33) NoFunction
          CFI (cfiPicker33) Picker
        MOV     DPTR,#ublMD
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_67:
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        RET
          CFI (cfiCond30) CFA_SP SP+0
          CFI (cfiCond31) CFA_SP SP+0
          CFI (cfiCond32) CFA_SP SP+0
          CFI (cfiPicker33) CFA_SP SP+0
          CFI EndBlock cfiCond30
          CFI EndBlock cfiCond31
          CFI EndBlock cfiCond32
          CFI EndBlock cfiPicker33

        RSEG BANKED_CODE:CODE:NOROOT(0)
ublJump:
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function ublJump
        CODE
        ; Saved register size: 0
        ; Auto size: 0
        LJMP 0x820
        CLR     0xa8.7
        MOV     0xc9,#-0x55
        MOV     0xc9,#0x5b
??ublJump_0:
        SJMP    ??ublJump_0
          CFI EndBlock cfiBlock34
        REQUIRE _A_IEN0
        REQUIRE WDCTL

        RSEG BANKED_CODE:CODE:NOROOT(0)
ublMassErase:
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function ublMassErase
        CODE
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
        MOV     R0,#0x2
??ublMassErase_0:
        MOV     A,R1
        JNZ     ??ublMassErase_1
        MOV     A,R0
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     R2,A
        MOV     A,#(ublMD + 40) & 0xff
        ADD     A,R2
        MOV     DPL,A
        CLR     A
        ADDC    A,#((ublMD + 40) >> 8) & 0xff
        MOV     DPH,A
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-6
        MOV     A,#0x7
        ANL     A,R0
        MOV     R2,A
        POP     A
          CFI CFA_SP SP+-5
        CJNE    R2,#0x0,??ublMassErase_2
        SJMP    ??ublMassErase_3
??ublMassErase_2:
        CLR     C
        RRC     A
        DJNZ    R2,??ublMassErase_2
??ublMassErase_3:
        MOV     C,0xE0 /* A   */.0
        JNC     ??ublMassErase_4
??ublMassErase_1:
        MOV     A,R0
        CLR     C
        RLC     A
        MOV     DPTR,#0x6272
        MOVX    @DPTR,A
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
??ublMassErase_4:
        INC     R0
        MOV     A,R0
        CLR     C
        SUBB    A,#0x77
        JC      ??ublMassErase_0
        MOV     DPTR,#0x6272
        MOV     A,#0x2
        LJMP    ?Subroutine2 & 0xFFFF
          CFI EndBlock cfiBlock35

        RSEG BANKED_CODE:CODE:NOROOT(0)
??aesLoadKey:
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function ??aesLoadKey
        CODE
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
        MOV     DPL,#??aesKey & 0xff
        MOV     DPH,#(??aesKey >> 8) & 0xff
        MOV     0xb3,#0x45
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        MOV     R0,#0x10
??aesLoadKey_1:
        MOVX    A,@DPTR
        MOV     0xb1,A
        INC     DPTR
        DJNZ    R0,??aesLoadKey_1
        LJMP    ??Subroutine31_0 & 0xFFFF
          CFI EndBlock cfiBlock36
        REQUIRE ENCCS
        REQUIRE ENCDI

        RSEG BANKED_CODE:CODE:NOROOT(0)
??aesInitSig:
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function ??aesInitSig
        CODE
        FUNCALL ??aesInitSig, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 50, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 50, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 36
        MOV     A,#-0x24
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 48)
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x20
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 50)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP102_8
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     R1,#0x1
        LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 48)
        MOV     0xb3,#0x57
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        MOV     A,#0x10
??aesInitSig_1:
        MOV     0xb1,#0x0
        DEC     A
        JNZ     ??aesInitSig_1
        MOV     0xb3,#0x51
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        MOV     0xb1,#0x3a
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine12 & 0xFFFF
??CrossCallReturnLabel_9:
        MOV     0xb1,A
        MOV     A,R1
        MOV     0xb1,A
        MOV     R2,#0x0
??aesInitSig_2:
        MOV     A,R2
        MOV     R0,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     A,DPL
        ADD     A,R0
        MOV     R0,A
        CLR     A
        ADDC    A,DPH
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x16
        LCALL   ?Subroutine27 & 0xFFFF
??CrossCallReturnLabel_40:
        INC     R2
        MOV     A,R2
        CLR     C
        SUBB    A,#0xa
        JC      ??aesInitSig_2
        MOV     A,#0x18
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        CLR     A
        MOV     ?V2,A
        MOV     ?V3,A
        MOV     A,#0xb
        MOV     R0,#?V0
        LCALL   ?L_SHL
        MOV     DPTR,#__Constant_fffffff0
        MOV     R0,#?V0
        LCALL   ?L_ADD_X
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     0xb1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     0xb1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     0xb1,A
??aesInitSig_3:
        MOV     A,0xb3
        MOV     C,0xE0 /* A   */.3
        JNC     ??aesInitSig_3
        MOV     A,#0x24
        LJMP    ?Subroutine3 & 0xFFFF
          CFI EndBlock cfiBlock37
        REQUIRE ENCCS
        REQUIRE ENCDI

        RSEG BANKED_CODE:CODE:NOROOT(0)
??gpioInit:
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function ??gpioInit
        CODE
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     DPTR,#ublMD + 89
        MOVX    A,@DPTR
        MOV     R0,A
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     R2,A
        MOV     A,#0x7
        ANL     A,R0
        MOV     R1,A
        MOV     A,R2
        JNZ     ??gpioInit_1
        MOV     R4,#-0xd
        SJMP    ??gpioInit_2
??gpioInit_1:
        MOV     A,#0x1
        XRL     A,R2
        JNZ     ??gpioInit_3
        MOV     R4,#-0xc
        SJMP    ??gpioInit_2
??gpioInit_3:
        MOV     R4,#-0xb
??gpioInit_2:
        MOV     R5,#0x70
        MOV     A,R1
        MOV     R0,A
        MOV     A,#0x1
        CJNE    R0,#0x0,??gpioInit_4
        SJMP    ??gpioInit_5
??gpioInit_4:
        CLR     C
        RLC     A
        DJNZ    R0,??gpioInit_4
??gpioInit_5:
        MOV     R0,A
        CPL     A
        MOV     R3,A
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        ANL     A,R3
        MOVX    @DPTR,A
        MOV     A,R2
        JNZ     ??gpioInit_6
        MOV     R4,#-0x3
        SJMP    ??gpioInit_7
??gpioInit_6:
        MOV     A,#0x1
        XRL     A,R2
        JNZ     ??gpioInit_8
        MOV     R4,#-0x2
        SJMP    ??gpioInit_7
??gpioInit_8:
        MOV     R4,#-0x1
??gpioInit_7:
        MOV     DPL,R4
        MOVX    A,@DPTR
        ANL     A,R3
        MOVX    @DPTR,A
        MOV     A,R2
        JNZ     ??gpioInit_9
        MOV     R4,#-0x71
        SJMP    ??gpioInit_10
??gpioInit_9:
        MOV     A,#0x1
        XRL     A,R2
        JNZ     ??gpioInit_11
        MOV     R4,#-0xa
        SJMP    ??gpioInit_10
??gpioInit_11:
        MOV     R4,#-0x9
??gpioInit_10:
        MOV     DPTR,#ublMD + 88
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.2
        JNC     ??gpioInit_12
        MOV     ?V0,#0x1
        MOV     ?V1,#0x0
        MOV     A,#0x5
        ADD     A,R2
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     A,?V0
        MOV     R0,A
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        MOV     A,R0
        JNC     ??gpioInit_13
        CPL     A
        ANL     0xf7,A
        SJMP    ??gpioInit_14
??gpioInit_13:
        ORL     0xf7,A
??gpioInit_14:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        ANL     A,R3
        SJMP    ??gpioInit_15
??gpioInit_12:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        ORL     A,R0
??gpioInit_15:
        MOVX    @DPTR,A
        MOV     A,R1
        MOV     DPTR,#??forcePin
        MOVX    @DPTR,A
        MOV     A,R2
        JNZ     ??gpioInit_16
        MOV     DPTR,#??pForcePort
        MOV     A,#-0x80
        SJMP    ??gpioInit_17
??gpioInit_16:
        MOV     A,#0x1
        XRL     A,R2
        MOV     DPTR,#??pForcePort
        JNZ     ??gpioInit_18
        MOV     A,#-0x70
        SJMP    ??gpioInit_17
??gpioInit_18:
        MOV     A,#-0x60
??gpioInit_17:
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x70
        MOVX    @DPTR,A
        MOV     DPTR,#??pForcePort
        LCALL   ?Subroutine24 & 0xFFFF
??CrossCallReturnLabel_32:
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#??forcePin
        MOVX    A,@DPTR
        MOV     R0,A
        POP     A
          CFI CFA_SP SP+0
        CJNE    R0,#0x0,??gpioInit_19
        SJMP    ??gpioInit_20
??gpioInit_19:
        CLR     C
        RRC     A
        DJNZ    R0,??gpioInit_19
??gpioInit_20:
        MOV     C,0xE0 /* A   */.0
        MOV     B.0,C
        MOV     DPTR,#ublMD + 88
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.1
        JB      B.0,??gpioInit_21
        CPL     C
??gpioInit_21:
        JNC     ??gpioInit_22
        MOV     DPTR,#ublMD + 2
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
        MOV     R1,#0x1
        SJMP    ??gpioInit_23
??gpioInit_22:
        MOV     R1,#0x0
??gpioInit_23:
        LJMP    ??Subroutine29_0 & 0xFFFF
          CFI EndBlock cfiBlock38
        REQUIRE P2INP

        RSEG BANKED_CODE:CODE:NOROOT(0)
??vddWait:
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function ??vddWait
        CODE
        ; Saved register size: 0
        ; Auto size: 0
        MOV     R0,#0x10
??vddWait_1:
        MOV     0xb6,#0xf
??vddWait_2:
        MOV     A,0xb4
        MOV     C,0xE0 /* A   */.7
        JNC     ??vddWait_2
        MOV     A,0xbb
        CLR     C
        SUBB    A,#0x4e
        JC      ??vddWait_1
        DEC     R0
        MOV     A,R0
        JNZ     ??vddWait_1
        LJMP    ?BRET
          CFI EndBlock cfiBlock39
        REQUIRE ADCCON3
        REQUIRE ADCCON1
        REQUIRE ADCH
//   68 
//   69 /* ------------------------------------------------------------------------------------------------
//   70  *                                       Local Functions
//   71  * ------------------------------------------------------------------------------------------------
//   72  */
//   73 
//   74 static void vddWait(void);
//   75 
//   76 // If the code model is banked, low_level_init must be declared
//   77 // __near_func elsa a ?BRET is performed
//   78 //
//   79 #if (__CODE_MODEL__ == 2)
//   80 __near_func __root char
//   81 #else
//   82 __root char
//   83 #endif
//   84 __low_level_init(void);
//   85 
//   86 /**************************************************************************************************
//   87  * @fn          __low_level_init
//   88  *
//   89  * @brief       Abort boot loader as soon as possible after a Watchdog reset with a valid RC image.
//   90  *              This function is called by the IAR start-up code before doing normal initialization
//   91  *              of the data segments.
//   92  *
//   93  * input parameters
//   94  *
//   95  * None.
//   96  *
//   97  * output parameters
//   98  *
//   99  * None.
//  100  *
//  101  * @return      0 - don't intialize data segments / 1 - do initialization.
//  102  */
//  103 #if (__CODE_MODEL__ == 2)
//  104 __near_func __root char
//  105 #else
//  106 __root char
//  107 #endif
//  108 __low_level_init(void)
//  109 {
//  110   // Map flash bank #7 into XDATA for access to "ROM mapped as data".
//  111   MEMCTR = (MEMCTR & 0xF8) | 0x07;
//  112 
//  113   if (ResetWasWatchDog)
//  114   {
//  115     // Read from Flash the minimum subset of ublMetaData_t necessary for UBL_RC_VALID().
//  116     HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD.crcRC, 4);
//  117 
//  118     if (UBL_RC_VALID)
//  119     {
//  120   //  HalFlashRead(1, 0, pgBuf, 2048);
//  121       ublJump();
//  122     }
//  123   }
//  124 
//  125   vddWait();
//  126   HAL_BOARD_INIT();
//  127 
//  128   // Choose if segment initialization should be done or not: 0 to omit seg_init; 1 to run seg_init.
//  129   return 1;
//  130 }
//  131 
//  132 /**************************************************************************************************
//  133  * @fn          main
//  134  *
//  135  * @brief       ISR for the reset vector, invoked by IAR after all segment initialization.
//  136  *
//  137  * input parameters
//  138  *
//  139  * None.
//  140  *
//  141  * output parameters
//  142  *
//  143  * None.
//  144  *
//  145  * @return      None.
//  146  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  147 void main(void)
main:
          CFI Block cfiBlock40 Using cfiCommon3
          CFI Function main
        CODE
//  148 {
        FUNCALL main, ublInit
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ublExec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        ; Auto size: 0
//  149   /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
//  150    * descriptors in addition to just Channel 0.
//  151    */
//  152   
//  153   HAL_DMA_SET_ADDR_DESC0(&dmaCh0);
        MOV     A,#(dmaCh0 >> 8) & 0xff
        MOV     0xd5,A
        MOV     0xd4,#dmaCh0 & 0xff
//  154   
//  155   P1SEL = P1SEL & 0xFC;
        ANL     0xf4,#0xfc
//  156   P1DIR = P1DIR & 0xFC;
        ANL     0xfe,#0xfc
//  157   P1DIR = P1DIR |  0x1;      
        ORL     0xfe,#0x1
//  158   P1_0 = 1;
        SETB    0x90.0
//  159 
//  160   P0DIR |=  (1<<6);  
        ORL     0xfd,#0x40
//  161   P0SEL &= ~(1<<6);
        ANL     0xf3,#0xbf
//  162   P0_6 = 0;
        CLR     0x80.6
//  163   
//  164   ublInit();
        ; Setup parameters for call to function ublInit
        LCALL   `??ublInit::?relay`  ; Banked call to: ublInit
//  165   ublExec();
        ; Setup parameters for call to function ublExec
        LCALL   `??ublExec::?relay`  ; Banked call to: ublExec
//  166 
//  167   HAL_SYSTEM_RESET();
        CLR     0xa8.7
        MOV     0xc9,#-0x55
        MOV     0xc9,#0x5b
??main_0:
        SJMP    ??main_0
          CFI EndBlock cfiBlock40
        REQUIRE DMA0CFGH
        REQUIRE DMA0CFGL
        REQUIRE P1SEL
        REQUIRE P1DIR
        REQUIRE _A_P1
        REQUIRE P0DIR
        REQUIRE P0SEL
        REQUIRE _A_P0
        REQUIRE _A_IEN0
        REQUIRE WDCTL
//  168 }
//  169 
//  170 /**************************************************************************************************
//  171  * @fn          vddWait
//  172  *
//  173  * @brief       Loop waiting for 16 reads of the Vdd over the safe minimum to run.
//  174  *
//  175  * input parameters
//  176  *
//  177  * None.
//  178  *
//  179  * output parameters
//  180  *
//  181  * None.
//  182  *
//  183  * @return      None.
//  184  */
//  185 static void vddWait(void)
//  186 {
//  187   uint8 cnt = 16;
//  188 
//  189   do {
//  190     do {
//  191       ADCCON3 = 0x0F;
//  192       while (!(ADCCON1 & 0x80));
//  193     } while (ADCH < VDD_MIN_RUN);
//  194   } while (--cnt);
//  195 }
//  196 
//  197 /**************************************************************************************************
//  198 */
// C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_descriptor_parser.c
//    1 /******************************************************************************
//    2 
//    3  @file  usb_descriptor_parser.c
//    4 
//    5  @brief Parser for USB descriptor structures.
//    6 
//    7  Group: WCS, BTS
//    8  Target Device: CC2540, CC2541
//    9 
//   10  ******************************************************************************
//   11  
//   12  Copyright (c) 2004-2016, Texas Instruments Incorporated
//   13  All rights reserved.
//   14 
//   15  IMPORTANT: Your use of this Software is limited to those specific rights
//   16  granted under the terms of a software license agreement between the user
//   17  who downloaded the software, his/her employer (which must be your employer)
//   18  and Texas Instruments Incorporated (the "License"). You may not use this
//   19  Software unless you agree to abide by the terms of the License. The License
//   20  limits your use, and you acknowledge, that the Software may not be modified,
//   21  copied or distributed unless embedded on a Texas Instruments microcontroller
//   22  or used solely and exclusively in conjunction with a Texas Instruments radio
//   23  frequency transceiver, which is integrated into your product. Other than for
//   24  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   25  works of, modify, distribute, perform, display or sell this Software and/or
//   26  its documentation for any purpose.
//   27 
//   28  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   29  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   30  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   31  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   32  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   33  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   34  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   35  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   36  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   37  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   38  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   39 
//   40  Should you have any questions regarding your right to use this Software,
//   41  contact Texas Instruments Incorporated at www.TI.com.
//   42 
//   43  ******************************************************************************
//   44  Release Name: ble_sdk_1.4.2.2
//   45  Release Date: 2016-06-09 06:57:10
//   46  *****************************************************************************/
//   47 
//   48 /// \addtogroup module_usb_descriptor_parser
//   49 /// @{
//   50 #define USBDESCRIPTORPARSER_C ///< Modifies the behavior of "EXTERN" in usb_descriptor_parser.h
//   51 #include "usb_firmware_library_headers.h"
//   52 #include "hal_flash.h"
//   53 
//   54 //-------------------------------------------------------------------------------------------------------
//   55 // USBDP internal module data
//   56 static USBDP_DATA __xdata usbdpData; ///< USBDP internal module data
//   57 
//   58 //-------------------------------------------------------------------------------------------------------
//   59 // String descriptors (2-byte unicode data).
//   60 
//   61 // Language ID.
//   62 static const uint8 languageId[4] = {
//   63   4,
//   64   DESC_TYPE_STRING,
//   65   0x09, 0x04  /* US-EN */
//   66 };
//   67 
//   68 // Manufacturer.
//   69 static const uint8 manufacturer[36] = {
//   70   36,
//   71   DESC_TYPE_STRING,
//   72   'T', 0,
//   73   'e', 0,
//   74   'x', 0,
//   75   'a', 0,
//   76   's', 0,
//   77   ' ', 0,
//   78   'I', 0,
//   79   'n', 0,
//   80   's', 0,
//   81   't', 0,
//   82   'r', 0,
//   83   'u', 0,
//   84   'm', 0,
//   85   'e', 0,
//   86   'n', 0,
//   87   't', 0,
//   88   's', 0
//   89 };
//   90 
//   91 // Product.
//   92 #if defined HAL_SB_BOOT_CODE
//   93 static const uint8 product[36] = {
//   94   36,
//   95   DESC_TYPE_STRING,
//   96   'T', 0,
//   97   'I', 0,
//   98   ' ', 0,
//   99   'C', 0,
//  100   'C', 0,
//  101   '2', 0,
//  102   '5', 0,
//  103   '3', 0,
//  104   '1', 0,
//  105   ' ', 0,
//  106   'U', 0,
//  107   'S', 0,
//  108   'B', 0,
//  109   ' ', 0,
//  110   'M', 0,
//  111   'S', 0,
//  112   'D', 0
//  113 };
//  114 #else
//  115 static const uint8 product[36] = {
//  116   36,
//  117   DESC_TYPE_STRING,
//  118   'T', 0,
//  119   'I', 0,
//  120   ' ', 0,
//  121   'C', 0,
//  122   'C', 0,
//  123   '2', 0,
//  124   '5', 0,
//  125   '3', 0,
//  126   '1', 0,
//  127   ' ', 0,
//  128   'U', 0,
//  129   'S', 0,
//  130   'B', 0,
//  131   ' ', 0,
//  132   'C', 0,
//  133   'D', 0,
//  134   'C', 0
//  135 };
//  136 #endif
//  137 
//  138 // Serial Number.
//  139 static uint8 serialNumber[42] = {
//  140   0,  // Initializing to zero vice 42 is the indication to usbdpGetStringDesc() to fill w/ IEEE.
//  141   DESC_TYPE_STRING,
//  142   // Setup for using the 16 nibbles of the hex representation of the IEEE address.
//  143   '_', 0,
//  144   '_', 0,
//  145   '0', 0,
//  146   'X', 0,
//  147 };
//  148 
//  149 const uint8 hexDigit[16] = {
//  150   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
//  151 
//  152 /** \brief	Initializes a search
//  153 *
//  154 * This function must be called before each new search to reset \ref USBDP_DATA.pDesc.
//  155 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  156 void usbdpInit(void)
usbdpInit:
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function usbdpInit
        CODE
//  157 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  158    usbdpData.pDesc = (const uint8 __code *) usbDescriptorMarker.pUsbDescStart;
        MOV     DPTR,#usbDescriptorMarker
        LCALL   ??Subroutine34_0 & 0xFFFF
??CrossCallReturnLabel_41:
        MOV     DPTR,#??usbdpData
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        LJMP    ??Subroutine30_0 & 0xFFFF
//  159 } // usbdpInit
          CFI EndBlock cfiBlock41
//  160 
//  161 
//  162 
//  163 
//  164 /** \brief	Locates the descriptor of the wanted type
//  165 *
//  166 * This function parses through the USB descriptors until:
//  167 * \li It hits one with <tt>bDescriptorType = wantedType</tt>, in which case it returns a pointer to
//  168 *     that descriptor, and exits. \ref USBDP_DATA.pDesc will then point to the next descriptor.
//  169 * \li It hits one with <tt>bDescriptorType = haltAtType</tt>, in which case it returns a NULL-pointer,
//  170 *     and exits. \ref USBDP_DATA.pDesc will then point to that descriptor.
//  171 * \li \ref USBDP_DATA.pDesc = \ref usbDescEnd, in which case it returns a NULL-pointer, and exits.
//  172 *     \ref USBDP_DATA.pDesc will continue to point to \ref usbDescEnd.
//  173 *
//  174 * \note To begin a search with this function, \ref usbdpInit should be called first. It should not be
//  175 *       called when continuing a search - for instance after a call to \ref usbdpGetConfigurationDesc().
//  176 *
//  177 * \param[in]       wantedType
//  178 *     The wanted descriptor type (e.g. \ref DESC_TYPE_CONFIG)
//  179 * \param[in]       haltAtType
//  180 *     The parser halts when it reaches this descriptor type, unless \c haltAtType is \c 0 (which in any
//  181 *     case is an invalid \c bDescriptorType value).
//  182 *
//  183 * \return
//  184 *     A pointer to the wanted descriptor type, or \c NULL if it was not found.
//  185 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  186 void __code* usbdpFindNext(uint8 wantedType, uint8 haltAtType)
usbdpFindNext:
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function usbdpFindNext
        CODE
//  187 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
        MOV     A,R1
        MOV     R4,A
        MOV     A,R2
        MOV     R5,A
//  188    void __code *pResult;
//  189    pResult = NULL;
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??CrossCallReturnLabel_2
//  190 
//  191    // As long as we haven't reached the end...
//  192    while (usbdpData.pDesc != (void __code *) usbDescriptorMarker.pUsbDescEnd) {
//  193 
//  194       // If we have a match on wantedType...
//  195       if (usbdpData.pDesc[DESC_TYPE_IDX] == wantedType) {
//  196          pResult = (void __code*) usbdpData.pDesc;
//  197          usbdpData.pDesc += usbdpData.pDesc[DESC_LENGTH_IDX];
//  198          break;
//  199 
//  200       // If we have a match on haltAtType...
//  201       } else if (usbdpData.pDesc[DESC_TYPE_IDX] == haltAtType) {
//  202          if (haltAtType) break;
//  203       }
//  204 
//  205       // Move on to the next descriptor
//  206       usbdpData.pDesc += usbdpData.pDesc[DESC_LENGTH_IDX];
??usbdpFindNext_0:
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_2:
        MOV     DPTR,#??usbdpData
        LCALL   ??Subroutine34_0 & 0xFFFF
??CrossCallReturnLabel_42:
        MOV     DPTR,#usbDescriptorMarker + 2
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??usbdpFindNext_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??usbdpFindNext_1:
        JZ      ??usbdpFindNext_2
        MOV     DPTR,#??usbdpData + 1
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,R4
        XRL     A,R0
        JNZ     ??usbdpFindNext_3
        MOV     DPTR,#??usbdpData
        LCALL   ??Subroutine36_0 & 0xFFFF
??CrossCallReturnLabel_46:
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_3:
        SJMP    ??usbdpFindNext_2
??usbdpFindNext_3:
        MOV     A,R5
        XRL     A,R0
        JNZ     ??usbdpFindNext_0
        MOV     A,R5
        JZ      ??usbdpFindNext_0
//  207    }
//  208 
//  209    return pResult;
??usbdpFindNext_2:
        SJMP    ??Subroutine31_0
//  210 } // usbdpFindNext
          CFI EndBlock cfiBlock42

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine8:
          CFI Block cfiCond43 Using cfiCommon0
          CFI Function usbdpFindNext
          CFI Conditional ??CrossCallReturnLabel_2
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond44 Using cfiCommon0
          CFI (cfiCond44) Function usbdpFindNext
          CFI (cfiCond44) Conditional ??CrossCallReturnLabel_3
          CFI (cfiCond44) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond44) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond44) CFA_SP SP+-7
          CFI Block cfiPicker45 Using cfiCommon1
          CFI (cfiPicker45) NoFunction
          CFI (cfiPicker45) Picker
        MOV     DPTR,#??usbdpData
        LCALL   ?Subroutine24 & 0xFFFF
??CrossCallReturnLabel_33:
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     DPTR,#??usbdpData
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#??usbdpData
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        RET
          CFI (cfiCond43) CFA_SP SP+-5
          CFI (cfiCond44) CFA_SP SP+-5
          CFI (cfiPicker45) CFA_SP SP+0
          CFI EndBlock cfiCond43
          CFI EndBlock cfiCond44
          CFI EndBlock cfiPicker45

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine24:
          CFI Block cfiCond46 Using cfiCommon0
          CFI Function ??gpioInit
          CFI Conditional ??CrossCallReturnLabel_32
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond47 Using cfiCommon0
          CFI (cfiCond47) Function usbdpFindNext
          CFI (cfiCond47) Conditional ??CrossCallReturnLabel_33, ??CrossCallReturnLabel_2
          CFI (cfiCond47) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond47) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond47) CFA_SP SP+-9
          CFI Block cfiCond48 Using cfiCommon0
          CFI (cfiCond48) Function usbdpFindNext
          CFI (cfiCond48) Conditional ??CrossCallReturnLabel_33, ??CrossCallReturnLabel_3
          CFI (cfiCond48) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond48) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond48) CFA_SP SP+-9
          CFI Block cfiPicker49 Using cfiCommon1
          CFI (cfiPicker49) NoFunction
          CFI (cfiPicker49) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        RET
          CFI (cfiCond46) CFA_SP SP+0
          CFI (cfiCond47) CFA_SP SP+-7
          CFI (cfiCond48) CFA_SP SP+-7
          CFI (cfiPicker49) CFA_SP SP+0
          CFI EndBlock cfiCond46
          CFI EndBlock cfiCond47
          CFI EndBlock cfiCond48
          CFI EndBlock cfiPicker49
//  211 
//  212 
//  213 
//  214 
//  215 /** \brief	Locates the (one and only) device descriptor
//  216 *
//  217 * \note It is not necessary to call \ref usbdpInit() before this function.
//  218 *
//  219 * \return
//  220 *     A pointer to the \ref USB_DEVICE_DESCRIPTOR, or \c NULL if it was not found.
//  221 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  222 USB_DEVICE_DESCRIPTOR __code* usbdpGetDeviceDesc(void)
usbdpGetDeviceDesc:
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function usbdpGetDeviceDesc
        CODE
//  223 {
        FUNCALL usbdpGetDeviceDesc, usbdpFindNext
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  224    usbdpInit();
        LCALL   ?Subroutine11 & 0xFFFF
//  225    return usbdpFindNext(DESC_TYPE_DEVICE, 0);
??CrossCallReturnLabel_7:
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x1
        LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
        SJMP    ??Subroutine31_0
//  226 } // usbdpGetDeviceDesc
          CFI EndBlock cfiBlock50

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
          CFI Block cfiBlock51 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        MOVX    @DPTR,A
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
          CFI EndBlock cfiBlock51
        REQUIRE ??Subroutine30_0
        ; // Fall through to label ??Subroutine30_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine30_0:
          CFI Block cfiBlock52 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        MOVX    @DPTR,A
          CFI EndBlock cfiBlock52
        REQUIRE ??Subroutine31_0
        ; // Fall through to label ??Subroutine31_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine31_0:
          CFI Block cfiBlock53 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        POP     DPH
          CFI CFA_SP SP+-4
          CFI DPH0 SameValue
        POP     DPL
          CFI CFA_SP SP+-3
          CFI DPL0 SameValue
        LJMP    ?BRET
          CFI EndBlock cfiBlock53
//  227 
//  228 
//  229 
//  230 
//  231 /** \brief	Locates a configuration descriptor
//  232 *
//  233 * The search will either look for a descriptor with a specific
//  234 * \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue, or simply take the n'th descriptor (by "index")
//  235 *
//  236 * \note It is not necessary to call \ref usbdpInit() before this function.
//  237 *
//  238 * \param[in]       cfgValue
//  239 *     The configuration value to search for (\ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue), or
//  240 *     0 to find descriptor by index
//  241 * \param[in]       cfgIndex
//  242 *     A zero-based index for the configuration descriptor to find.
//  243 *     This value is ignored unless \c cfgValue is 0.
//  244 *
//  245 * \return
//  246 *     A pointer to the \ref USB_DEVICE_DESCRIPTOR, or \c NULL if it was not found.
//  247 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  248 USB_CONFIGURATION_DESCRIPTOR __code* usbdpGetConfigurationDesc(uint8 cfgValue, uint8 cfgIndex)
usbdpGetConfigurationDesc:
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function usbdpGetConfigurationDesc
        CODE
//  249 {
        FUNCALL usbdpGetConfigurationDesc, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R1
        MOV     R7,A
        MOV     A,R2
        MOV     R6,A
//  250    USB_CONFIGURATION_DESCRIPTOR __code *pConfigurationDesc;
//  251    usbdpInit();
        LCALL   ?Subroutine11 & 0xFFFF
//  252 
//  253    // As long as there are more configuration descriptors...
//  254    while (pConfigurationDesc = usbdpFindNext(DESC_TYPE_CONFIG, 0)) {
??CrossCallReturnLabel_8:
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x2
        LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
        MOV     A,R2
        ORL     A,R3
        JZ      ??usbdpGetConfigurationDesc_0
//  255 
//  256       // Search by value?
//  257       if (cfgValue) {
        MOV     A,R7
        JZ      ??usbdpGetConfigurationDesc_1
//  258          if (cfgValue == pConfigurationDesc->bConfigurationValue) break;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        XRL     A,R7
        JNZ     ??CrossCallReturnLabel_8
        SJMP    ??usbdpGetConfigurationDesc_0
//  259 
//  260       // Search by index? (search cfgIndex+1 times)
//  261       } else if (!cfgIndex--) {
??usbdpGetConfigurationDesc_1:
        MOV     A,R6
        MOV     R0,A
        MOV     A,#-0x1
        ADD     A,R0
        MOV     R6,A
        INC     A
        JNZ     ??CrossCallReturnLabel_8
//  262          break;
//  263       }
//  264    }
//  265 
//  266    return pConfigurationDesc;
??usbdpGetConfigurationDesc_0:
        LJMP    ??Subroutine29_0 & 0xFFFF
//  267 } // usbdpGetConfigurationDesc
          CFI EndBlock cfiBlock54

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine11:
          CFI Block cfiCond55 Using cfiCommon0
          CFI Function usbdpGetDeviceDesc
          CFI Conditional ??CrossCallReturnLabel_7
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond56 Using cfiCommon0
          CFI (cfiCond56) Function usbdpGetConfigurationDesc
          CFI (cfiCond56) Conditional ??CrossCallReturnLabel_8
          CFI (cfiCond56) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond56) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond56) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond56) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond56) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond56) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond56) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond56) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond56) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond56) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond56) CFA_SP SP+-2
          CFI (cfiCond56) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiPicker57 Using cfiCommon1
          CFI (cfiPicker57) NoFunction
          CFI (cfiPicker57) Picker
        MOV     DPTR,#usbDescriptorMarker
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_68:
        MOV     DPTR,#??usbdpData
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        RET
          CFI (cfiCond55) CFA_SP SP+-5
          CFI (cfiCond56) CFA_SP SP+0
          CFI (cfiPicker57) CFA_SP SP+0
          CFI EndBlock cfiCond55
          CFI EndBlock cfiCond56
          CFI EndBlock cfiPicker57
//  268 
//  269 
//  270 
//  271 
//  272 /** \brief	Locates an interface descriptor
//  273 *
//  274 * The function will first go to the configuration descriptor that matches the supplied configuration
//  275 * value, and then locate the interface descriptor that matches the given interface number and alternate
//  276 * setting.
//  277 *
//  278 * \note It is not necessary to call \ref usbdpInit() before this function.
//  279 *
//  280 * \param[in]       cfgValue
//  281 *     The configuration value (\ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue)
//  282 * \param[in]       intNumber
//  283 *     The interface number (\ref USB_INTERFACE_DESCRIPTOR.bInterfaceNumber)
//  284 * \param[in]       altSetting
//  285 *     The alternate setting (\ref USB_INTERFACE_DESCRIPTOR.bAlternateSetting)
//  286 *
//  287 * \return
//  288 *     A pointer to the \ref USB_INTERFACE_DESCRIPTOR, or \c NULL if it was not found.
//  289 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  290 USB_INTERFACE_DESCRIPTOR __code* usbdpGetInterfaceDesc(uint8 cfgValue, uint8 intNumber, uint8 altSetting)
usbdpGetInterfaceDesc:
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function usbdpGetInterfaceDesc
        CODE
//  291 {
        FUNCALL usbdpGetInterfaceDesc, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbdpGetInterfaceDesc, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R2
        MOV     R7,A
        MOV     ?V0,R3
//  292    USB_INTERFACE_DESCRIPTOR __code *pInterfaceDesc;
//  293 
//  294    // First get to the correct configuration
//  295    usbdpGetConfigurationDesc(cfgValue, 0);
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     R2,#0x0
        LCALL   `??usbdpGetConfigurationDesc::?relay`; Banked call to: usbdpGetConfigurationDesc
//  296 
//  297    // Then find a match on the interface
//  298    while (pInterfaceDesc = usbdpFindNext(DESC_TYPE_INTERFACE, DESC_TYPE_CONFIG)) {
??usbdpGetInterfaceDesc_0:
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x2
        MOV     R1,#0x4
        LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
        MOV     A,R2
        ORL     A,R3
        JZ      ??usbdpGetInterfaceDesc_1
//  299       if ((pInterfaceDesc->bInterfaceNumber == intNumber) && (pInterfaceDesc->bAlternateSetting == altSetting)) {
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        XRL     A,R7
        JNZ     ??usbdpGetInterfaceDesc_0
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        XRL     A,?V0
        JNZ     ??usbdpGetInterfaceDesc_0
//  300          break;
//  301       }
//  302    }
//  303 
//  304    return pInterfaceDesc;
??usbdpGetInterfaceDesc_1:
        SJMP    ??Subroutine32_0
//  305 } // usbdpGetInterfaceDesc
          CFI EndBlock cfiBlock58

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
          CFI Block cfiBlock59 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 45)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI Invalid
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
          CFI Valid
          CFI EndBlock cfiBlock59
        REQUIRE ??Subroutine32_0
        ; // Fall through to label ??Subroutine32_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine32_0:
          CFI Block cfiBlock60 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
          CFI CFA_SP SP+-3
          CFI CFA_XSP16 XSP16+0
          CFI VB SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndBlock cfiBlock60
//  306 
//  307 
//  308 
//  309 
//  310 /** \brief	Locates a string descriptor
//  311 *
//  312 * \note It is not necessary to call \ref usbdpInit() before this function.
//  313 *
//  314 * \param[in]       strIndex
//  315 *     A zero-based index that matches the "iXxxxxxxxxx" string indexes in the other descriptors
//  316 *
//  317 * \return
//  318 *     A pointer to the \ref USB_INTERFACE_DESCRIPTOR, or \c NULL if it was not found.
//  319 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  320 USB_STRING_DESCRIPTOR* usbdpGetStringDesc(uint8 strIndex)
usbdpGetStringDesc:
          CFI Block cfiBlock61 Using cfiCommon0
          CFI Function usbdpGetStringDesc
        CODE
//  321 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 17)
        MOV     A,R1
//  322   USB_STRING_DESCRIPTOR *pStringDesc = NULL;
        MOV     R2,#0x0
        MOV     R3,#0x0
//  323 
//  324 #ifdef MS_EXT_C_ID
//  325   /* TODO: Find the Microsoft OS String Descriptor?
//  326   usbdpInit();
//  327 
//  328   if (strIndex == 0xEE){
//  329     // Find the Microsoft OS String Descriptor
//  330     do{
//  331       pStringDesc = usbdpFindNext(DESC_TYPE_STRING, 0);
//  332     }while (pStringDesc != NULL && pStringDesc->bLength != 18);
//  333   } else
//  334   */
//  335 #endif
//  336   {
//  337     switch (strIndex)
        JZ      ??usbdpGetStringDesc_0
        DEC     A
        JZ      ??usbdpGetStringDesc_1
        DEC     A
        JZ      ??usbdpGetStringDesc_2
        DEC     A
        JZ      ??usbdpGetStringDesc_3
        SJMP    ??usbdpGetStringDesc_4
//  338     {
//  339     case 0:
//  340       pStringDesc = (USB_STRING_DESCRIPTOR *)languageId;
??usbdpGetStringDesc_0:
        MOV     R2,#??languageId & 0xff
        MOV     R3,#(??languageId >> 8) & 0xff
//  341       break;
        SJMP    ??usbdpGetStringDesc_4
//  342 
//  343     case 1:
//  344       pStringDesc = (USB_STRING_DESCRIPTOR *)manufacturer;
??usbdpGetStringDesc_1:
        MOV     R2,#??manufacturer & 0xff
        MOV     R3,#(??manufacturer >> 8) & 0xff
//  345       break;
        SJMP    ??usbdpGetStringDesc_4
//  346 
//  347     case 2:
//  348       pStringDesc = (USB_STRING_DESCRIPTOR *)product;
??usbdpGetStringDesc_2:
        MOV     R2,#??product & 0xff
        MOV     R3,#(??product >> 8) & 0xff
//  349       break;
        SJMP    ??usbdpGetStringDesc_4
//  350 
//  351     case 3:
//  352       if (serialNumber[0] == 0)
??usbdpGetStringDesc_3:
        MOV     DPTR,#??serialNumber
        MOVX    A,@DPTR
        JNZ     ??usbdpGetStringDesc_5
//  353       {
//  354 #if (defined HAL_SB_BOOT_CODE || defined CC253X_MACNP || defined CC2531DK)
//  355         #include <string.h>
//  356         uint8 aExtendedAddress[HAL_FLASH_IEEE_SIZE] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
        MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,_1`
        MOV     R4,?XSP + 0
        MOV     R5,?XSP + 1
        MOV     A,#0x8
        LCALL   ?MOVE_LONG8_XDATA_XDATA
//  357         /*
//  358         uint8 nullAddr[HAL_FLASH_IEEE_SIZE] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
//  359         uint8 aExtendedAddress[HAL_FLASH_IEEE_SIZE];
//  360 
//  361         // Attempt to read the extended address from the location on the lock bits page
//  362         // where the programming tools know to reserve it.
//  363         HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_IEEE_OSET,
//  364                         aExtendedAddress, HAL_FLASH_IEEE_SIZE);
//  365 
//  366         if (!memcmp(aExtendedAddress, nullAddr, HAL_FLASH_IEEE_SIZE))
//  367         {
//  368           // Attempt to read the extended address from the designated location in the Info Page.
//  369           memcpy(aExtendedAddress, (uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), HAL_FLASH_IEEE_SIZE);
//  370         }
//  371          */
//  372 #endif
//  373         // Load the 16 nibbles of the hex representation of the IEEE address into the serialNumber
//  374         // string in big-endian (i.e. human-readable) order.
//  375         for (uint8 idx = sizeof(serialNumber)-2, cnt=0; cnt < HAL_FLASH_IEEE_SIZE; cnt++, idx -= 4)
        MOV     R4,#0x28
        MOV     R5,#0x0
//  376         {
//  377           serialNumber[idx]   = hexDigit[aExtendedAddress[cnt] & 0x0F];
??usbdpGetStringDesc_6:
        MOV     A,R5
        MOV     R0,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        LCALL   ?Subroutine21 & 0xFFFF
??CrossCallReturnLabel_29:
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R4
        MOV     R0,A
        MOV     A,#??serialNumber & 0xff
        ADD     A,R0
        MOV     R0,A
        CLR     A
        ADDC    A,#(??serialNumber >> 8) & 0xff
        MOV     R1,A
        MOV     A,R7
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_0:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    @DPTR,A
//  378           serialNumber[idx-2] = hexDigit[aExtendedAddress[cnt] / 16];
        MOV     A,R7
        SWAP    A
        LCALL   ?Subroutine6 & 0xFFFF
//  379         }
??CrossCallReturnLabel_1:
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R0
        ADD     A,#-0x2
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     DPH,A
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        INC     R5
        MOV     A,#-0x4
        ADD     A,R4
        MOV     R4,A
        MOV     A,R5
        CLR     C
        SUBB    A,#0x8
        JC      ??usbdpGetStringDesc_6
//  380         serialNumber[0] = sizeof(serialNumber);
        MOV     DPTR,#??serialNumber
        MOV     A,#0x2a
        MOVX    @DPTR,A
//  381       }
//  382       pStringDesc = (USB_STRING_DESCRIPTOR *)serialNumber;
??usbdpGetStringDesc_5:
        MOV     R2,#??serialNumber & 0xff
        MOV     R3,#(??serialNumber >> 8) & 0xff
//  383       break;
//  384 
//  385     default:
//  386       break;
//  387     }
//  388   }
//  389 
//  390   return pStringDesc;
??usbdpGetStringDesc_4:
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 9)
        LJMP    ?Subroutine4 & 0xFFFF
//  391 }
          CFI EndBlock cfiBlock61

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine21:
          CFI Block cfiCond62 Using cfiCommon0
          CFI Function ublAesAuth
          CFI Conditional ??CrossCallReturnLabel_28
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_XSP16 add(XSP16, 59)
          CFI Block cfiCond63 Using cfiCommon0
          CFI (cfiCond63) Function usbdpGetStringDesc
          CFI (cfiCond63) Conditional ??CrossCallReturnLabel_29
          CFI (cfiCond63) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond63) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond63) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond63) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond63) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond63) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond63) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond63) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond63) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond63) CFA_SP SP+-2
          CFI (cfiCond63) CFA_XSP16 add(XSP16, 17)
          CFI Block cfiPicker64 Using cfiCommon1
          CFI (cfiPicker64) NoFunction
          CFI (cfiPicker64) Picker
        MOV     A,DPL
        ADD     A,R0
        MOV     DPL,A
        CLR     A
        ADDC    A,DPH
        MOV     DPH,A
        RET
          CFI (cfiCond62) CFA_SP SP+-1
          CFI (cfiCond63) CFA_SP SP+0
          CFI (cfiPicker64) CFA_SP SP+0
          CFI EndBlock cfiCond62
          CFI EndBlock cfiCond63
          CFI EndBlock cfiPicker64

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine6:
          CFI Block cfiCond65 Using cfiCommon0
          CFI Function usbdpGetStringDesc
          CFI Conditional ??CrossCallReturnLabel_0
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 17)
          CFI Block cfiCond66 Using cfiCommon0
          CFI (cfiCond66) Function usbdpGetStringDesc
          CFI (cfiCond66) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond66) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond66) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond66) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond66) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond66) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond66) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond66) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond66) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond66) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond66) CFA_SP SP+-2
          CFI (cfiCond66) CFA_XSP16 add(XSP16, 17)
          CFI Block cfiPicker67 Using cfiCommon1
          CFI (cfiPicker67) NoFunction
          CFI (cfiPicker67) Picker
        ANL     A,#0xf
        MOV     R2,A
        MOV     A,#hexDigit & 0xff
        ADD     A,R2
        MOV     DPL,A
        CLR     A
        ADDC    A,#(hexDigit >> 8) & 0xff
        MOV     DPH,A
        MOVX    A,@DPTR
        RET
          CFI (cfiCond65) CFA_SP SP+0
          CFI (cfiCond66) CFA_SP SP+0
          CFI (cfiPicker67) CFA_SP SP+0
          CFI EndBlock cfiCond65
          CFI EndBlock cfiCond66
          CFI EndBlock cfiPicker67
//  392 /// @}
//  393 
//  394 
// C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_framework.c
//    1 /******************************************************************************
//    2 
//    3  @file  usb_framework.c
//    4 
//    5  @brief USB library common functionality.
//    6 
//    7  Group: WCS, BTS
//    8  Target Device: CC2540, CC2541
//    9 
//   10  ******************************************************************************
//   11  
//   12  Copyright (c) 2004-2016, Texas Instruments Incorporated
//   13  All rights reserved.
//   14 
//   15  IMPORTANT: Your use of this Software is limited to those specific rights
//   16  granted under the terms of a software license agreement between the user
//   17  who downloaded the software, his/her employer (which must be your employer)
//   18  and Texas Instruments Incorporated (the "License"). You may not use this
//   19  Software unless you agree to abide by the terms of the License. The License
//   20  limits your use, and you acknowledge, that the Software may not be modified,
//   21  copied or distributed unless embedded on a Texas Instruments microcontroller
//   22  or used solely and exclusively in conjunction with a Texas Instruments radio
//   23  frequency transceiver, which is integrated into your product. Other than for
//   24  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   25  works of, modify, distribute, perform, display or sell this Software and/or
//   26  its documentation for any purpose.
//   27 
//   28  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   29  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   30  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   31  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   32  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   33  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   34  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   35  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   36  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   37  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   38  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   39 
//   40  Should you have any questions regarding your right to use this Software,
//   41  contact Texas Instruments Incorporated at www.TI.com.
//   42 
//   43  ******************************************************************************
//   44  Release Name: ble_sdk_1.4.2.2
//   45  Release Date: 2016-06-09 06:57:10
//   46  *****************************************************************************/
//   47 
//   48 /// \addtogroup module_usb_framework
//   49 /// @{
//   50 #define USBFRAMEWORK_C ///< Modifies the behavior of "EXTERN" in usb_framework.h
//   51 #include "usb_firmware_library_headers.h"
//   52 #include "usb_board_cfg.h"
//   53 
//   54 // Function pointer used by usbfwSetupHandler()
//   55 static VFPTR __data ProcessFunc;
//   56 
//   57 /** \brief Initializes the USB framework
//   58  *
//   59  * This function should be called when the microcontroller is ready to accept USB traffic. It enables the
//   60  * USB peripheral unit and enables the pull-up resistor on the D+ line. Endpoint status, current
//   61  * configuration value, etc. are initialized and evenetually re-initialized in the
//   62  * \ref usbfwResetHandler() function.
//   63  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   64 void usbfwInit(void)
usbfwInit:
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function usbfwInit
        CODE
//   65 {
        FUNCALL usbfwInit, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//   66     // Set default values
//   67     usbfwData.selfPowered = (usbdpGetConfigurationDesc(1, 0)->bmAttributes & 0x40) ? TRUE : FALSE;
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     R2,#0x0
        MOV     R1,#0x1
        LCALL   `??usbdpGetConfigurationDesc::?relay`; Banked call to: usbdpGetConfigurationDesc
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     C,0xE0 /* A   */.6
        MOV     DPTR,#usbfwData + 19
        JNC     ??usbfwInit_0
        MOV     A,#0x1
        SJMP    ??usbfwInit_1
??usbfwInit_0:
        CLR     A
??usbfwInit_1:
        MOVX    @DPTR,A
//   68     usbfwData.remoteWakeup = FALSE;
        MOV     DPTR,#usbfwData + 18
        CLR     A
        MOVX    @DPTR,A
//   69 
//   70     HAL_USB_ENABLE();
        MOV     DPTR,#0x620f
        MOV     A,#0x3
        MOVX    @DPTR,A
??usbfwInit_2:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.7
        JNC     ??usbfwInit_2
//   71 
//   72     // Enable Resume Interrupt
//   73     HAL_USB_RESUME_INT_ENABLE();
//   74 
//   75 } // usbfwInit
        LJMP    ??Subroutine29_0 & 0xFFFF
          CFI EndBlock cfiBlock68
//   76 
//   77 
//   78 
//   79 
//   80 /** \brief Handles USB reset signalling
//   81  *
//   82  * This function should be called, either from the USB interrupt or the main loop, when the \c USBCIF.RST
//   83  * flag has been set. Keep in mind that all bits in \c USBCIF register are cleared when the register is
//   84  * read. The function puts the device into the default state (not yet addressed), and puts all endpoints
//   85  * (except EP0) into the \ref EP_HALT state
//   86  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   87 void usbfwResetHandler(void)
usbfwResetHandler:
          CFI Block cfiBlock69 Using cfiCommon0
          CFI Function usbfwResetHandler
        CODE
//   88 {
        FUNCALL usbfwResetHandler, usbfwSetAllEpStatus
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//   89 
//   90    // Reset the USB state
//   91    usbfwData.usbState = DEV_DEFAULT;
        MOV     DPTR,#usbfwData
        MOV     A,#0x2
        MOVX    @DPTR,A
//   92    usbfwData.configurationValue = 0;
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//   93 
//   94    // Reset all endpoints
//   95    usbfwData.ep0Status = EP_IDLE;
        MOV     DPTR,#usbfwData + 7
        MOVX    @DPTR,A
//   96    usbfwSetAllEpStatus(EP_HALT);
        ; Setup parameters for call to function usbfwSetAllEpStatus
        MOV     R1,#0x3
        LCALL   `??usbfwSetAllEpStatus::?relay`; Banked call to: usbfwSetAllEpStatus
//   97 
//   98    // Reset last function pointer
//   99    ProcessFunc = NULL;
        MOV     ??ProcessFunc+0x0,#0x0
        MOV     ??ProcessFunc+0x1,#0x0
//  100 
//  101 } // usbfwResetHandler
        LJMP    ??Subroutine31_0 & 0xFFFF
          CFI EndBlock cfiBlock69
//  102 
//  103 
//  104 
//  105 
//  106 /** \brief USB Setup Handler
//  107  *
//  108  * This function should be called either from the USB interrupt or the main loop when the \c USBIIF.EP0IF
//  109  * flag has been set. Keep in mind that all bits in \c USBIIF register are cleared when the register is
//  110  * read. A detailed description of the framework is found in the \ref section_setup_handler_usage
//  111  * section.
//  112  *
//  113  * \note The USB header data is always little-endian, so if a big-endian compiler is used (such as Keil
//  114  * C51), the 16-bit values in the \ref usbSetupHeader must be flipped before they are used.
//  115  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  116 void usbfwSetupHandler(void)
usbfwSetupHandler:
          CFI Block cfiBlock70 Using cfiCommon0
          CFI Function usbfwSetupHandler
        CODE
//  117 {
        FUNCALL usbfwSetupHandler, usbfwReadFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbfwReadFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrSetAddress
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrSetFeature
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrClearFeature
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrSetConfiguration
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrSetInterface
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrGetStatus
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrGetDescriptor
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrGetConfiguration
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrGetInterface
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbvrHookProcessOut
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbvrHookProcessIn
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbcrHookProcessOut
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbcrHookProcessIn
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbfwWriteFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
//  118    uint8 controlReg;
//  119    uint8 bytesNow;
//  120    uint8 oldEndpoint;
//  121 
//  122    // Save the old index setting, then select endpoint 0 and fetch the control register
//  123    oldEndpoint = USBFW_GET_SELECTED_ENDPOINT();
        MOV     DPTR,#0x620e
        MOVX    A,@DPTR
        MOV     R6,A
//  124    USBFW_SELECT_ENDPOINT(0);
        CLR     A
        MOVX    @DPTR,A
//  125    controlReg = USBCS0;
        MOV     DPTR,#0x6211
        MOVX    A,@DPTR
        MOV     R7,A
//  126 
//  127    // The last transfer was ended prematurely by a new SETUP packet
//  128    if (controlReg & USBCS0_SETUP_END) {
        MOV     C,0xE0 /* A   */.4
        JNC     ??usbfwSetupHandler_0
//  129       USBCS0 = USBCS0_CLR_SETUP_END;
        MOV     A,#-0x80
        MOVX    @DPTR,A
//  130       usbfwData.ep0Status = EP_CANCEL;
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x7
        MOVX    @DPTR,A
//  131       if (ProcessFunc) ProcessFunc();
        MOV     A,??ProcessFunc+0x0
        ORL     A,??ProcessFunc+0x1
        JZ      ??usbfwSetupHandler_1
        ; Setup parameters for indirect call
        MOV     DPL,??ProcessFunc+0x0
        MOV     DPH,??ProcessFunc+0x1
        LCALL   ?CALL_IND
//  132       usbfwData.ep0Status = EP_IDLE;
??usbfwSetupHandler_1:
        MOV     DPTR,#usbfwData + 7
        CLR     A
        MOVX    @DPTR,A
//  133    }
//  134 
//  135    // A STALL handshake was transmitted to the PC
//  136    if (controlReg & USBCS0_SENT_STALL) {
??usbfwSetupHandler_0:
        MOV     A,R7
        MOV     C,0xE0 /* A   */.2
        JNC     ??usbfwSetupHandler_2
//  137       USBCS0 = 0x00;
        MOV     DPTR,#0x6211
        CLR     A
        MOVX    @DPTR,A
//  138       usbfwData.ep0Status = EP_IDLE;
        MOV     DPTR,#usbfwData + 7
        MOVX    @DPTR,A
        SJMP    ??usbfwSetupHandler_3
//  139    }
//  140 
//  141    // Receive OUT packets
//  142    if (usbfwData.ep0Status == EP_RX) {
??usbfwSetupHandler_2:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x2
        XRL     A,R0
        JNZ     ??usbfwSetupHandler_4
//  143 
//  144       // Read FIFO
//  145       bytesNow = USBCNT0;
        MOV     DPTR,#0x6216
        MOVX    A,@DPTR
        MOV     R7,A
//  146       usbfwReadFifo(&USBF0, bytesNow, usbSetupData.pBuffer);
        ; Setup parameters for call to function usbfwReadFifo
        MOV     DPTR,#usbSetupData
        LCALL   ?PUSH_XSTACK8_X_THREE
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R7
        MOV     R1,A
        MOV     R2,#0x20
        MOV     R3,#0x62
        LCALL   `??usbfwReadFifo::?relay`; Banked call to: usbfwReadFifo
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 11)
//  147       usbSetupData.bytesLeft -= bytesNow;
        MOV     A,R7
        MOV     R0,A
        MOV     DPTR,#usbSetupData + 3
        LCALL   ?Subroutine16 & 0xFFFF
//  148       usbSetupData.pBuffer += bytesNow;
??CrossCallReturnLabel_18:
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_50:
        MOV     A,R1
        ADD     A,R7
        LCALL   ?Subroutine22 & 0xFFFF
//  149 
//  150       // Arm the endpoint
//  151       USBCS0 = usbSetupData.bytesLeft ? USBCS0_CLR_OUTPKT_RDY : (USBCS0_CLR_OUTPKT_RDY | USBCS0_DATA_END);
??CrossCallReturnLabel_30:
        INC     DPTR
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_55:
        JZ      ??usbfwSetupHandler_5
        MOV     A,#0x40
        SJMP    ??usbfwSetupHandler_6
??usbfwSetupHandler_5:
        MOV     A,#0x48
??usbfwSetupHandler_6:
        MOV     DPTR,#0x6211
        MOVX    @DPTR,A
//  152 
//  153       // Make a call to the appropriate request handler when done
//  154       if (usbSetupData.bytesLeft == 0) {
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??usbfwSetupHandler_7 & 0xFFFF
        LJMP    ??usbfwSetupHandler_8 & 0xFFFF
//  155          if (ProcessFunc) ProcessFunc();
//  156          usbfwData.ep0Status = EP_IDLE;
//  157       }
//  158 
//  159       // Return here since nothing more will happen until the next interrupt
//  160       USBFW_SELECT_ENDPOINT(oldEndpoint);
//  161       return;
//  162 
//  163    // Let the application handle the reception
//  164    } else if (usbfwData.ep0Status == EP_MANUAL_RX) {
??usbfwSetupHandler_4:
        MOV     A,#0x6
        XRL     A,R0
        JNZ     ??usbfwSetupHandler_9
//  165       ProcessFunc();
        ; Setup parameters for indirect call
        MOV     DPL,??ProcessFunc+0x0
        MOV     DPH,??ProcessFunc+0x1
        LCALL   ?CALL_IND
//  166    }
//  167 
//  168    // Receive SETUP header
//  169    if (usbfwData.ep0Status == EP_IDLE) {
??usbfwSetupHandler_9:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??usbfwSetupHandler_10 & 0xFFFF
//  170       if (controlReg & USBCS0_OUTPKT_RDY) {
??usbfwSetupHandler_3:
        MOV     A,R7
        MOV     C,0xE0 /* A   */.0
        JC      $+5
        LJMP    ??usbfwSetupHandler_7 & 0xFFFF
//  171          usbfwReadFifo(&USBF0, 8, (uint8 __xdata *) &usbSetupHeader);
        ; Setup parameters for call to function usbfwReadFifo
        MOV     ?V0,#usbSetupHeader & 0xff
        MOV     ?V1,#(usbSetupHeader >> 8) & 0xff
        MOV     ?V2,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     R1,#0x8
        MOV     R2,#0x20
        MOV     R3,#0x62
        LCALL   `??usbfwReadFifo::?relay`; Banked call to: usbfwReadFifo
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 11)
//  172 
//  173          // Handle control transfers individually
//  174          ProcessFunc = NULL;
        MOV     ??ProcessFunc+0x0,#0x0
        MOV     ??ProcessFunc+0x1,#0x0
//  175          switch (usbSetupHeader.requestType & (RT_MASK_TYPE | RT_MASK_DIR)) {
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        ANL     A,#0xe0
        JZ      ??usbfwSetupHandler_11
        ADD     A,#-0x20
        JNZ     $+5
        LJMP    ??usbfwSetupHandler_12 & 0xFFFF
        ADD     A,#-0x20
        JZ      ??usbfwSetupHandler_13
        ADD     A,#-0x40
        JZ      ??usbfwSetupHandler_14
        ADD     A,#-0x20
        JNZ     $+5
        LJMP    ??usbfwSetupHandler_15 & 0xFFFF
        ADD     A,#-0x20
        JZ      ??usbfwSetupHandler_16
        LJMP    ??usbfwSetupHandler_17 & 0xFFFF
//  176 
//  177             // Standard requests with data from the host (OUT)
//  178          case RT_STD_OUT:
//  179             switch (usbSetupHeader.request) {
??usbfwSetupHandler_11:
        INC     DPTR
        MOVX    A,@DPTR
        DEC     A
        JZ      ??usbfwSetupHandler_18
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_19
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_20
        ADD     A,#-0x4
        JZ      ??usbfwSetupHandler_21
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_22
        SJMP    ??usbfwSetupHandler_17
//  180             case SET_ADDRESS:       usbsrSetAddress(); break;
??usbfwSetupHandler_20:
        ; Setup parameters for call to function usbsrSetAddress
        LCALL   `??usbsrSetAddress::?relay`; Banked call to: usbsrSetAddress
//  181             case SET_FEATURE:       usbsrSetFeature(); break;
//  182             case CLEAR_FEATURE:     usbsrClearFeature(); break;
//  183             case SET_CONFIGURATION: usbsrSetConfiguration(); break;
//  184             case SET_INTERFACE:     usbsrSetInterface(); break;
//  185             case SET_DESCRIPTOR:    /*usbsrHookSetDescriptor(); break; - unsupported */
//  186             default:                usbfwData.ep0Status = EP_STALL; break;
//  187             }
//  188             break;
//  189 
//  190             // Standard requests with data to the host (IN)
//  191          case RT_STD_IN:
//  192             switch (usbSetupHeader.request) {
//  193             case GET_STATUS:        usbsrGetStatus(); break;
//  194             case GET_DESCRIPTOR:    usbsrGetDescriptor(); break;
//  195             case GET_CONFIGURATION: usbsrGetConfiguration(); break;
//  196             case GET_INTERFACE:     usbsrGetInterface(); break;
//  197             case SYNCH_FRAME:       /*usbsrHookSynchFrame(); break; - unsupported */
//  198             default:                usbfwData.ep0Status = EP_STALL; break;
//  199             }
//  200             break;
//  201 
//  202             // Vendor requests
//  203          case RT_VEND_OUT:
//  204             ProcessFunc = usbvrHookProcessOut; usbvrHookProcessOut();
//  205             break;
//  206          case RT_VEND_IN:
//  207             ProcessFunc = usbvrHookProcessIn; usbvrHookProcessIn();
//  208             break;
//  209 
//  210             // Class requests
//  211          case RT_CLASS_OUT:
//  212             ProcessFunc = usbcrHookProcessOut; usbcrHookProcessOut();
//  213             break;
//  214          case RT_CLASS_IN:
//  215             ProcessFunc = usbcrHookProcessIn; usbcrHookProcessIn();
//  216             break;
//  217 
//  218             // Unrecognized request: Stall the endpoint
//  219          default:
//  220             usbfwData.ep0Status = EP_STALL;
//  221             break;
//  222          }
//  223 
//  224          // Arm/stall the endpoint
//  225          USBCS0 = (usbfwData.ep0Status == EP_STALL) ? (USBCS0_CLR_OUTPKT_RDY | USBCS0_SEND_STALL) : USBCS0_CLR_OUTPKT_RDY;
??usbfwSetupHandler_23:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbfwSetupHandler_24
??usbfwSetupHandler_25:
        MOV     R0,#0x60
        SJMP    ??usbfwSetupHandler_26
??usbfwSetupHandler_19:
        ; Setup parameters for call to function usbsrSetFeature
        LCALL   `??usbsrSetFeature::?relay`; Banked call to: usbsrSetFeature
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_18:
        ; Setup parameters for call to function usbsrClearFeature
        LCALL   `??usbsrClearFeature::?relay`; Banked call to: usbsrClearFeature
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_21:
        ; Setup parameters for call to function usbsrSetConfiguration
        LCALL   `??usbsrSetConfiguration::?relay`; Banked call to: usbsrSetConfiguration
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_22:
        ; Setup parameters for call to function usbsrSetInterface
        LCALL   `??usbsrSetInterface::?relay`; Banked call to: usbsrSetInterface
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_14:
        INC     DPTR
        MOVX    A,@DPTR
        JZ      ??usbfwSetupHandler_27
        ADD     A,#-0x6
        JZ      ??usbfwSetupHandler_28
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_29
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_30
        SJMP    ??usbfwSetupHandler_17
??usbfwSetupHandler_27:
        ; Setup parameters for call to function usbsrGetStatus
        LCALL   `??usbsrGetStatus::?relay`; Banked call to: usbsrGetStatus
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_28:
        ; Setup parameters for call to function usbsrGetDescriptor
        LCALL   `??usbsrGetDescriptor::?relay`; Banked call to: usbsrGetDescriptor
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_29:
        ; Setup parameters for call to function usbsrGetConfiguration
        LCALL   `??usbsrGetConfiguration::?relay`; Banked call to: usbsrGetConfiguration
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_30:
        ; Setup parameters for call to function usbsrGetInterface
        LCALL   `??usbsrGetInterface::?relay`; Banked call to: usbsrGetInterface
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_13:
        MOV     ??ProcessFunc+0x0,#`??usbvrHookProcessOut::?relay` & 0xff
        MOV     ??ProcessFunc+0x1,#(`??usbvrHookProcessOut::?relay` >> 8) & 0xff
        ; Setup parameters for call to function usbvrHookProcessOut
        LCALL   `??usbvrHookProcessOut::?relay`; Banked call to: usbvrHookProcessOut
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_16:
        MOV     ??ProcessFunc+0x0,#`??usbvrHookProcessIn::?relay` & 0xff
        MOV     ??ProcessFunc+0x1,#(`??usbvrHookProcessIn::?relay` >> 8) & 0xff
        ; Setup parameters for call to function usbvrHookProcessIn
        LCALL   `??usbvrHookProcessIn::?relay`; Banked call to: usbvrHookProcessIn
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_12:
        MOV     ??ProcessFunc+0x0,#`??usbcrHookProcessOut::?relay` & 0xff
        MOV     ??ProcessFunc+0x1,#(`??usbcrHookProcessOut::?relay` >> 8) & 0xff
        ; Setup parameters for call to function usbcrHookProcessOut
        LCALL   `??usbcrHookProcessOut::?relay`; Banked call to: usbcrHookProcessOut
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_15:
        MOV     ??ProcessFunc+0x0,#`??usbcrHookProcessIn::?relay` & 0xff
        MOV     ??ProcessFunc+0x1,#(`??usbcrHookProcessIn::?relay` >> 8) & 0xff
        ; Setup parameters for call to function usbcrHookProcessIn
        LCALL   `??usbcrHookProcessIn::?relay`; Banked call to: usbcrHookProcessIn
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_17:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
        SJMP    ??usbfwSetupHandler_25
//  226       }
//  227    }
??usbfwSetupHandler_24:
        MOV     R0,#0x40
??usbfwSetupHandler_26:
        MOV     A,R0
        MOV     DPTR,#0x6211
        MOVX    @DPTR,A
//  228 
//  229    // Transmit IN packets
//  230    if (usbfwData.ep0Status == EP_TX) {
??usbfwSetupHandler_10:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??usbfwSetupHandler_31
//  231       controlReg = USBCS0_INPKT_RDY;
        MOV     R7,#0x2
//  232 
//  233       // The last frame should contain 0 to (EP0_PACKET_SIZE - 1) bytes
//  234       if (usbSetupData.bytesLeft < EP0_PACKET_SIZE) {
        LCALL   ?Subroutine15 & 0xFFFF
??CrossCallReturnLabel_43:
        CLR     C
        MOV     A,R0
        SUBB    A,#0x20
        MOV     A,R1
        SUBB    A,#0x0
        JNC     ??usbfwSetupHandler_32
//  235          bytesNow = usbSetupData.bytesLeft;
        MOV     A,R0
        MOV     ?V0,A
//  236          controlReg |= USBCS0_DATA_END;
        MOV     R7,#0xa
        SJMP    ??usbfwSetupHandler_33
//  237 
//  238          // All other packets should have the maximum length
//  239       } else {
//  240          bytesNow = EP0_PACKET_SIZE;
??usbfwSetupHandler_32:
        MOV     ?V0,#0x20
//  241       }
//  242 
//  243       // Load the FIFO and move the pointer
//  244       usbfwWriteFifo(&USBF0, bytesNow, usbSetupData.pBuffer);
??usbfwSetupHandler_33:
        ; Setup parameters for call to function usbfwWriteFifo
        MOV     DPTR,#usbSetupData
        LCALL   ?PUSH_XSTACK8_X_THREE
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     R1,?V0
        MOV     R2,#0x20
        MOV     R3,#0x62
        LCALL   `??usbfwWriteFifo::?relay`; Banked call to: usbfwWriteFifo
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 11)
//  245       usbSetupData.pBuffer += bytesNow;
        MOV     R4,?V0
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_51:
        MOV     A,R1
        ADD     A,R4
        LCALL   ?Subroutine22 & 0xFFFF
//  246       usbSetupData.bytesLeft -= bytesNow;
??CrossCallReturnLabel_31:
        MOV     R0,?V0
        INC     DPTR
        LCALL   ?Subroutine16 & 0xFFFF
//  247 
//  248       // Arm the FIFO (even for a zero-length packet)
//  249       USBCS0 = controlReg;
??CrossCallReturnLabel_19:
        MOV     A,R7
        MOV     DPTR,#0x6211
        MOVX    @DPTR,A
//  250 
//  251       // Make a call to the appropriate request handler when done
//  252       if (bytesNow < EP0_PACKET_SIZE) {
        MOV     A,R0
        CLR     C
        SUBB    A,#0x20
        JNC     ??usbfwSetupHandler_7
//  253          if (ProcessFunc) ProcessFunc();
??usbfwSetupHandler_8:
        MOV     A,??ProcessFunc+0x0
        ORL     A,??ProcessFunc+0x1
        JZ      ??usbfwSetupHandler_34
        ; Setup parameters for indirect call
        MOV     DPL,??ProcessFunc+0x0
        MOV     DPH,??ProcessFunc+0x1
        LCALL   ?CALL_IND
//  254          usbfwData.ep0Status = EP_IDLE;
??usbfwSetupHandler_34:
        MOV     DPTR,#usbfwData + 7
        CLR     A
        MOVX    @DPTR,A
        SJMP    ??usbfwSetupHandler_7
//  255       }
//  256 
//  257    // Let the application handle the transmission
//  258    } else if (usbfwData.ep0Status == EP_MANUAL_TX) {
??usbfwSetupHandler_31:
        MOV     A,#0x5
        XRL     A,R0
        JNZ     ??usbfwSetupHandler_7
//  259       ProcessFunc();
        ; Setup parameters for indirect call
        MOV     DPL,??ProcessFunc+0x0
        MOV     DPH,??ProcessFunc+0x1
        LCALL   ?CALL_IND
//  260    }
//  261 
//  262    // Restore the old index setting
//  263    USBFW_SELECT_ENDPOINT(oldEndpoint);
??usbfwSetupHandler_7:
        MOV     A,R6
        MOV     DPTR,#0x620e
          CFI EndBlock cfiBlock70
        REQUIRE ?Subroutine0
        ; // Fall through to label ?Subroutine0
//  264 
//  265 } // usbfwSetupHandler

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
          CFI Block cfiBlock71 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOVX    @DPTR,A
          CFI EndBlock cfiBlock71
        REQUIRE ??Subroutine33_0
        ; // Fall through to label ??Subroutine33_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine33_0:
          CFI Block cfiBlock72 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x3
        LJMP    ?BANKED_LEAVE_XDATA
          CFI CFA_SP SP+-3
          CFI CFA_XSP16 XSP16+0
          CFI VB SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndBlock cfiBlock72

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine22:
          CFI Block cfiCond73 Using cfiCommon0
          CFI Function usbfwSetupHandler
          CFI Conditional ??CrossCallReturnLabel_30
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond74 Using cfiCommon0
          CFI (cfiCond74) Function usbfwSetupHandler
          CFI (cfiCond74) Conditional ??CrossCallReturnLabel_31
          CFI (cfiCond74) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond74) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond74) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond74) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond74) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond74) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond74) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond74) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond74) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond74) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond74) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond74) CFA_SP SP+-2
          CFI (cfiCond74) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker75 Using cfiCommon1
          CFI (cfiPicker75) NoFunction
          CFI (cfiPicker75) Picker
        MOV     R1,A
        CLR     A
        ADDC    A,R2
        MOV     R2,A
        MOV     DPTR,#usbSetupData
        MOV     A,R1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        RET
          CFI (cfiCond73) CFA_SP SP+0
          CFI (cfiCond74) CFA_SP SP+0
          CFI (cfiPicker75) CFA_SP SP+0
          CFI EndBlock cfiCond73
          CFI EndBlock cfiCond74
          CFI EndBlock cfiPicker75

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine16:
          CFI Block cfiCond76 Using cfiCommon0
          CFI Function usbfwSetupHandler
          CFI Conditional ??CrossCallReturnLabel_18
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond77 Using cfiCommon0
          CFI (cfiCond77) Function usbfwSetupHandler
          CFI (cfiCond77) Conditional ??CrossCallReturnLabel_19
          CFI (cfiCond77) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond77) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond77) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond77) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond77) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond77) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond77) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond77) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond77) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond77) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond77) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond77) CFA_SP SP+-2
          CFI (cfiCond77) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker78 Using cfiCommon1
          CFI (cfiPicker78) NoFunction
          CFI (cfiPicker78) Picker
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#0x0
        MOVX    @DPTR,A
        RET
          CFI (cfiCond76) CFA_SP SP+0
          CFI (cfiCond77) CFA_SP SP+0
          CFI (cfiPicker78) CFA_SP SP+0
          CFI EndBlock cfiCond76
          CFI EndBlock cfiCond77
          CFI EndBlock cfiPicker78

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine15:
          CFI Block cfiCond79 Using cfiCommon0
          CFI Function usbfwSetupHandler
          CFI Conditional ??CrossCallReturnLabel_43
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond80 Using cfiCommon0
          CFI (cfiCond80) Function usbsrGetDescriptor
          CFI (cfiCond80) Conditional ??CrossCallReturnLabel_44
          CFI (cfiCond80) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond80) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond80) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond80) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond80) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond80) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond80) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond80) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond80) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond80) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond80) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond80) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond80) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond80) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond80) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond80) CFA_SP SP+-2
          CFI (cfiCond80) CFA_XSP16 add(XSP16, 15)
          CFI Block cfiPicker81 Using cfiCommon1
          CFI (cfiPicker81) NoFunction
          CFI (cfiPicker81) Picker
        MOV     DPTR,#usbSetupData + 3
          CFI EndBlock cfiCond79
          CFI EndBlock cfiCond80
          CFI EndBlock cfiPicker81
        REQUIRE ??Subroutine34_0
        ; // Fall through to label ??Subroutine34_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine34_0:
          CFI Block cfiCond82 Using cfiCommon0
          CFI Function usbdpInit
          CFI Conditional ??CrossCallReturnLabel_41
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond83 Using cfiCommon0
          CFI (cfiCond83) Function usbdpFindNext
          CFI (cfiCond83) Conditional ??CrossCallReturnLabel_42
          CFI (cfiCond83) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond83) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond83) CFA_SP SP+-7
          CFI Block cfiCond84 Using cfiCommon0
          CFI (cfiCond84) Function usbfwSetupHandler
          CFI (cfiCond84) Conditional ??CrossCallReturnLabel_43
          CFI (cfiCond84) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond84) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond84) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond84) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond84) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond84) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond84) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond84) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond84) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond84) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond84) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond84) CFA_SP SP+-2
          CFI (cfiCond84) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond85 Using cfiCommon0
          CFI (cfiCond85) Function usbsrGetDescriptor
          CFI (cfiCond85) Conditional ??CrossCallReturnLabel_44
          CFI (cfiCond85) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond85) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond85) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond85) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond85) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond85) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond85) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond85) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond85) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond85) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond85) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond85) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond85) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond85) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond85) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond85) CFA_SP SP+-2
          CFI (cfiCond85) CFA_XSP16 add(XSP16, 15)
          CFI Block cfiPicker86 Using cfiCommon1
          CFI (cfiPicker86) NoFunction
          CFI (cfiPicker86) Picker
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_70:
        RET
          CFI (cfiCond82) CFA_SP SP+-5
          CFI (cfiCond83) CFA_SP SP+-5
          CFI (cfiCond84) CFA_SP SP+0
          CFI (cfiCond85) CFA_SP SP+0
          CFI (cfiPicker86) CFA_SP SP+0
          CFI EndBlock cfiCond82
          CFI EndBlock cfiCond83
          CFI EndBlock cfiCond84
          CFI EndBlock cfiCond85
          CFI EndBlock cfiPicker86

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine23:
          CFI Block cfiCond87 Using cfiCommon0
          CFI Function ublExec
          CFI Conditional ??CrossCallReturnLabel_67, ??CrossCallReturnLabel_4
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-4
          CFI CFA_XSP16 add(XSP16, 24)
          CFI Block cfiCond88 Using cfiCommon0
          CFI (cfiCond88) Function ublExec
          CFI (cfiCond88) Conditional ??CrossCallReturnLabel_67, ??CrossCallReturnLabel_5
          CFI (cfiCond88) R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI (cfiCond88) VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond88) V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond88) V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond88) V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond88) V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond88) V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond88) V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond88) V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond88) V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond88) V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond88) V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond88) V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond88) V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond88) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond88) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond88) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond88) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond88) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond88) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond88) CFA_SP SP+-4
          CFI (cfiCond88) CFA_XSP16 add(XSP16, 24)
          CFI Block cfiCond89 Using cfiCommon0
          CFI (cfiCond89) Function ublInit
          CFI (cfiCond89) Conditional ??CrossCallReturnLabel_67, ??CrossCallReturnLabel_6
          CFI (cfiCond89) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond89) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond89) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond89) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond89) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond89) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond89) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond89) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond89) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond89) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond89) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond89) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond89) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond89) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond89) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond89) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond89) CFA_SP SP+-4
          CFI (cfiCond89) CFA_XSP16 add(XSP16, 52)
          CFI Block cfiCond90 Using cfiCommon0
          CFI (cfiCond90) Function usbdpGetDeviceDesc
          CFI (cfiCond90) Conditional ??CrossCallReturnLabel_68, ??CrossCallReturnLabel_7
          CFI (cfiCond90) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond90) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond90) CFA_SP SP+-9
          CFI Block cfiCond91 Using cfiCommon0
          CFI (cfiCond91) Function usbdpGetConfigurationDesc
          CFI (cfiCond91) Conditional ??CrossCallReturnLabel_68, ??CrossCallReturnLabel_8
          CFI (cfiCond91) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond91) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond91) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond91) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond91) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond91) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond91) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond91) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond91) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond91) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond91) CFA_SP SP+-4
          CFI (cfiCond91) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond92 Using cfiCommon0
          CFI (cfiCond92) Function usbfwSetupHandler
          CFI (cfiCond92) Conditional ??CrossCallReturnLabel_70, ??CrossCallReturnLabel_43
          CFI (cfiCond92) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond92) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond92) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond92) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond92) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond92) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond92) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond92) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond92) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond92) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond92) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond92) CFA_SP SP+-4
          CFI (cfiCond92) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond93 Using cfiCommon0
          CFI (cfiCond93) Function usbsrGetDescriptor
          CFI (cfiCond93) Conditional ??CrossCallReturnLabel_70, ??CrossCallReturnLabel_44
          CFI (cfiCond93) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond93) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond93) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond93) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond93) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond93) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond93) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond93) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond93) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond93) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond93) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond93) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond93) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond93) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond93) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond93) CFA_SP SP+-4
          CFI (cfiCond93) CFA_XSP16 add(XSP16, 15)
          CFI Block cfiCond94 Using cfiCommon0
          CFI (cfiCond94) Function usbdpInit
          CFI (cfiCond94) Conditional ??CrossCallReturnLabel_70, ??CrossCallReturnLabel_41
          CFI (cfiCond94) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond94) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond94) CFA_SP SP+-9
          CFI Block cfiCond95 Using cfiCommon0
          CFI (cfiCond95) Function usbdpFindNext
          CFI (cfiCond95) Conditional ??CrossCallReturnLabel_70, ??CrossCallReturnLabel_42
          CFI (cfiCond95) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond95) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond95) CFA_SP SP+-9
          CFI Block cfiCond96 Using cfiCommon0
          CFI (cfiCond96) Function ??aesInitSig
          CFI (cfiCond96) Conditional ??CrossCallReturnLabel_69, ??CrossCallReturnLabel_9
          CFI (cfiCond96) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond96) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond96) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond96) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond96) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond96) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond96) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond96) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond96) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond96) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond96) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond96) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond96) CFA_SP SP+-4
          CFI (cfiCond96) CFA_XSP16 add(XSP16, 48)
          CFI Block cfiCond97 Using cfiCommon0
          CFI (cfiCond97) Function usbsrSetAddress
          CFI (cfiCond97) Conditional ??CrossCallReturnLabel_69, ??CrossCallReturnLabel_10
          CFI (cfiCond97) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond97) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond97) CFA_SP SP+-9
          CFI Block cfiCond98 Using cfiCommon0
          CFI (cfiCond98) Function usbsrGetDescriptor
          CFI (cfiCond98) Conditional ??CrossCallReturnLabel_69, ??CrossCallReturnLabel_11
          CFI (cfiCond98) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond98) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond98) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond98) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond98) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond98) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond98) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond98) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond98) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond98) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond98) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond98) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond98) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond98) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond98) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond98) CFA_SP SP+-4
          CFI (cfiCond98) CFA_XSP16 add(XSP16, 15)
          CFI Block cfiCond99 Using cfiCommon0
          CFI (cfiCond99) Function ??ConfigureEndpoints
          CFI (cfiCond99) Conditional ??CrossCallReturnLabel_69, ??CrossCallReturnLabel_12
          CFI (cfiCond99) R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond99) VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond99) V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond99) V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond99) V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond99) V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond99) V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond99) V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond99) V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond99) V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond99) V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond99) V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond99) V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond99) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond99) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond99) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond99) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond99) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond99) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond99) CFA_SP SP+-4
          CFI (cfiCond99) CFA_XSP16 add(XSP16, 19)
          CFI Block cfiCond100 Using cfiCommon0
          CFI (cfiCond100) Function usbsrGetStatus
          CFI (cfiCond100) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_64
          CFI (cfiCond100) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond100) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond100) CFA_SP SP+-9
          CFI Block cfiCond101 Using cfiCommon0
          CFI (cfiCond101) Function usbsrGetConfiguration
          CFI (cfiCond101) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_65
          CFI (cfiCond101) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond101) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond101) CFA_SP SP+-9
          CFI Block cfiCond102 Using cfiCommon0
          CFI (cfiCond102) Function usbsrGetInterface
          CFI (cfiCond102) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_66
          CFI (cfiCond102) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond102) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond102) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond102) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond102) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond102) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond102) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond102) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond102) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond102) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond102) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond102) CFA_SP SP+-4
          CFI (cfiCond102) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond103 Using cfiCommon0
          CFI (cfiCond103) Function ublExec
          CFI (cfiCond103) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_52
          CFI (cfiCond103) R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI (cfiCond103) VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond103) V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond103) V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond103) V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond103) V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond103) V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond103) V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond103) V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond103) V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond103) V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond103) V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond103) V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond103) V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond103) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond103) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond103) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond103) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond103) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond103) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond103) CFA_SP SP+-4
          CFI (cfiCond103) CFA_XSP16 add(XSP16, 24)
          CFI Block cfiCond104 Using cfiCommon0
          CFI (cfiCond104) Function ublExec
          CFI (cfiCond104) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_53
          CFI (cfiCond104) R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI (cfiCond104) VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond104) V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond104) V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond104) V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond104) V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond104) V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond104) V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond104) V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond104) V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond104) V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond104) V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond104) V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond104) V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond104) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond104) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond104) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond104) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond104) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond104) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond104) CFA_SP SP+-4
          CFI (cfiCond104) CFA_XSP16 add(XSP16, 24)
          CFI Block cfiCond105 Using cfiCommon0
          CFI (cfiCond105) Function ublInit
          CFI (cfiCond105) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_54
          CFI (cfiCond105) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond105) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond105) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond105) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond105) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond105) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond105) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond105) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond105) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond105) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond105) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond105) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond105) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond105) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond105) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond105) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond105) CFA_SP SP+-4
          CFI (cfiCond105) CFA_XSP16 add(XSP16, 52)
          CFI Block cfiCond106 Using cfiCommon0
          CFI (cfiCond106) Function usbfwSetupHandler
          CFI (cfiCond106) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_55
          CFI (cfiCond106) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond106) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond106) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond106) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond106) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond106) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond106) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond106) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond106) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond106) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond106) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond106) CFA_SP SP+-4
          CFI (cfiCond106) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond107 Using cfiCommon0
          CFI (cfiCond107) Function ??ChangeFeature
          CFI (cfiCond107) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_56
          CFI (cfiCond107) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond107) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond107) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond107) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond107) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond107) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond107) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond107) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond107) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond107) CFA_SP SP+-4
          CFI (cfiCond107) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond108 Using cfiCommon0
          CFI (cfiCond108) Function ??ChangeFeature
          CFI (cfiCond108) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_57
          CFI (cfiCond108) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond108) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond108) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond108) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond108) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond108) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond108) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond108) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond108) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond108) CFA_SP SP+-4
          CFI (cfiCond108) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond109 Using cfiCommon0
          CFI (cfiCond109) Function usbsrSetAddress
          CFI (cfiCond109) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_58
          CFI (cfiCond109) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond109) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond109) CFA_SP SP+-9
          CFI Block cfiCond110 Using cfiCommon0
          CFI (cfiCond110) Function usbsrSetAddress
          CFI (cfiCond110) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_59
          CFI (cfiCond110) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond110) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond110) CFA_SP SP+-9
          CFI Block cfiCond111 Using cfiCommon0
          CFI (cfiCond111) Function usbsrGetConfiguration
          CFI (cfiCond111) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_60
          CFI (cfiCond111) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond111) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond111) CFA_SP SP+-9
          CFI Block cfiCond112 Using cfiCommon0
          CFI (cfiCond112) Function usbsrSetConfiguration
          CFI (cfiCond112) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_61
          CFI (cfiCond112) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond112) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond112) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond112) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond112) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond112) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond112) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond112) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond112) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond112) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond112) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond112) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond112) CFA_SP SP+-4
          CFI (cfiCond112) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond113 Using cfiCommon0
          CFI (cfiCond113) Function usbsrSetConfiguration
          CFI (cfiCond113) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_62
          CFI (cfiCond113) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond113) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond113) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond113) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond113) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond113) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond113) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond113) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond113) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond113) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond113) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond113) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond113) CFA_SP SP+-4
          CFI (cfiCond113) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond114 Using cfiCommon0
          CFI (cfiCond114) Function usbsrSetInterface
          CFI (cfiCond114) Conditional ??CrossCallReturnLabel_71, ??CrossCallReturnLabel_63
          CFI (cfiCond114) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond114) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond114) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond114) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond114) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond114) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond114) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond114) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond114) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond114) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond114) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond114) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond114) CFA_SP SP+-4
          CFI (cfiCond114) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiPicker115 Using cfiCommon1
          CFI (cfiPicker115) NoFunction
          CFI (cfiPicker115) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        RET
          CFI (cfiCond87) CFA_SP SP+-2
          CFI (cfiCond88) CFA_SP SP+-2
          CFI (cfiCond89) CFA_SP SP+-2
          CFI (cfiCond90) CFA_SP SP+-7
          CFI (cfiCond91) CFA_SP SP+-2
          CFI (cfiCond92) CFA_SP SP+-2
          CFI (cfiCond93) CFA_SP SP+-2
          CFI (cfiCond94) CFA_SP SP+-7
          CFI (cfiCond95) CFA_SP SP+-7
          CFI (cfiCond96) CFA_SP SP+-2
          CFI (cfiCond97) CFA_SP SP+-7
          CFI (cfiCond98) CFA_SP SP+-2
          CFI (cfiCond99) CFA_SP SP+-2
          CFI (cfiCond100) CFA_SP SP+-7
          CFI (cfiCond101) CFA_SP SP+-7
          CFI (cfiCond102) CFA_SP SP+-2
          CFI (cfiCond103) CFA_SP SP+-2
          CFI (cfiCond104) CFA_SP SP+-2
          CFI (cfiCond105) CFA_SP SP+-2
          CFI (cfiCond106) CFA_SP SP+-2
          CFI (cfiCond107) CFA_SP SP+-2
          CFI (cfiCond108) CFA_SP SP+-2
          CFI (cfiCond109) CFA_SP SP+-7
          CFI (cfiCond110) CFA_SP SP+-7
          CFI (cfiCond111) CFA_SP SP+-7
          CFI (cfiCond112) CFA_SP SP+-2
          CFI (cfiCond113) CFA_SP SP+-2
          CFI (cfiCond114) CFA_SP SP+-2
          CFI (cfiPicker115) CFA_SP SP+0
          CFI EndBlock cfiCond87
          CFI EndBlock cfiCond88
          CFI EndBlock cfiCond89
          CFI EndBlock cfiCond90
          CFI EndBlock cfiCond91
          CFI EndBlock cfiCond92
          CFI EndBlock cfiCond93
          CFI EndBlock cfiCond94
          CFI EndBlock cfiCond95
          CFI EndBlock cfiCond96
          CFI EndBlock cfiCond97
          CFI EndBlock cfiCond98
          CFI EndBlock cfiCond99
          CFI EndBlock cfiCond100
          CFI EndBlock cfiCond101
          CFI EndBlock cfiCond102
          CFI EndBlock cfiCond103
          CFI EndBlock cfiCond104
          CFI EndBlock cfiCond105
          CFI EndBlock cfiCond106
          CFI EndBlock cfiCond107
          CFI EndBlock cfiCond108
          CFI EndBlock cfiCond109
          CFI EndBlock cfiCond110
          CFI EndBlock cfiCond111
          CFI EndBlock cfiCond112
          CFI EndBlock cfiCond113
          CFI EndBlock cfiCond114
          CFI EndBlock cfiPicker115
//  266 
//  267 
//  268 
//  269 
//  270 /** \brief Changes the state of endpoint 1-5 IN/OUT
//  271  *
//  272  * This is an internal function used by the library.
//  273  *
//  274  * \param[in]       status
//  275  *     The new status for each endpoint
//  276  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  277 void usbfwSetAllEpStatus(EP_STATUS status)
usbfwSetAllEpStatus:
          CFI Block cfiBlock116 Using cfiCommon0
          CFI Function usbfwSetAllEpStatus
        CODE
//  278 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  279    uint8 n;
//  280    for (n = 0; n < sizeof(usbfwData.pEpInStatus); n++)
//  281        usbfwData.pEpInStatus[n] = status;
        MOV     A,R1
        MOV     DPTR,#usbfwData + 8
        MOV     R0,#0x5
??usbfwSetAllEpStatus_0:
        MOVX    @DPTR,A
        INC     DPTR
        DJNZ    R0,??usbfwSetAllEpStatus_0
//  282    for (n = 0; n < sizeof(usbfwData.pEpOutStatus); n++)
//  283        usbfwData.pEpOutStatus[n] = status;
        MOV     DPTR,#usbfwData + 13
        MOV     R0,#0x5
??usbfwSetAllEpStatus_1:
        MOVX    @DPTR,A
        INC     DPTR
        DJNZ    R0,??usbfwSetAllEpStatus_1
//  284 } // usbfwSetAllEpStatus
        LJMP    ??Subroutine31_0 & 0xFFFF
          CFI EndBlock cfiBlock116
//  285 
//  286 
//  287 
//  288 
//  289 /** \brief Reads from the selected OUT endpoint FIFO, without using DMA
//  290  *
//  291  * The FIFO must be re-armed after reading it empty (using the \ref USBFW_ARM_OUT_ENDPOINT() macro). This
//  292  * is not necessary when flushing the FIFO.
//  293  *
//  294  * \param[in]       *pFifo
//  295  *     Pointer to the FIFO (\c &USBFx)
//  296  * \param[in]       count
//  297  *     The number of bytes to read
//  298  * \param[in]       *pData
//  299  *     A pointer to the storage location for the read data (in any memory space)
//  300  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  301 void usbfwReadFifo(uint8 volatile __xdata *pFifo, uint8 count, void __generic *pData)
usbfwReadFifo:
          CFI Block cfiBlock117 Using cfiCommon0
          CFI Function usbfwReadFifo
        CODE
//  302 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     A,R1
        MOV     R0,A
//  303    uint8 __generic *pTemp = pData;
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        LCALL   ??Subroutine35_0 & 0xFFFF
//  304    if (count) {
??CrossCallReturnLabel_48:
        MOV     A,R0
        JZ      ??usbfwReadFifo_0
//  305       do {
//  306          *(pTemp++) = *pFifo;
??usbfwReadFifo_1:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        LCALL   ?C_GPTR_STORE
        MOV     A,R1
        ADD     A,#0x1
        INC     R1
        CLR     A
        ADDC    A,R2
        MOV     R2,A
//  307       } while (--count);
        DJNZ    R0,??usbfwReadFifo_1
//  308    }
//  309 } // usbfwReadFifo
??usbfwReadFifo_0:
        SJMP    ?Subroutine4
          CFI EndBlock cfiBlock117

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine9:
          CFI Block cfiCond118 Using cfiCommon0
          CFI Function usbfwSetupHandler
          CFI Conditional ??CrossCallReturnLabel_50
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond119 Using cfiCommon0
          CFI (cfiCond119) Function usbfwSetupHandler
          CFI (cfiCond119) Conditional ??CrossCallReturnLabel_51
          CFI (cfiCond119) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond119) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond119) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond119) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond119) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond119) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond119) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond119) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond119) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond119) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond119) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond119) CFA_SP SP+-2
          CFI (cfiCond119) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker120 Using cfiCommon1
          CFI (cfiPicker120) NoFunction
          CFI (cfiPicker120) Picker
        MOV     DPTR,#usbSetupData
          CFI EndBlock cfiCond118
          CFI EndBlock cfiCond119
          CFI EndBlock cfiPicker120
        REQUIRE ??Subroutine35_0
        ; // Fall through to label ??Subroutine35_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine35_0:
          CFI Block cfiCond121 Using cfiCommon0
          CFI Function usbfwReadFifo
          CFI Conditional ??CrossCallReturnLabel_48
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond122 Using cfiCommon0
          CFI (cfiCond122) Function usbfwWriteFifo
          CFI (cfiCond122) Conditional ??CrossCallReturnLabel_49
          CFI (cfiCond122) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond122) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond122) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond122) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond122) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond122) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond122) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond122) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond122) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond122) CFA_SP SP+-2
          CFI (cfiCond122) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond123 Using cfiCommon0
          CFI (cfiCond123) Function usbfwSetupHandler
          CFI (cfiCond123) Conditional ??CrossCallReturnLabel_50
          CFI (cfiCond123) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond123) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond123) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond123) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond123) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond123) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond123) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond123) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond123) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond123) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond123) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond123) CFA_SP SP+-2
          CFI (cfiCond123) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond124 Using cfiCommon0
          CFI (cfiCond124) Function usbfwSetupHandler
          CFI (cfiCond124) Conditional ??CrossCallReturnLabel_51
          CFI (cfiCond124) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond124) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond124) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond124) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond124) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond124) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond124) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond124) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond124) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond124) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond124) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond124) CFA_SP SP+-2
          CFI (cfiCond124) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker125 Using cfiCommon1
          CFI (cfiPicker125) NoFunction
          CFI (cfiPicker125) Picker
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
          CFI EndBlock cfiCond121
          CFI EndBlock cfiCond122
          CFI EndBlock cfiCond123
          CFI EndBlock cfiCond124
          CFI EndBlock cfiPicker125
        REQUIRE ??Subroutine36_0
        ; // Fall through to label ??Subroutine36_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine36_0:
          CFI Block cfiCond126 Using cfiCommon0
          CFI Function HalFlashRead
          CFI Conditional ??CrossCallReturnLabel_45
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond127 Using cfiCommon0
          CFI (cfiCond127) Function usbdpFindNext
          CFI (cfiCond127) Conditional ??CrossCallReturnLabel_46
          CFI (cfiCond127) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond127) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond127) CFA_SP SP+-7
          CFI Block cfiCond128 Using cfiCommon0
          CFI (cfiCond128) Function usbsrGetDescriptor
          CFI (cfiCond128) Conditional ??CrossCallReturnLabel_47
          CFI (cfiCond128) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond128) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond128) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond128) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond128) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond128) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond128) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond128) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond128) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond128) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond128) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond128) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond128) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond128) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond128) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond128) CFA_SP SP+-2
          CFI (cfiCond128) CFA_XSP16 add(XSP16, 15)
          CFI Block cfiCond129 Using cfiCommon0
          CFI (cfiCond129) Function usbfwReadFifo
          CFI (cfiCond129) Conditional ??CrossCallReturnLabel_48
          CFI (cfiCond129) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond129) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond129) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond129) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond129) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond129) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond129) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond129) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond129) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond129) CFA_SP SP+-2
          CFI (cfiCond129) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond130 Using cfiCommon0
          CFI (cfiCond130) Function usbfwWriteFifo
          CFI (cfiCond130) Conditional ??CrossCallReturnLabel_49
          CFI (cfiCond130) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond130) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond130) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond130) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond130) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond130) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond130) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond130) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond130) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond130) CFA_SP SP+-2
          CFI (cfiCond130) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond131 Using cfiCommon0
          CFI (cfiCond131) Function usbfwSetupHandler
          CFI (cfiCond131) Conditional ??CrossCallReturnLabel_50
          CFI (cfiCond131) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond131) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond131) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond131) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond131) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond131) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond131) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond131) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond131) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond131) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond131) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond131) CFA_SP SP+-2
          CFI (cfiCond131) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond132 Using cfiCommon0
          CFI (cfiCond132) Function usbfwSetupHandler
          CFI (cfiCond132) Conditional ??CrossCallReturnLabel_51
          CFI (cfiCond132) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond132) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond132) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond132) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond132) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond132) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond132) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond132) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond132) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond132) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond132) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond132) CFA_SP SP+-2
          CFI (cfiCond132) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker133 Using cfiCommon1
          CFI (cfiPicker133) NoFunction
          CFI (cfiPicker133) Picker
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        RET
          CFI (cfiCond126) CFA_SP SP+0
          CFI (cfiCond127) CFA_SP SP+-5
          CFI (cfiCond128) CFA_SP SP+0
          CFI (cfiCond129) CFA_SP SP+0
          CFI (cfiCond130) CFA_SP SP+0
          CFI (cfiCond131) CFA_SP SP+0
          CFI (cfiCond132) CFA_SP SP+0
          CFI (cfiPicker133) CFA_SP SP+0
          CFI EndBlock cfiCond126
          CFI EndBlock cfiCond127
          CFI EndBlock cfiCond128
          CFI EndBlock cfiCond129
          CFI EndBlock cfiCond130
          CFI EndBlock cfiCond131
          CFI EndBlock cfiCond132
          CFI EndBlock cfiPicker133
//  310 
//  311 
//  312 
//  313 
//  314 /** \brief Writes to the selected IN endpoint FIFO, without using DMA
//  315  *
//  316  * Note that the FIFO must be armed in order to be transmitted (using the \ref USBFW_ARM_IN_ENDPOINT()
//  317  * macro).
//  318  *
//  319  * \param[in]       *pFifo
//  320  *     Pointer to the FIFO (\c &USBFx)
//  321  * \param[in]       count
//  322  *     The number of bytes to write
//  323  * \param[in]       *pData
//  324  *     A pointer to the data to be written (from any memory space)
//  325  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  326 void usbfwWriteFifo(uint8 volatile __xdata *pFifo, uint8 count, void __generic *pData)
usbfwWriteFifo:
          CFI Block cfiBlock134 Using cfiCommon0
          CFI Function usbfwWriteFifo
        CODE
//  327 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     A,R1
        MOV     R0,A
//  328    uint8 __generic *pTemp = pData;
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        LCALL   ??Subroutine35_0 & 0xFFFF
//  329    if (count) {
??CrossCallReturnLabel_49:
        MOV     A,R0
        JZ      ??usbfwWriteFifo_0
//  330       do {
//  331          *pFifo = *(pTemp++);
??usbfwWriteFifo_1:
        LCALL   ?C_GPTR_LOAD
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    @DPTR,A
        MOV     A,R1
        ADD     A,#0x1
        INC     R1
        CLR     A
        ADDC    A,R2
        MOV     R2,A
//  332       } while (--count);
        DJNZ    R0,??usbfwWriteFifo_1
//  333    }
//  334 } // usbfwWriteFifo
??usbfwWriteFifo_0:
          CFI EndBlock cfiBlock134
        REQUIRE ?Subroutine4
        ; // Fall through to label ?Subroutine4

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine4:
          CFI Block cfiBlock135 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
          CFI CFA_SP SP+-3
          CFI CFA_XSP16 XSP16+0
          CFI VB SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndBlock cfiBlock135
//  335 
//  336 
//  337 /// @}
//  338 
// C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_interrupt.c
//    1 /******************************************************************************
//    2 
//    3  @file  usb_interrupt.c
//    4 
//    5  @brief USB library interrupt initialisation and ISR.
//    6 
//    7  Group: WCS, BTS
//    8  Target Device: CC2540, CC2541
//    9 
//   10  ******************************************************************************
//   11  
//   12  Copyright (c) 2008-2016, Texas Instruments Incorporated
//   13  All rights reserved.
//   14 
//   15  IMPORTANT: Your use of this Software is limited to those specific rights
//   16  granted under the terms of a software license agreement between the user
//   17  who downloaded the software, his/her employer (which must be your employer)
//   18  and Texas Instruments Incorporated (the "License"). You may not use this
//   19  Software unless you agree to abide by the terms of the License. The License
//   20  limits your use, and you acknowledge, that the Software may not be modified,
//   21  copied or distributed unless embedded on a Texas Instruments microcontroller
//   22  or used solely and exclusively in conjunction with a Texas Instruments radio
//   23  frequency transceiver, which is integrated into your product. Other than for
//   24  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   25  works of, modify, distribute, perform, display or sell this Software and/or
//   26  its documentation for any purpose.
//   27 
//   28  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   29  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   30  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   31  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   32  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   33  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   34  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   35  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   36  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   37  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   38  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   39 
//   40  Should you have any questions regarding your right to use this Software,
//   41  contact Texas Instruments Incorporated at www.TI.com.
//   42 
//   43  ******************************************************************************
//   44  Release Name: ble_sdk_1.4.2.2
//   45  Release Date: 2016-06-09 06:57:10
//   46  *****************************************************************************/
//   47 
//   48 /// \addtogroup module_usb_interrupt
//   49 /// @{
//   50 #define USBINTERRUPT_C ///< Modifies the behavior of "EXTERN" in usb_interrupt.h
//   51 #include "usb_firmware_library_headers.h"
//   52 #include "usb_board_cfg.h"
//   53 #include "hal_flash.h"
//   54 
//   55 /** \brief Initializes the \ref module_usb_interrupt module
//   56  *
//   57  * This function should be called after the \ref module_usb_framework module has been initialized.
//   58  * Use interrupt group priority control (refer to the CC2531 datasheet) to adjust the priority of the
//   59  * USB interrupt relative to other interrupts.
//   60  *
//   61  * \param[in]       irqMask
//   62  *     A bit mask containing USBIRQ_EVENT bits for all events that shall be reported
//   63  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   64 void usbirqInit(uint16 irqMask)
usbirqInit:
          CFI Block cfiBlock136 Using cfiCommon0
          CFI Function usbirqInit
        CODE
//   65 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//   66     // Initialize variables
//   67     usbirqData.eventMask = 0x0000;
        MOV     usbirqData+0x0,#0x0
        MOV     usbirqData+0x1,#0x0
//   68     usbirqData.inSuspend = FALSE;
        MOV     usbirqData + 2,#0x0
//   69     usbirqData.irqMask = irqMask;
        MOV     usbirqData + 3+0x0,R2
        MOV     usbirqData + 3+0x1,R3
//   70 
//   71     // Select which IRQ flags to handle
//   72     USBCIE = irqMask;
        MOV     A,R2
        MOV     DPTR,#0x620b
        MOVX    @DPTR,A
//   73     USBIIE = irqMask >> 4;
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     A,#0x4
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        MOV     DPTR,#0x6207
        MOVX    @DPTR,A
//   74     USBOIE = (irqMask >> 9) & 0x3E;
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     A,#0x9
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        ANL     A,#0x3e
        MOV     DPTR,#0x6209
        MOVX    @DPTR,A
//   75 
//   76     HAL_USB_INT_CLEAR();
        LJMP    ?Subroutine1 & 0xFFFF
          CFI EndBlock cfiBlock136
        REQUIRE P2IFG
        REQUIRE _A_IRCON2
//   77     HAL_USB_INT_ENABLE();
//   78 
//   79 } // usbirqInit
//   80 
//   81 
//   82 
//   83 /** \brief USB interrupt handler
//   84  *
//   85  * Clears the P2 interrupt flag and converts all USB interrupt flags into events.
//   86  * The interrupt also lets \ref usbsuspEnter() break from the suspend loop.
//   87  */
//   88 #if defined HAL_SB_BOOT_CODE

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   89 void usbirqHandler(void)
usbirqHandler:
          CFI Block cfiBlock137 Using cfiCommon0
          CFI Function usbirqHandler
        CODE
//   90 #else
//   91 #pragma vector=P2INT_VECTOR
//   92 __interrupt void usbirqHandler(void)
//   93 #endif
//   94 {
        FUNCALL usbirqHandler, usbirqHookProcessEvents
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//   95    uint8 usbcif;
//   96 
//   97    // First make sure that the crystal oscillator is stable
//   98    while (!CC2530_IS_XOSC_STABLE());
??usbirqHandler_0:
        MOV     A,0x9d
        MOV     C,0xE0 /* A   */.6
        JNC     ??usbirqHandler_0
//   99 
//  100    // Special handling for reset interrupts
//  101    usbcif = USBCIF;
        MOV     DPTR,#0x6206
        MOVX    A,@DPTR
        MOV     R1,A
//  102    if (usbcif & USBCIF_RSTIF) {
        MOV     C,0xE0 /* A   */.2
        JNC     ??usbirqHandler_1
//  103 
//  104        // All interrupts (except suspend) are by default enabled by hardware, so
//  105        // re-initialize the enable bits to avoid unwanted interrupts
//  106        USBCIE = usbirqData.irqMask;
        MOV     R2,usbirqData + 3+0x0
        MOV     A,R2
        MOV     DPTR,#0x620b
        MOVX    @DPTR,A
//  107        USBIIE = usbirqData.irqMask >> 4;
        MOV     ?V0,A
        MOV     ?V1,usbirqData + 3+0x1
        MOV     A,#0x4
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        MOV     DPTR,#0x6207
        MOVX    @DPTR,A
//  108        USBOIE = (usbirqData.irqMask >> 9) & 0x3E;
        MOV     ?V0,R2
        MOV     ?V1,usbirqData + 3+0x1
        MOV     A,#0x9
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        ANL     A,#0x3e
        MOV     DPTR,#0x6209
        MOVX    @DPTR,A
//  109 
//  110        // Enable suspend mode when suspend signaling is detected on the bus
//  111        USBPOW |= USBPOW_SUSPEND_EN;
        MOV     DPTR,#0x6201
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
//  112    }
//  113 
//  114    // Record events (keeping existing)
//  115    usbirqData.eventMask |= (uint16) usbcif;
??usbirqHandler_1:
        MOV     A,R1
        MOV     R0,#usbirqData
        ORL     A,@R0
        MOV     @R0,A
//  116    usbirqData.eventMask |= (uint16) USBIIF << 4;
        MOV     DPTR,#0x6202
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     ?V1,#0x0
        MOV     A,#0x4
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     R0,#usbirqData
        MOV     A,?V0
        ORL     A,@R0
        MOV     @R0,A
        INC     R0
        MOV     A,?V1
        ORL     A,@R0
        MOV     @R0,A
//  117    usbirqData.eventMask |= (uint16) USBOIF << 9;
        MOV     DPTR,#0x6204
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     ?V1,#0x0
        MOV     A,#0x9
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     R0,#usbirqData + 1
        MOV     A,?V1
        ORL     A,@R0
        MOV     @R0,A
//  118 
//  119    // If we get a suspend event, we should always enter suspend mode. We must,
//  120    // however be sure that we exit the suspend loop upon resume or reset
//  121    // signaling.
//  122    if (usbcif & USBCIF_SUSPENDIF) {
        MOV     A,R1
        MOV     C,0xE0 /* A   */.0
        JNC     ??usbirqHandler_2
//  123       usbirqData.inSuspend = TRUE;
        MOV     usbirqData + 2,#0x1
//  124    }
//  125    if (usbcif & (USBCIF_RSTIF | USBCIF_RESUMEIF)) {
??usbirqHandler_2:
        MOV     A,#0x6
        ANL     A,R1
        JZ      ??usbirqHandler_3
//  126       usbirqData.inSuspend = FALSE;
        MOV     usbirqData + 2,#0x0
//  127    }
//  128    if (P2IFG & P2IFG_DPIF) {
??usbirqHandler_3:
        MOV     A,0x8b
        MOV     C,0xE0 /* A   */.5
        JNC     ??usbirqHandler_4
//  129       // Resume interrupt detected on D+ line while in suspend
//  130       P2IFG = (P2IFG_DPIF ^ 0xFF);
        MOV     0x8b,#-0x21
//  131       usbirqData.inSuspend = FALSE;
        MOV     usbirqData + 2,#0x0
//  132    }
//  133 
//  134    // Handle event which need immediate processing
//  135    usbirqHookProcessEvents();
??usbirqHandler_4:
        ; Setup parameters for call to function usbirqHookProcessEvents
        LCALL   `??usbirqHookProcessEvents::?relay`; Banked call to: usbirqHookProcessEvents
//  136 
//  137    // Clear the interrupt
//  138    HAL_USB_INT_CLEAR();
        LJMP    ?Subroutine1 & 0xFFFF
          CFI EndBlock cfiBlock137
        REQUIRE SLEEPSTA
        REQUIRE P2IFG
        REQUIRE _A_IRCON2
//  139 
//  140 } // usbirqHandler
//  141 
//  142 //@}
//  143 
// C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_standard_requests.c
//    1 /******************************************************************************
//    2 
//    3  @file  usb_standard_requests.c
//    4 
//    5  @brief Handle USB standard requests.
//    6 
//    7  Group: WCS, BTS
//    8  Target Device: CC2540, CC2541
//    9 
//   10  ******************************************************************************
//   11  
//   12  Copyright (c) 2004-2016, Texas Instruments Incorporated
//   13  All rights reserved.
//   14 
//   15  IMPORTANT: Your use of this Software is limited to those specific rights
//   16  granted under the terms of a software license agreement between the user
//   17  who downloaded the software, his/her employer (which must be your employer)
//   18  and Texas Instruments Incorporated (the "License"). You may not use this
//   19  Software unless you agree to abide by the terms of the License. The License
//   20  limits your use, and you acknowledge, that the Software may not be modified,
//   21  copied or distributed unless embedded on a Texas Instruments microcontroller
//   22  or used solely and exclusively in conjunction with a Texas Instruments radio
//   23  frequency transceiver, which is integrated into your product. Other than for
//   24  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   25  works of, modify, distribute, perform, display or sell this Software and/or
//   26  its documentation for any purpose.
//   27 
//   28  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   29  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   30  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   31  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   32  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   33  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   34  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   35  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   36  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   37  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   38  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   39 
//   40  Should you have any questions regarding your right to use this Software,
//   41  contact Texas Instruments Incorporated at www.TI.com.
//   42 
//   43  ******************************************************************************
//   44  Release Name: ble_sdk_1.4.2.2
//   45  Release Date: 2016-06-09 06:57:10
//   46  *****************************************************************************/
//   47 
//   48 /// \addtogroup module_usb_standard_requests
//   49 /// @{
//   50 #include "usb_firmware_library_headers.h"
//   51 #include "hal_types.h"
//   52 #include "hal_board.h"
//   53 
//   54 
//   55 
//   56 /** \brief Processes the \ref GET_STATUS request (returns status for the specified recipient)
//   57  *
//   58  * The recipient bits in \ref USB_SETUP_HEADER.requestType specify the desired recipient. This is either the
//   59  * (one and only) device, a specific interface, or a specific endpoint. Some of the status bits can be
//   60  * changed with the SET_FEATURE and CLEAR_FEATURE requests.
//   61  *
//   62  * <b>Parameters</b>:
//   63  * - VALUE: Always 0
//   64  * - INDEX: Depends upon the recipient:
//   65  *     - DEVICE: Always 0
//   66  *     - INTERFACE: Interface number
//   67  *     - ENDPOINT: Endpoint address
//   68  * - LENGTH: Always 2
//   69  *
//   70  * <b>Data (IN)</b>:
//   71  * Depends upon the recipient (the bit field illustrations are MSB first, LSB last):
//   72  * - DEVICE: <tt>00000000.000000RS</tt>, where R(1) = DEVICE_REMOTE_WAKEUP and S(0) = SELF_POWERED
//   73  * - INTERFACE: <tt>00000000.00000000</tt> (all bits are reserved)
//   74  * - ENDPOINT: <tt>00000000.0000000H</tt>, where H(0) = ENDPOINT_HALT
//   75  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   76 void usbsrGetStatus(void)
usbsrGetStatus:
          CFI Block cfiBlock138 Using cfiCommon0
          CFI Function usbsrGetStatus
        CODE
//   77 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//   78    uint8 endpoint;
//   79    static uint16 __xdata status;
//   80 
//   81    // Common sanity check
//   82    if (usbSetupHeader.value || HI_UINT16(usbSetupHeader.index) || (usbSetupHeader.length != 2)) {
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_64:
        JZ      $+5
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??usbsrGetStatus_1
        INC     DPTR
        MOVX    A,@DPTR
??usbsrGetStatus_1:
        JZ      $+5
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
//   83       usbfwData.ep0Status = EP_STALL;
//   84 
//   85    // Return status for device, interface, or endpoint
//   86    } else {
//   87       switch (usbSetupHeader.requestType) {
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        ADD     A,#-0x80
        JZ      ??usbsrGetStatus_2
        DEC     A
        JZ      ??usbsrGetStatus_3
        DEC     A
        JZ      ??usbsrGetStatus_4
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
//   88 
//   89          // Device status:
//   90          //     Bit 0: Self powered
//   91          //     Bit 1: Remote wake-up allowed
//   92       case RT_IN_DEVICE:
//   93 
//   94          // Sanity check
//   95          if (LO_UINT16(usbSetupHeader.index)) {
??usbsrGetStatus_2:
        MOV     A,R0
        JZ      $+5
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
//   96             usbfwData.ep0Status = EP_STALL;
//   97 
//   98          // Get the bit values from the USBFW_DATA struct
//   99          } else {
//  100 
//  101             // Self powered?
//  102             status = usbfwData.selfPowered ? 0x0001 : 0x0000;
        MOV     DPTR,#usbfwData + 19
        MOVX    A,@DPTR
        MOV     DPTR,#??status
        JZ      ??usbsrGetStatus_5
        MOV     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        SJMP    ??usbsrGetStatus_6
??usbsrGetStatus_5:
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
??usbsrGetStatus_6:
        MOVX    @DPTR,A
//  103 
//  104             // Remote wakeup?
//  105             if (usbfwData.remoteWakeup) status |= 0x0002;
        MOV     DPTR,#usbfwData + 18
        MOVX    A,@DPTR
        JZ      ??usbsrGetStatus_7
        MOV     DPTR,#??status
        MOVX    A,@DPTR
        ORL     A,#0x2
??usbsrGetStatus_8:
        MOVX    @DPTR,A
//  106          }
//  107          break;
//  108 
//  109          // Interface status:
//  110          //     All bits are reserved
//  111       case RT_IN_INTERFACE:
//  112 
//  113          // Sanity check
//  114          if (usbfwData.usbState != DEV_CONFIGURED) {
//  115             usbfwData.ep0Status = EP_STALL;
//  116          } else {
//  117             status = 0x0000;
//  118          }
//  119          break;
//  120 
//  121          // Endpoint status:
//  122          //     Bit 0: Endpoint halted
//  123       case RT_IN_ENDPOINT:
//  124          endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
//  125 
//  126          // Sanity check
//  127          if ((usbfwData.usbState != DEV_CONFIGURED) || (endpoint > 5)) {
//  128             usbfwData.ep0Status = EP_STALL;
//  129 
//  130          // Translate endpoint address to status index and return the status
//  131          } else {
//  132 
//  133             // IN
//  134             if (LO_UINT16(usbSetupHeader.index) & 0x80) {
//  135                status = (usbfwData.pEpInStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
//  136 
//  137             // OUT
//  138             } else {
//  139                status = (usbfwData.pEpOutStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
//  140             }
//  141          }
//  142          break;
//  143 
//  144       default:
//  145          usbfwData.ep0Status = EP_STALL;
//  146          break;
//  147       }
//  148 
//  149       if (usbfwData.ep0Status != EP_STALL) {
??usbsrGetStatus_7:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??usbsrGetStatus_9
//  150          // Send it
//  151          usbSetupData.pBuffer = (uint8 __generic *)&status;
        MOV     DPTR,#usbSetupData
        MOV     A,#??status & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(??status >> 8) & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//  152          usbSetupData.bytesLeft = 2;
        INC     DPTR
        MOV     A,#0x2
        LCALL   ?Subroutine26 & 0xFFFF
//  153          usbfwData.ep0Status = EP_TX;
//  154       }
??CrossCallReturnLabel_36:
        MOVX    @DPTR,A
//  155    }
//  156 } // usbsrGetStatus
??usbsrGetStatus_9:
        LJMP    ??Subroutine31_0 & 0xFFFF
??usbsrGetStatus_3:
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrGetStatus_0
??usbsrGetStatus_10:
        MOV     DPTR,#??status
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        SJMP    ??usbsrGetStatus_8
??usbsrGetStatus_4:
        MOV     A,R0
        ANL     A,#0x7f
        MOV     R2,A
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrGetStatus_0
        MOV     A,R2
        CLR     C
        SUBB    A,#0x6
        JNC     ??usbsrGetStatus_0
        MOV     A,#usbfwData & 0xff
        ADD     A,R2
        MOV     DPL,A
        CLR     A
        ADDC    A,#(usbfwData >> 8) & 0xff
        MOV     DPH,A
        MOV     A,R0
        ANL     A,#0x80
        JZ      ??usbsrGetStatus_11
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??usbsrGetStatus_10
        SJMP    ??usbsrGetStatus_12
??usbsrGetStatus_11:
        MOV     A,DPL
        ADD     A,#0xc
        MOV     DPL,A
        JNC     ??usbsrGetStatus_13
        INC     DPH
??usbsrGetStatus_13:
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??usbsrGetStatus_10
??usbsrGetStatus_12:
        MOV     DPTR,#??status
        MOV     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        SJMP    ??usbsrGetStatus_8
??usbsrGetStatus_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??CrossCallReturnLabel_36
          CFI EndBlock cfiBlock138

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
??status:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  157 
//  158 
//  159 
//  160 
//  161 /** \brief Internal function used for the very similar \ref SET_FEATURE and \ref CLEAR_FEATURE requests
//  162  *
//  163  * This function either sets or clears the specified feature on the specified recipient.
//  164  *
//  165  * \param[in]       set
//  166  *     When TRUE, the feature is set. When FALSE, the feature is cleared.
//  167  *
//  168  * \return
//  169  *     TRUE if the selected feature is supported by the USB library. FALSE to indicate that
//  170  *     \ref usbsrHookClearFeature() or \ref usbsrHookSetFeature() must be called.
//  171  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  172 static uint8 ChangeFeature(uint8 set)
??ChangeFeature:
          CFI Block cfiBlock139 Using cfiCommon0
          CFI Function ??ChangeFeature
        CODE
//  173 {
        FUNCALL ??ChangeFeature, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??ChangeFeature, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??ChangeFeature, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
//  174    uint8 endpoint;
//  175 
//  176    // Sanity check
//  177    if (usbSetupHeader.length || (usbfwData.usbState != DEV_CONFIGURED) && (usbSetupHeader.index != 0)) {
        MOV     DPTR,#usbSetupHeader + 6
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_56:
        JZ      $+5
        LJMP    ??ChangeFeature_1 & 0xFFFF
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??ChangeFeature_2
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_57:
        JZ      $+5
        LJMP    ??ChangeFeature_1 & 0xFFFF
//  178       usbfwData.ep0Status = EP_STALL;
//  179 
//  180       // Handle based on recipient
//  181    } else {
//  182       switch (usbSetupHeader.requestType & RT_MASK_RECIP) {
??ChangeFeature_2:
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        ANL     A,#0x1f
        JZ      ??ChangeFeature_3
        DEC     A
        JZ      ??ChangeFeature_4
        DEC     A
        JZ      ??ChangeFeature_5
        LJMP    ??ChangeFeature_1 & 0xFFFF
//  183 
//  184       // Device
//  185       case RT_RECIP_DEV:
//  186 
//  187          // Sanity check
//  188          if (LO_UINT16(usbSetupHeader.value) != DEVICE_REMOTE_WAKEUP) {
??ChangeFeature_3:
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??ChangeFeature_4
//  189             return FALSE;
//  190          } else {
//  191             usbfwData.remoteWakeup = set;
        MOV     A,R6
        MOV     DPTR,#usbfwData + 18
        MOVX    @DPTR,A
//  192             usbsrHookProcessEvent(set ? USBSR_EVENT_REMOTE_WAKEUP_ENABLED : USBSR_EVENT_REMOTE_WAKEUP_DISABLED, 0);
        JZ      ??ChangeFeature_6
        MOV     R1,#0x5
        SJMP    ??ChangeFeature_7
??ChangeFeature_6:
        MOV     R1,#0x6
??ChangeFeature_7:
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     R2,#0x0
        LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
//  193          }
//  194          break;
        LJMP    ??ChangeFeature_8 & 0xFFFF
//  195 
//  196       // Endpoint
//  197       case RT_RECIP_IF:
//  198          return FALSE;
//  199 
//  200       // Endpoint
//  201       case RT_RECIP_EP:
//  202          endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
??ChangeFeature_5:
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ANL     A,#0x7f
        MOV     R2,A
//  203 
//  204          // Sanity check
//  205          if (LO_UINT16(usbSetupHeader.value) != ENDPOINT_HALT) {
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        JZ      ??ChangeFeature_9
//  206             return FALSE;
??ChangeFeature_4:
        MOV     R1,#0x0
        LJMP    ??ChangeFeature_10 & 0xFFFF
//  207          } else if (endpoint > 5) {
??ChangeFeature_9:
        MOV     A,R2
        CLR     C
        SUBB    A,#0x6
        JNC     ??ChangeFeature_1
//  208             usbfwData.ep0Status = EP_STALL;
//  209          } else {
//  210             USBFW_SELECT_ENDPOINT(endpoint);
        MOV     A,R2
        MOV     DPTR,#0x620e
        MOVX    @DPTR,A
//  211 
//  212             // IN
//  213             if (LO_UINT16(usbSetupHeader.index) & 0x80) {
        MOV     A,#usbfwData & 0xff
        ADD     A,R2
        MOV     R0,A
        CLR     A
        ADDC    A,#(usbfwData >> 8) & 0xff
        MOV     R1,A
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ANL     A,#0x80
        JZ      ??ChangeFeature_11
//  214                USBCSIL = set ? USBCSIL_SEND_STALL : USBCSIL_CLR_DATA_TOG;
        MOV     A,R6
        JZ      ??ChangeFeature_12
        MOV     A,#0x10
        SJMP    ??ChangeFeature_13
??ChangeFeature_12:
        MOV     A,#0x40
??ChangeFeature_13:
        MOV     DPTR,#0x6211
        MOVX    @DPTR,A
//  215                usbfwData.pEpInStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
        MOV     A,R6
        JZ      ??ChangeFeature_14
        MOV     R3,#0x3
        SJMP    ??ChangeFeature_15
??ChangeFeature_14:
        MOV     R3,#0x0
??ChangeFeature_15:
        MOV     A,R3
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
//  216                usbsrHookProcessEvent(set ? USBSR_EVENT_EPIN_STALL_SET : USBSR_EVENT_EPIN_STALL_CLEARED, endpoint);
        MOV     A,R6
        JZ      ??ChangeFeature_16
        MOV     R1,#0x8
        SJMP    ??ChangeFeature_17
??ChangeFeature_16:
        MOV     R1,#0x7
        ; Setup parameters for call to function usbsrHookProcessEvent
        SJMP    ??ChangeFeature_17
//  217 
//  218             // OUT
//  219             } else {
//  220                USBCSOL = set ? USBCSOL_SEND_STALL : USBCSOL_CLR_DATA_TOG;
??ChangeFeature_11:
        MOV     A,R6
        JZ      ??ChangeFeature_18
        MOV     R3,#0x20
        SJMP    ??ChangeFeature_19
??ChangeFeature_18:
        MOV     R3,#-0x80
??ChangeFeature_19:
        MOV     A,R3
        MOV     DPTR,#0x6214
        MOVX    @DPTR,A
//  221                usbfwData.pEpOutStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
        MOV     A,R6
        JZ      ??ChangeFeature_20
        MOV     R3,#0x3
        SJMP    ??ChangeFeature_21
??ChangeFeature_20:
        MOV     R3,#0x0
??ChangeFeature_21:
        MOV     A,R0
        ADD     A,#0xc
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        MOV     A,R3
        MOVX    @DPTR,A
//  222                usbsrHookProcessEvent(set ? USBSR_EVENT_EPOUT_STALL_SET : USBSR_EVENT_EPOUT_STALL_CLEARED, endpoint);
        MOV     A,R6
        JZ      ??ChangeFeature_22
        MOV     R1,#0xa
        SJMP    ??ChangeFeature_17
??ChangeFeature_22:
        MOV     R1,#0x9
??ChangeFeature_17:
        ; Setup parameters for call to function usbsrHookProcessEvent
        LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
//  223             }
//  224             USBFW_SELECT_ENDPOINT(0);
        MOV     DPTR,#0x620e
        CLR     A
        SJMP    ??ChangeFeature_23
//  225          }
//  226          break;
//  227 
//  228       default:
//  229          usbfwData.ep0Status = EP_STALL;
??ChangeFeature_1:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
??ChangeFeature_23:
        MOVX    @DPTR,A
//  230          break;
//  231       }
//  232    }
//  233    return TRUE;
??ChangeFeature_8:
        MOV     R1,#0x1
??ChangeFeature_10:
        LJMP    ?Subroutine4 & 0xFFFF
//  234 } // ChangeFeature
          CFI EndBlock cfiBlock139
//  235 
//  236 
//  237 
//  238 
//  239 /** \brief Processes the \ref CLEAR_FEATURE request (clears or disables a specific feature)
//  240  *
//  241  * The feature selector value must be appropriate to the recipient.
//  242  *
//  243  * <b>Parameters</b>:
//  244  * - VALUE: Feature selector:
//  245  *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
//  246  *     - \c ENDPOINT_HALT(0): Clear the halt feature for the specified endpoint (not endpoint 0!)
//  247  * - INDEX: Depends upon the recipient:
//  248  *     - DEVICE: Always 0
//  249  *     - INTERFACE: Interface number
//  250  *     - ENDPOINT: Endpoint address
//  251  * - LENGTH: Always 0
//  252  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  253 void usbsrClearFeature()
usbsrClearFeature:
          CFI Block cfiBlock140 Using cfiCommon0
          CFI Function usbsrClearFeature
        CODE
//  254 {
        FUNCALL usbsrClearFeature, ??ChangeFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrClearFeature, usbsrHookClearFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  255    if (!ChangeFeature(FALSE)) {
        ; Setup parameters for call to function ChangeFeature
        MOV     R1,#0x0
        LCALL   `??ChangeFeature::?relay`; Banked call to: ChangeFeature
        MOV     A,R1
        JNZ     ??usbsrClearFeature_0
//  256       usbsrHookClearFeature();
        ; Setup parameters for call to function usbsrHookClearFeature
        LCALL   `??usbsrHookClearFeature::?relay`; Banked call to: usbsrHookClearFeature
//  257    }
//  258 } // usbsrClearFeature
??usbsrClearFeature_0:
        LJMP    ??Subroutine31_0 & 0xFFFF
          CFI EndBlock cfiBlock140
//  259 
//  260 
//  261 
//  262 
//  263 /** \brief Processes the \ref SET_FEATURE request (sets or enables a specific feature)
//  264  *
//  265  * The feature selector value must be appropriate to the recipient.
//  266  *
//  267  * <b>Parameters</b>:
//  268  * - VALUE: Feature selector:
//  269  *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
//  270  *     - \c ENDPOINT_HALT(0): Set the halt feature for the specified endpoint (not endpoint 0!)
//  271  * - INDEX: Depends upon the recipient:
//  272  *     - DEVICE: Always 0
//  273  *     - INTERFACE: Interface number
//  274  *     - ENDPOINT: Endpoint address
//  275  * - LENGTH: Always 0
//  276  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  277 void usbsrSetFeature(void)
usbsrSetFeature:
          CFI Block cfiBlock141 Using cfiCommon0
          CFI Function usbsrSetFeature
        CODE
//  278 {
        FUNCALL usbsrSetFeature, ??ChangeFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetFeature, usbsrHookSetFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  279    if (!ChangeFeature(TRUE)) {
        ; Setup parameters for call to function ChangeFeature
        MOV     R1,#0x1
        LCALL   `??ChangeFeature::?relay`; Banked call to: ChangeFeature
        MOV     A,R1
        JNZ     ??usbsrSetFeature_0
//  280       usbsrHookSetFeature();
        ; Setup parameters for call to function usbsrHookSetFeature
        LCALL   `??usbsrHookSetFeature::?relay`; Banked call to: usbsrHookSetFeature
//  281    }
//  282 } // usbsrSetFeature
??usbsrSetFeature_0:
        LJMP    ??Subroutine31_0 & 0xFFFF
          CFI EndBlock cfiBlock141
//  283 
//  284 
//  285 
//  286 
//  287 /** \brief Processes the \ref SET_ADDRESS request (sets the device address for all future device
//  288  * accesses)
//  289  *
//  290  * If the value is between 1 and 127 and the device is in the default state, it will enter the address
//  291  * state. If it already is in the address state, it starts to use the newly-specified address.
//  292  *
//  293  * If the value is 0 and the device is in the address state, it will enter the default state. If it
//  294  * already is in the default state, nothing happens.
//  295  *
//  296  * <b>Parameters</b>:
//  297  * - VALUE: The device address (0-127)
//  298  * - INDEX: Always 0
//  299  * - LENGTH: Always 0
//  300  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  301 void usbsrSetAddress(void)
usbsrSetAddress:
          CFI Block cfiBlock142 Using cfiCommon0
          CFI Function usbsrSetAddress
        CODE
//  302 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  303 
//  304    // Sanity check
//  305    if (usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value) || (LO_UINT16(usbSetupHeader.value) & 0x80)) {
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_58:
        JNZ     ??usbsrSetAddress_0
        INC     DPTR
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_59:
        JNZ     ??usbsrSetAddress_0
        MOV     DPTR,#usbSetupHeader + 2
        LCALL   ?Subroutine12 & 0xFFFF
??CrossCallReturnLabel_10:
        ANL     A,#0x80
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,R2
        ORL     A,R3
        JZ      ??usbsrSetAddress_1
//  306       usbfwData.ep0Status = EP_STALL;
??usbsrSetAddress_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??usbsrSetAddress_2
//  307 
//  308    // Update the device address
//  309    } else {
//  310       USBADDR = LO_UINT16(usbSetupHeader.value);
??usbsrSetAddress_1:
        MOV     A,R0
        MOV     DPTR,#0x6200
        MOVX    @DPTR,A
//  311       if (LO_UINT16(usbSetupHeader.value) != 0) {
        MOV     DPTR,#usbfwData
        JZ      ??usbsrSetAddress_3
//  312          if (usbfwData.usbState == DEV_DEFAULT) usbfwData.usbState = DEV_ADDRESS;
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??usbsrSetAddress_4
        MOV     A,#0x3
        SJMP    ??usbsrSetAddress_2
//  313       } else {
//  314          if (usbfwData.usbState == DEV_ADDRESS) usbfwData.usbState = DEV_DEFAULT;
??usbsrSetAddress_3:
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??usbsrSetAddress_4
        MOV     A,#0x2
??usbsrSetAddress_2:
        MOVX    @DPTR,A
//  315       }
//  316    }
//  317 
//  318 } // usbsrSetAddress
??usbsrSetAddress_4:
        LJMP    ??Subroutine31_0 & 0xFFFF
          CFI EndBlock cfiBlock142
//  319 
//  320 
//  321 
//  322 
//  323 /** \brief Processes the \ref GET_DESCRIPTOR request (returns the specified USB descriptor)
//  324  *
//  325  * The \ref module_usb_descriptor_parser module is used to locate device, configuration and string
//  326  * descriptors. Note that configuration descriptors also include interface, endpoint and other
//  327  * "similar" descriptor types (e.g. HID descriptor), with the total descriptor length specified by
//  328  * the \ref USB_CONFIGURATION_DESCRIPTOR.wTotalLength field.
//  329  *
//  330  * Other descriptor types that are not returned with the configuration descriptor, must be defined in
//  331  * the usbDescriptorMarker.pUsbDescLut lookup-table. This table specifies the values of the VALUE and INDEX fields, and
//  332  * gives a pointer to the descriptor along with it's length.
//  333  *
//  334  * <b>Parameters</b>:
//  335  * - VALUE.MSB: Descriptor type
//  336  * - VALUE.LSB: Descriptor index
//  337  * - INDEX: 0, or language ID for string descriptors (currently not supported)
//  338  * - LENGTH: Descriptor length (either the requested number of bytes, or the length of the descriptor,
//  339  *           whichever is the smallest)
//  340  *
//  341  * <b>Data (IN)</b>:
//  342  * The descriptor(s)
//  343  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  344 void usbsrGetDescriptor(void)
usbsrGetDescriptor:
          CFI Block cfiBlock143 Using cfiCommon0
          CFI Function usbsrGetDescriptor
        CODE
//  345 {
        FUNCALL usbsrGetDescriptor, usbdpGetDeviceDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrGetDescriptor, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrGetDescriptor, usbdpGetStringDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        MOV     A,#-0xf
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 15)
        ; Saved register size: 15
        ; Auto size: 0
//  346    uint8 n;
//  347 
//  348    // Which descriptor?
//  349    switch (HI_UINT16(usbSetupHeader.value)) {
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
        DEC     A
        JZ      ??usbsrGetDescriptor_0
        DEC     A
        JZ      ??usbsrGetDescriptor_1
        DEC     A
        JZ      ??usbsrGetDescriptor_2
        SJMP    ??usbsrGetDescriptor_3
//  350 
//  351    // Device descriptor
//  352    case DESC_TYPE_DEVICE:
//  353       usbSetupData.pBuffer = (uint8 __code*) usbdpGetDeviceDesc();
??usbsrGetDescriptor_0:
        ; Setup parameters for call to function usbdpGetDeviceDesc
        LCALL   `??usbdpGetDeviceDesc::?relay`; Banked call to: usbdpGetDeviceDesc
        LCALL   ?Subroutine17 & 0xFFFF
//  354       usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
??CrossCallReturnLabel_20:
        INC     DPTR
        MOV     R3,#-0x80
        SJMP    ??usbsrGetDescriptor_4
//  355       break;
//  356 
//  357    // Configuration descriptor
//  358    case DESC_TYPE_CONFIG:
//  359       usbSetupData.pBuffer = (uint8 __code*) usbdpGetConfigurationDesc(0, LO_UINT16(usbSetupHeader.value));
??usbsrGetDescriptor_1:
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     R1,#0x0
        LCALL   `??usbdpGetConfigurationDesc::?relay`; Banked call to: usbdpGetConfigurationDesc
        LCALL   ?Subroutine17 & 0xFFFF
//  360       usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_CONFIG_LENGTH_LSB_IDX] +
//  361                                usbSetupData.pBuffer[DESC_CONFIG_LENGTH_MSB_IDX] * 256;
??CrossCallReturnLabel_21:
        MOV     R3,#-0x80
        MOV     A,R1
        ADD     A,#0x2
        MOV     R1,A
        CLR     A
        ADDC    A,R2
        MOV     R2,A
        LCALL   ?C_GPTR_LOAD
        MOV     R4,A
        DEC     R1
        DEC     R1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOV     A,R1
        ADD     A,#0x3
        MOV     R1,A
        CLR     A
        ADDC    A,R2
        MOV     R2,A
        LCALL   ?C_GPTR_LOAD
        MOV     R1,A
        MOV     A,R4
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        SJMP    ??usbsrGetDescriptor_5
//  362       break;
//  363 
//  364    // String descriptor
//  365    case DESC_TYPE_STRING:
//  366       // OPT: Implement language ID
//  367       usbSetupData.pBuffer = (uint8*) usbdpGetStringDesc(LO_UINT16(usbSetupHeader.value));
??usbsrGetDescriptor_2:
        ; Setup parameters for call to function usbdpGetStringDesc
        MOV     A,R2
        MOV     R1,A
        LCALL   `??usbdpGetStringDesc::?relay`; Banked call to: usbdpGetStringDesc
        MOV     DPTR,#usbSetupData
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        LCALL   ?Subroutine25 & 0xFFFF
//  368       usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
??CrossCallReturnLabel_34:
        INC     DPTR
        MOV     R3,#0x0
??usbsrGetDescriptor_4:
        LCALL   ?C_GPTR_LOAD
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
??usbsrGetDescriptor_5:
        MOVX    @DPTR,A
//  369       break;
        LJMP    ??usbsrGetDescriptor_6 & 0xFFFF
//  370 
//  371    // Other descriptor type
//  372    default:
//  373       // Perform a table search (on index and value)
//  374       usbSetupData.pBuffer = NULL;
??usbsrGetDescriptor_3:
        MOV     DPTR,#usbSetupData
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  375       for (n = 0; n < ((uint16)usbDescriptorMarker.pUsbDescLutEnd - (uint16)usbDescriptorMarker.pUsbDescLut) / sizeof(DESC_LUT_INFO); n++) {
        MOV     ?V6,#0x0
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        MOV     ?V4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V5,A
        MOV     DPTR,#usbDescriptorMarker + 4
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        LJMP    ??usbsrGetDescriptor_7 & 0xFFFF
//  376          if ((usbDescriptorMarker.pUsbDescLut[n].valueMsb == HI_UINT16(usbSetupHeader.value))
//  377              && (usbDescriptorMarker.pUsbDescLut[n].valueLsb == LO_UINT16(usbSetupHeader.value))
//  378              && (usbDescriptorMarker.pUsbDescLut[n].indexMsb == HI_UINT16(usbSetupHeader.index))
//  379              && (usbDescriptorMarker.pUsbDescLut[n].indexLsb == LO_UINT16(usbSetupHeader.index)) )
??usbsrGetDescriptor_8:
        MOV     ?V0,?V6
        MOV     ?V1,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     A,R4
        ADD     A,?V0
        MOV     R0,A
        MOV     A,R5
        ADDC    A,?V1
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        CLR     A
        MOVC    A,@A+DPTR
        XRL     A,?V3
        JNZ     ??usbsrGetDescriptor_9
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R2
        MOV     R6,A
        POP     A
          CFI CFA_SP SP+0
        XRL     A,R6
        JNZ     ??usbsrGetDescriptor_9
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R6,?V5
        XRL     A,R6
        JNZ     ??usbsrGetDescriptor_9
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R6,?V4
        XRL     A,R6
        JNZ     ??usbsrGetDescriptor_9
//  380          {
//  381             usbSetupData.pBuffer = usbDescriptorMarker.pUsbDescLut[n].pDescStart;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     ?V0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     ?V1,A
        MOV     DPTR,#usbSetupData
        MOV     A,?V0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x80
        MOVX    @DPTR,A
//  382             usbSetupData.bytesLeft = usbDescriptorMarker.pUsbDescLut[n].length;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     DPTR,#usbSetupData + 3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  383          }
//  384       }
??usbsrGetDescriptor_9:
        INC     ?V6
??usbsrGetDescriptor_7:
        MOV     DPTR,#usbDescriptorMarker + 6
        LCALL   ?Subroutine12 & 0xFFFF
//  385    }
??CrossCallReturnLabel_11:
        CLR     C
        SUBB    A,R4
        MOV     ?V0,A
        MOV     A,R1
        SUBB    A,R5
        MOV     ?V1,A
        MOV     A,#0x3
        MOV     R0,#?V0
        LCALL   ?US_SHR
        CLR     C
        MOV     A,?V6
        SUBB    A,?V0
        CLR     A
        SUBB    A,?V1
        JNC     $+5
        LJMP    ??usbsrGetDescriptor_8 & 0xFFFF
//  386 
//  387    // Stall EP0 if no descriptor was found
//  388    if (usbSetupData.pBuffer == NULL) usbfwData.ep0Status = EP_STALL;
??usbsrGetDescriptor_6:
        MOV     DPTR,#usbSetupData
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,R4
        ORL     A,R5
        ORL     A,R6
        MOV     DPTR,#usbfwData + 7
        JNZ     ??usbsrGetDescriptor_10
        MOV     A,#0x4
        SJMP    ??usbsrGetDescriptor_11
//  389 
//  390    if (usbfwData.ep0Status != EP_STALL) {
??usbsrGetDescriptor_10:
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??usbsrGetDescriptor_12
//  391 
//  392       // Limit the returned descriptor size (the PC wants to know about sizes before
//  393       // polling the complete descriptors)
//  394       if (usbSetupData.bytesLeft > usbSetupHeader.length) {
        MOV     DPTR,#usbSetupHeader + 6
        LCALL   ??Subroutine36_0 & 0xFFFF
??CrossCallReturnLabel_47:
        LCALL   ?Subroutine15 & 0xFFFF
??CrossCallReturnLabel_44:
        CLR     C
        MOV     A,R2
        SUBB    A,R0
        MOV     A,R3
        SUBB    A,R1
        JNC     ??usbsrGetDescriptor_13
//  395          usbSetupData.bytesLeft = usbSetupHeader.length;
        MOV     DPTR,#usbSetupData + 3
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  396       }
//  397 
//  398       usbfwData.ep0Status = EP_TX;
??usbsrGetDescriptor_13:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x1
??usbsrGetDescriptor_11:
        MOVX    @DPTR,A
//  399    }
//  400 
//  401 } // usbsrGetDescriptor
??usbsrGetDescriptor_12:
        MOV     R7,#0x7
        LJMP    ?BANKED_LEAVE_XDATA
          CFI R6 SameValue
          CFI VB SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI R7 SameValue
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI CFA_SP SP+-3
          CFI CFA_XSP16 XSP16+0
          CFI EndBlock cfiBlock143

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine17:
          CFI Block cfiCond144 Using cfiCommon0
          CFI Function usbsrGetDescriptor
          CFI Conditional ??CrossCallReturnLabel_20
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 15)
          CFI Block cfiCond145 Using cfiCommon0
          CFI (cfiCond145) Function usbsrGetDescriptor
          CFI (cfiCond145) Conditional ??CrossCallReturnLabel_21
          CFI (cfiCond145) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond145) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond145) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond145) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond145) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond145) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond145) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond145) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond145) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond145) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond145) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond145) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond145) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond145) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond145) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond145) CFA_SP SP+-2
          CFI (cfiCond145) CFA_XSP16 add(XSP16, 15)
          CFI Block cfiPicker146 Using cfiCommon1
          CFI (cfiPicker146) NoFunction
          CFI (cfiPicker146) Picker
        MOV     DPTR,#usbSetupData
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x80
        LCALL   ?Subroutine25 & 0xFFFF
??CrossCallReturnLabel_35:
        RET
          CFI (cfiCond144) CFA_SP SP+0
          CFI (cfiCond145) CFA_SP SP+0
          CFI (cfiPicker146) CFA_SP SP+0
          CFI EndBlock cfiCond144
          CFI EndBlock cfiCond145
          CFI EndBlock cfiPicker146

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine25:
          CFI Block cfiCond147 Using cfiCommon0
          CFI Function usbsrGetDescriptor
          CFI Conditional ??CrossCallReturnLabel_34
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 15)
          CFI Block cfiCond148 Using cfiCommon0
          CFI (cfiCond148) Function usbsrGetDescriptor
          CFI (cfiCond148) Conditional ??CrossCallReturnLabel_35, ??CrossCallReturnLabel_20
          CFI (cfiCond148) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond148) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond148) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond148) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond148) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond148) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond148) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond148) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond148) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond148) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond148) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond148) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond148) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond148) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond148) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond148) CFA_SP SP+-4
          CFI (cfiCond148) CFA_XSP16 add(XSP16, 15)
          CFI Block cfiCond149 Using cfiCommon0
          CFI (cfiCond149) Function usbsrGetDescriptor
          CFI (cfiCond149) Conditional ??CrossCallReturnLabel_35, ??CrossCallReturnLabel_21
          CFI (cfiCond149) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond149) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond149) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond149) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond149) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond149) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond149) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond149) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond149) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond149) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond149) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond149) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond149) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond149) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond149) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond149) CFA_SP SP+-4
          CFI (cfiCond149) CFA_XSP16 add(XSP16, 15)
          CFI Block cfiPicker150 Using cfiCommon1
          CFI (cfiPicker150) NoFunction
          CFI (cfiPicker150) Picker
        MOVX    @DPTR,A
        MOV     DPTR,#usbSetupData
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        RET
          CFI (cfiCond147) CFA_SP SP+0
          CFI (cfiCond148) CFA_SP SP+-2
          CFI (cfiCond149) CFA_SP SP+-2
          CFI (cfiPicker150) CFA_SP SP+0
          CFI EndBlock cfiCond147
          CFI EndBlock cfiCond148
          CFI EndBlock cfiCond149
          CFI EndBlock cfiPicker150

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine12:
          CFI Block cfiCond151 Using cfiCommon0
          CFI Function ??aesInitSig
          CFI Conditional ??CrossCallReturnLabel_9
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 48)
          CFI Block cfiCond152 Using cfiCommon0
          CFI (cfiCond152) Function usbsrSetAddress
          CFI (cfiCond152) Conditional ??CrossCallReturnLabel_10
          CFI (cfiCond152) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond152) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond152) CFA_SP SP+-7
          CFI Block cfiCond153 Using cfiCommon0
          CFI (cfiCond153) Function usbsrGetDescriptor
          CFI (cfiCond153) Conditional ??CrossCallReturnLabel_11
          CFI (cfiCond153) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond153) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond153) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond153) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond153) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond153) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond153) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond153) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond153) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond153) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond153) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond153) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond153) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond153) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond153) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond153) CFA_SP SP+-2
          CFI (cfiCond153) CFA_XSP16 add(XSP16, 15)
          CFI Block cfiCond154 Using cfiCommon0
          CFI (cfiCond154) Function ??ConfigureEndpoints
          CFI (cfiCond154) Conditional ??CrossCallReturnLabel_12
          CFI (cfiCond154) R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond154) VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond154) V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond154) V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond154) V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond154) V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond154) V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond154) V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond154) V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond154) V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond154) V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond154) V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond154) V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond154) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond154) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond154) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond154) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond154) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond154) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond154) CFA_SP SP+-2
          CFI (cfiCond154) CFA_XSP16 add(XSP16, 19)
          CFI Block cfiPicker155 Using cfiCommon1
          CFI (cfiPicker155) NoFunction
          CFI (cfiPicker155) Picker
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_69:
        MOV     A,R0
        RET
          CFI (cfiCond151) CFA_SP SP+0
          CFI (cfiCond152) CFA_SP SP+-5
          CFI (cfiCond153) CFA_SP SP+0
          CFI (cfiCond154) CFA_SP SP+0
          CFI (cfiPicker155) CFA_SP SP+0
          CFI EndBlock cfiCond151
          CFI EndBlock cfiCond152
          CFI EndBlock cfiCond153
          CFI EndBlock cfiCond154
          CFI EndBlock cfiPicker155
//  402 
//  403 
//  404 
//  405 /** \brief Internally used function that configures all endpoints for the specified interface
//  406  *
//  407  * The new endpoint setup overwrites the old, without any warning. Unused endpoints keep their current
//  408  * setup. The user is responsible for ensuring that no endpoint buffers overwrite each other, and that
//  409  * interfaces do not cause conflicts. The pUsbDblbufLutInfo table must contain an entry for each
//  410  * interface descriptor to define endpoint double-buffering.
//  411  *
//  412  * \param[in]       *pInterface
//  413  *     A pointer to the interface descriptor
//  414  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  415 static void ConfigureEndpoints(USB_INTERFACE_DESCRIPTOR __code *pInterface)
??ConfigureEndpoints:
          CFI Block cfiBlock156 Using cfiCommon0
          CFI Function ??ConfigureEndpoints
        CODE
//  416 {
        FUNCALL ??ConfigureEndpoints, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 19, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 19, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        REQUIRE ?V10
        MOV     A,#-0x13
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 19)
        ; Saved register size: 19
        ; Auto size: 0
//  417    uint8 n;
//  418    uint16 maxpRegValue;
//  419    uint8 csRegValue;
//  420    uint8 endpoint;
//  421    USB_ENDPOINT_DESCRIPTOR __code *pEndpoint;
//  422    DBLBUF_LUT_INFO __code *pUsbDblbufLutInfo;
//  423 
//  424    // Locate the double buffer settings
//  425    if (pInterface->bNumEndpoints) {
        MOV     A,R2
        ADD     A,#0x4
        MOV     ?V0,A
        CLR     A
        ADDC    A,R3
        MOV     ?V1,A
        MOV     DPL,?V0
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        JZ      ??ConfigureEndpoints_1
//  426        pUsbDblbufLutInfo = (DBLBUF_LUT_INFO __code*) usbDescriptorMarker.pUsbDblbufLut;
        MOV     DPTR,#usbDescriptorMarker + 8
        LCALL   ?Subroutine12 & 0xFFFF
??CrossCallReturnLabel_12:
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
        SJMP    ??ConfigureEndpoints_2
//  427        while (pUsbDblbufLutInfo->pInterface != pInterface) {
//  428           pUsbDblbufLutInfo++;
??ConfigureEndpoints_3:
        MOV     A,R6
        ADD     A,#0x4
        MOV     R6,A
        JNC     ??ConfigureEndpoints_2
        INC     R7
//  429        }
??ConfigureEndpoints_2:
        MOV     DPL,R6
        MOV     DPH,R7
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     A,R2
        XRL     A,R0
        JNZ     ??ConfigureEndpoints_4
        MOV     A,R3
        XRL     A,R1
??ConfigureEndpoints_4:
        JNZ     ??ConfigureEndpoints_3
//  430    }
//  431 
//  432    // For each endpoint in this interface
//  433    for (n = 0; n < pInterface->bNumEndpoints; n++) {
??ConfigureEndpoints_1:
        MOV     ?V3,#0x0
        SJMP    ??ConfigureEndpoints_5
//  434       if (pEndpoint = usbdpFindNext(DESC_TYPE_ENDPOINT, 0)) {
//  435 
//  436          // Get the endpoint index
//  437          endpoint = pEndpoint->bEndpointAddress & 0x0F;
//  438          USBFW_SELECT_ENDPOINT(endpoint);
//  439 
//  440          csRegValue = 0x00;
//  441          maxpRegValue = (pEndpoint->wMaxPacketSize + 7) >> 3;
//  442 
//  443          // For IN endpoints...
//  444          if (pEndpoint->bEndpointAddress & 0x80) {
//  445 
//  446             // Clear data toggle, and flush twice (due to double buffering)
//  447             USBCSIL = USBCSIL_CLR_DATA_TOG | USBCSIL_FLUSH_PACKET;
//  448             USBCSIL = USBCSIL_FLUSH_PACKET;
//  449 
//  450             // USBCSIH
//  451             if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSIH_ISO;  // ISO flag
//  452             if (pUsbDblbufLutInfo->inMask & (1 << endpoint)) csRegValue |= USBCSIH_IN_DBL_BUF;          // Double buffering
//  453             USBCSIH = csRegValue;
//  454 
//  455             // Max transfer size
//  456             USBMAXI = maxpRegValue;
//  457 
//  458             // Endpoint status
//  459             usbfwData.pEpInStatus[endpoint - 1] = EP_IDLE;
//  460 
//  461          // For OUT endpoints...
//  462          } else {
//  463 
//  464             // Clear data toggle, and flush twice (due to double buffering)
//  465             USBCSOL = USBCSOL_CLR_DATA_TOG | USBCSOL_FLUSH_PACKET;
??ConfigureEndpoints_6:
        MOV     DPTR,#0x6214
        MOV     A,#-0x70
        MOVX    @DPTR,A
//  466             USBCSOL = USBCSOL_FLUSH_PACKET;
        MOV     A,#0x10
        LCALL   ?Subroutine19 & 0xFFFF
//  467 
//  468             // USBCSOH
//  469             if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSOH_ISO;  // ISO flag
??CrossCallReturnLabel_24:
        JNZ     ??ConfigureEndpoints_7
        MOV     ?V2,#0x40
//  470             if (pUsbDblbufLutInfo->outMask & (1 << endpoint)) csRegValue |= USBCSOH_OUT_DBL_BUF;        // Double buffering
??ConfigureEndpoints_7:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,?V6
        JZ      ??ConfigureEndpoints_8
        MOV     A,?V2
        SETB    0xE0 /* A   */.0
        MOV     ?V2,A
//  471             USBCSOH = csRegValue;
??ConfigureEndpoints_8:
        MOV     A,?V2
        MOV     DPTR,#0x6215
        MOVX    @DPTR,A
//  472 
//  473             // Max transfer size
//  474             USBMAXO = maxpRegValue;
        MOV     A,R2
        MOV     DPTR,#0x6213
        MOVX    @DPTR,A
//  475 
//  476             // Endpoint status
//  477             usbfwData.pEpOutStatus[endpoint - 1] = EP_IDLE;
        MOV     A,R4
        ADD     A,#0xc
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
??ConfigureEndpoints_9:
        CLR     A
        MOVX    @DPTR,A
//  478          }
//  479          USBFW_SELECT_ENDPOINT(0);
        MOV     DPTR,#0x620e
        MOVX    @DPTR,A
??ConfigureEndpoints_10:
        INC     ?V3
??ConfigureEndpoints_5:
        MOV     DPL,?V0
        MOV     DPH,?V1
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,?V3
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??ConfigureEndpoints_11 & 0xFFFF
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x5
        LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
        MOV     ?V4,R2
        MOV     ?V5,R3
        MOV     A,R2
        ORL     A,?V5
        JZ      ??ConfigureEndpoints_10
        MOV     A,R2
        ADD     A,#0x2
        MOV     R0,A
        CLR     A
        ADDC    A,?V5
        MOV     R1,A
        MOV     ?V8,R0
        MOV     ?V9,R1
        MOV     DPL,R0
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,#0xf
        MOV     ?V10,A
        MOV     DPTR,#0x620e
        MOVX    @DPTR,A
        MOV     ?V2,#0x0
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ADD     A,#0x7
        MOV     ?V6,A
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ADDC    A,#0x0
        MOV     ?V7,A
        MOV     A,#0x3
        MOV     R0,#?V6
        LCALL   ?US_SHR
        MOV     R2,?V6
        MOV     R0,?V10
        MOV     A,#usbfwData & 0xff
        ADD     A,R0
        MOV     R0,A
        CLR     A
        ADDC    A,#(usbfwData >> 8) & 0xff
        MOV     R1,A
        MOV     A,R0
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     ?V6,#0x1
        MOV     ?V7,#0x0
        MOV     A,?V10
        MOV     R0,#?V6
        LCALL   ?S_SHL
        MOV     A,?V6
        MOV     ?V6,A
        MOV     A,?V4
        ADD     A,#0x3
        MOV     R0,A
        CLR     A
        ADDC    A,?V5
        MOV     R1,A
        MOV     DPL,?V8
        MOV     DPH,?V9
        CLR     A
        MOVC    A,@A+DPTR
        MOV     C,0xE0 /* A   */.7
        JC      $+5
        LJMP    ??ConfigureEndpoints_6 & 0xFFFF
        MOV     DPTR,#0x6211
        MOV     A,#0x48
        MOVX    @DPTR,A
        MOV     A,#0x8
        LCALL   ?Subroutine19 & 0xFFFF
??CrossCallReturnLabel_25:
        JNZ     ??ConfigureEndpoints_12
        MOV     ?V2,#0x40
??ConfigureEndpoints_12:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,?V6
        JZ      ??ConfigureEndpoints_13
        MOV     A,?V2
        SETB    0xE0 /* A   */.0
        MOV     ?V2,A
??ConfigureEndpoints_13:
        MOV     A,?V2
        MOV     DPTR,#0x6212
        MOVX    @DPTR,A
        MOV     A,R2
        MOV     DPTR,#0x6210
        MOVX    @DPTR,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LJMP    ??ConfigureEndpoints_9 & 0xFFFF
//  480       }
//  481    }
//  482 } // ConfigureEndpoints
??ConfigureEndpoints_11:
        MOV     R7,#0xb
        LJMP    ?BANKED_LEAVE_XDATA
          CFI R6 SameValue
          CFI VB SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI R7 SameValue
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI CFA_SP SP+-3
          CFI CFA_XSP16 XSP16+0
          CFI EndBlock cfiBlock156

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine19:
          CFI Block cfiCond157 Using cfiCommon0
          CFI Function ??ConfigureEndpoints
          CFI Conditional ??CrossCallReturnLabel_24
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 19)
          CFI Block cfiCond158 Using cfiCommon0
          CFI (cfiCond158) Function ??ConfigureEndpoints
          CFI (cfiCond158) Conditional ??CrossCallReturnLabel_25
          CFI (cfiCond158) R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond158) VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond158) V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond158) V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond158) V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond158) V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond158) V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond158) V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond158) V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond158) V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond158) V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond158) V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond158) V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond158) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond158) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond158) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond158) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond158) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond158) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond158) CFA_SP SP+-2
          CFI (cfiCond158) CFA_XSP16 add(XSP16, 19)
          CFI Block cfiPicker159 Using cfiCommon1
          CFI (cfiPicker159) NoFunction
          CFI (cfiPicker159) Picker
        MOVX    @DPTR,A
        MOV     DPL,R0
        MOV     DPH,R1
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,#0x3
        XRL     A,#0x1
        RET
          CFI (cfiCond157) CFA_SP SP+0
          CFI (cfiCond158) CFA_SP SP+0
          CFI (cfiPicker159) CFA_SP SP+0
          CFI EndBlock cfiCond157
          CFI EndBlock cfiCond158
          CFI EndBlock cfiPicker159
//  483 
//  484 
//  485 
//  486 
//  487 /** \brief Processes the \ref GET_CONFIGURATION request (returns the current device configuration value)
//  488  *
//  489  * If the returned value is 0, the device is not configured (not in the configured state)
//  490  *
//  491  * <b>Parameters</b>:
//  492  * - VALUE: Always 0
//  493  * - INDEX: Always 0
//  494  * - LENGTH: Always 1
//  495  *
//  496  * <b>Data (IN)</b>:
//  497  * The non-zero \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue of the currently selected
//  498  * configuration.
//  499  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  500 void usbsrGetConfiguration(void)
usbsrGetConfiguration:
          CFI Block cfiBlock160 Using cfiCommon0
          CFI Function usbsrGetConfiguration
        CODE
//  501 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  502 
//  503    // Sanity check
//  504    if (usbSetupHeader.value || usbSetupHeader.index || (usbSetupHeader.length != 1)) {
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_65:
        JNZ     ??usbsrGetConfiguration_0
        INC     DPTR
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_60:
        JNZ     ??usbsrGetConfiguration_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??usbsrGetConfiguration_1
        INC     DPTR
        MOVX    A,@DPTR
??usbsrGetConfiguration_1:
        JZ      ??usbsrGetConfiguration_2
//  505       usbfwData.ep0Status = EP_STALL;
??usbsrGetConfiguration_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??CrossCallReturnLabel_22
//  506 
//  507    // Return the current configuration
//  508    } else {
//  509       usbSetupData.pBuffer = &usbfwData.configurationValue;
??usbsrGetConfiguration_2:
        MOV     DPTR,#usbSetupData
        MOV     A,#(usbfwData + 1) & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((usbfwData + 1) >> 8) & 0xff
        LCALL   ?Subroutine18 & 0xFFFF
//  510       usbSetupData.bytesLeft = 1;
//  511       usbfwData.ep0Status = EP_TX;
//  512    }
??CrossCallReturnLabel_22:
        LJMP    ??Subroutine30_0 & 0xFFFF
//  513 
//  514 } // usbsrGetConfiguration
          CFI EndBlock cfiBlock160

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine7:
          CFI Block cfiCond161 Using cfiCommon0
          CFI Function usbsrGetStatus
          CFI Conditional ??CrossCallReturnLabel_64
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond162 Using cfiCommon0
          CFI (cfiCond162) Function usbsrGetConfiguration
          CFI (cfiCond162) Conditional ??CrossCallReturnLabel_65
          CFI (cfiCond162) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond162) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond162) CFA_SP SP+-7
          CFI Block cfiCond163 Using cfiCommon0
          CFI (cfiCond163) Function usbsrGetInterface
          CFI (cfiCond163) Conditional ??CrossCallReturnLabel_66
          CFI (cfiCond163) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond163) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond163) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond163) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond163) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond163) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond163) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond163) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond163) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond163) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond163) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond163) CFA_SP SP+-2
          CFI (cfiCond163) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker164 Using cfiCommon1
          CFI (cfiPicker164) NoFunction
          CFI (cfiPicker164) Picker
        MOV     DPTR,#usbSetupHeader + 2
          CFI EndBlock cfiCond161
          CFI EndBlock cfiCond162
          CFI EndBlock cfiCond163
          CFI EndBlock cfiPicker164
        REQUIRE ??Subroutine37_0
        ; // Fall through to label ??Subroutine37_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine37_0:
          CFI Block cfiCond165 Using cfiCommon0
          CFI Function ublExec
          CFI Conditional ??CrossCallReturnLabel_52
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 24)
          CFI Block cfiCond166 Using cfiCommon0
          CFI (cfiCond166) Function ublExec
          CFI (cfiCond166) Conditional ??CrossCallReturnLabel_53
          CFI (cfiCond166) R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI (cfiCond166) VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond166) V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond166) V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond166) V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond166) V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond166) V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond166) V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond166) V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond166) V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond166) V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond166) V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond166) V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond166) V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond166) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond166) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond166) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond166) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond166) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond166) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond166) CFA_SP SP+-2
          CFI (cfiCond166) CFA_XSP16 add(XSP16, 24)
          CFI Block cfiCond167 Using cfiCommon0
          CFI (cfiCond167) Function ublInit
          CFI (cfiCond167) Conditional ??CrossCallReturnLabel_54
          CFI (cfiCond167) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond167) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond167) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond167) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond167) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond167) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond167) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond167) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond167) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond167) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond167) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond167) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond167) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond167) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond167) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond167) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond167) CFA_SP SP+-2
          CFI (cfiCond167) CFA_XSP16 add(XSP16, 52)
          CFI Block cfiCond168 Using cfiCommon0
          CFI (cfiCond168) Function usbfwSetupHandler
          CFI (cfiCond168) Conditional ??CrossCallReturnLabel_55
          CFI (cfiCond168) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond168) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond168) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond168) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond168) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond168) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond168) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond168) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond168) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond168) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond168) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond168) CFA_SP SP+-2
          CFI (cfiCond168) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond169 Using cfiCommon0
          CFI (cfiCond169) Function ??ChangeFeature
          CFI (cfiCond169) Conditional ??CrossCallReturnLabel_56
          CFI (cfiCond169) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond169) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond169) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond169) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond169) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond169) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond169) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond169) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond169) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond169) CFA_SP SP+-2
          CFI (cfiCond169) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond170 Using cfiCommon0
          CFI (cfiCond170) Function ??ChangeFeature
          CFI (cfiCond170) Conditional ??CrossCallReturnLabel_57
          CFI (cfiCond170) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond170) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond170) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond170) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond170) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond170) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond170) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond170) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond170) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond170) CFA_SP SP+-2
          CFI (cfiCond170) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond171 Using cfiCommon0
          CFI (cfiCond171) Function usbsrSetAddress
          CFI (cfiCond171) Conditional ??CrossCallReturnLabel_58
          CFI (cfiCond171) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond171) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond171) CFA_SP SP+-7
          CFI Block cfiCond172 Using cfiCommon0
          CFI (cfiCond172) Function usbsrSetAddress
          CFI (cfiCond172) Conditional ??CrossCallReturnLabel_59
          CFI (cfiCond172) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond172) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond172) CFA_SP SP+-7
          CFI Block cfiCond173 Using cfiCommon0
          CFI (cfiCond173) Function usbsrGetConfiguration
          CFI (cfiCond173) Conditional ??CrossCallReturnLabel_60
          CFI (cfiCond173) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond173) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond173) CFA_SP SP+-7
          CFI Block cfiCond174 Using cfiCommon0
          CFI (cfiCond174) Function usbsrSetConfiguration
          CFI (cfiCond174) Conditional ??CrossCallReturnLabel_61
          CFI (cfiCond174) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond174) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond174) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond174) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond174) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond174) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond174) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond174) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond174) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond174) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond174) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond174) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond174) CFA_SP SP+-2
          CFI (cfiCond174) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond175 Using cfiCommon0
          CFI (cfiCond175) Function usbsrSetConfiguration
          CFI (cfiCond175) Conditional ??CrossCallReturnLabel_62
          CFI (cfiCond175) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond175) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond175) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond175) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond175) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond175) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond175) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond175) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond175) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond175) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond175) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond175) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond175) CFA_SP SP+-2
          CFI (cfiCond175) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond176 Using cfiCommon0
          CFI (cfiCond176) Function usbsrSetInterface
          CFI (cfiCond176) Conditional ??CrossCallReturnLabel_63
          CFI (cfiCond176) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond176) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond176) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond176) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond176) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond176) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond176) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond176) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond176) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond176) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond176) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond176) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond176) CFA_SP SP+-2
          CFI (cfiCond176) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond177 Using cfiCommon0
          CFI (cfiCond177) Function usbsrGetStatus
          CFI (cfiCond177) Conditional ??CrossCallReturnLabel_64
          CFI (cfiCond177) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond177) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond177) CFA_SP SP+-7
          CFI Block cfiCond178 Using cfiCommon0
          CFI (cfiCond178) Function usbsrGetConfiguration
          CFI (cfiCond178) Conditional ??CrossCallReturnLabel_65
          CFI (cfiCond178) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond178) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond178) CFA_SP SP+-7
          CFI Block cfiCond179 Using cfiCommon0
          CFI (cfiCond179) Function usbsrGetInterface
          CFI (cfiCond179) Conditional ??CrossCallReturnLabel_66
          CFI (cfiCond179) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond179) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond179) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond179) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond179) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond179) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond179) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond179) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond179) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond179) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond179) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond179) CFA_SP SP+-2
          CFI (cfiCond179) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker180 Using cfiCommon1
          CFI (cfiPicker180) NoFunction
          CFI (cfiPicker180) Picker
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_71:
        MOV     A,R0
        ORL     A,R1
        RET
          CFI (cfiCond165) CFA_SP SP+0
          CFI (cfiCond166) CFA_SP SP+0
          CFI (cfiCond167) CFA_SP SP+0
          CFI (cfiCond168) CFA_SP SP+0
          CFI (cfiCond169) CFA_SP SP+0
          CFI (cfiCond170) CFA_SP SP+0
          CFI (cfiCond171) CFA_SP SP+-5
          CFI (cfiCond172) CFA_SP SP+-5
          CFI (cfiCond173) CFA_SP SP+-5
          CFI (cfiCond174) CFA_SP SP+0
          CFI (cfiCond175) CFA_SP SP+0
          CFI (cfiCond176) CFA_SP SP+0
          CFI (cfiCond177) CFA_SP SP+-5
          CFI (cfiCond178) CFA_SP SP+-5
          CFI (cfiCond179) CFA_SP SP+0
          CFI (cfiPicker180) CFA_SP SP+0
          CFI EndBlock cfiCond165
          CFI EndBlock cfiCond166
          CFI EndBlock cfiCond167
          CFI EndBlock cfiCond168
          CFI EndBlock cfiCond169
          CFI EndBlock cfiCond170
          CFI EndBlock cfiCond171
          CFI EndBlock cfiCond172
          CFI EndBlock cfiCond173
          CFI EndBlock cfiCond174
          CFI EndBlock cfiCond175
          CFI EndBlock cfiCond176
          CFI EndBlock cfiCond177
          CFI EndBlock cfiCond178
          CFI EndBlock cfiCond179
          CFI EndBlock cfiPicker180
//  515 
//  516 
//  517 
//  518 
//  519 /** \brief Processes the \ref SET_CONFIGURATION request (sets the device configuration)
//  520  *
//  521  * The configuration value must either be 0, in which case the device enters the address state, or it
//  522  * must match a configuration value from one of the USB configuration descriptors. If there is a match,
//  523  * the device enters the configured state.
//  524  *
//  525  * This request resets all interfaces to alternate setting 0, and uses the \c ConfigureEndpoints()
//  526  * function to automatically setup all endpoint registers.
//  527  *
//  528  * <b>Parameters</b>:
//  529  * - VALUE: The configuration value (0-255)
//  530  * - INDEX: Always 0
//  531  * - LENGTH: Always 0
//  532  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  533 void usbsrSetConfiguration(void)
usbsrSetConfiguration:
          CFI Block cfiBlock181 Using cfiCommon0
          CFI Function usbsrSetConfiguration
        CODE
//  534 {
        FUNCALL usbsrSetConfiguration, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, ??ConfigureEndpoints
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbfwSetAllEpStatus
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
//  535    uint8 n;
//  536    USB_CONFIGURATION_DESCRIPTOR __code *pConfiguration;
//  537    USB_INTERFACE_DESCRIPTOR __code *pInterface;
//  538 
//  539    // Sanity check
//  540    if ((usbfwData.usbState == DEV_DEFAULT) || usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value)) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x2
        JZ      ??usbsrSetConfiguration_0
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_61:
        JNZ     ??usbsrSetConfiguration_0
        INC     DPTR
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_62:
        JNZ     ??usbsrSetConfiguration_0
        MOV     DPTR,#usbSetupHeader + 3
        MOVX    A,@DPTR
        JZ      ??usbsrSetConfiguration_1
//  541       usbfwData.ep0Status = EP_STALL;
??usbsrSetConfiguration_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
        SJMP    ??usbsrSetConfiguration_2
//  542 
//  543    // Default endpoint setup
//  544    } else {
//  545       usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGING, 0);
??usbsrSetConfiguration_1:
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     R2,#0x0
        MOV     R1,#0x1
        LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
//  546 
//  547       // Configure relevant endpoints
//  548       if (LO_UINT16(usbSetupHeader.value)) {
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R6,A
        JZ      ??usbsrSetConfiguration_3
//  549 
//  550          // Find the correct configuration descriptor...
//  551          pConfiguration = usbdpGetConfigurationDesc(LO_UINT16(usbSetupHeader.value), 0);
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     R2,#0x0
        MOV     R1,A
        LCALL   `??usbdpGetConfigurationDesc::?relay`; Banked call to: usbdpGetConfigurationDesc
        MOV     ?V0,R2
        MOV     ?V1,R3
//  552 
//  553          // If it exists...
//  554          if (pConfiguration) {
        MOV     A,R2
        ORL     A,?V1
        JZ      ??usbsrSetConfiguration_4
//  555             usbfwData.usbState = DEV_CONFIGURED;
        MOV     DPTR,#usbfwData
        MOV     A,#0x4
        MOVX    @DPTR,A
//  556             usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
        MOV     A,R6
        INC     DPTR
        MOVX    @DPTR,A
//  557 
//  558             // For each interface...
//  559             for (n = 0; n < pConfiguration->bNumInterfaces; n++) {
        MOV     R6,#0x0
??usbsrSetConfiguration_5:
        MOV     DPL,?V0
        MOV     DPH,?V1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,R6
        CLR     C
        SUBB    A,R0
        JNC     ??usbsrSetConfiguration_6
//  560                usbfwData.pAlternateSetting[n] = 0x00;
        MOV     A,R6
        MOV     R0,A
        MOV     A,#(usbfwData + 2) & 0xff
        ADD     A,R0
        MOV     DPL,A
        CLR     A
        ADDC    A,#((usbfwData + 2) >> 8) & 0xff
        MOV     DPH,A
        CLR     A
        MOVX    @DPTR,A
//  561 
//  562                // Look only for alternate setting 0
//  563                do {
//  564                   pInterface = usbdpFindNext(DESC_TYPE_INTERFACE, 0);
??usbsrSetConfiguration_7:
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x4
        LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
//  565                } while (pInterface->bAlternateSetting != usbfwData.pAlternateSetting[n]);
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        JNZ     ??usbsrSetConfiguration_7
//  566 
//  567                // Configure all endpoints in this interface
//  568                ConfigureEndpoints(pInterface);
        ; Setup parameters for call to function ConfigureEndpoints
        LCALL   `??ConfigureEndpoints::?relay`; Banked call to: ConfigureEndpoints
//  569             }
        INC     R6
        SJMP    ??usbsrSetConfiguration_5
//  570 
//  571          // If not, then stall the endpoint
//  572          } else {
//  573             usbfwData.ep0Status = EP_STALL;
??usbsrSetConfiguration_4:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
        SJMP    ??usbsrSetConfiguration_6
//  574          }
//  575 
//  576       // Unconfigure endpoints
//  577       } else {
//  578          usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
??usbsrSetConfiguration_3:
        MOV     DPTR,#usbfwData + 1
        MOVX    @DPTR,A
//  579          usbfwData.usbState = DEV_ADDRESS;
        MOV     DPTR,#usbfwData
        MOV     A,#0x3
        MOVX    @DPTR,A
//  580          usbfwSetAllEpStatus(EP_HALT);
        ; Setup parameters for call to function usbfwSetAllEpStatus
        MOV     R1,A
        LCALL   `??usbfwSetAllEpStatus::?relay`; Banked call to: usbfwSetAllEpStatus
//  581       }
//  582       usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGED, 0);
??usbsrSetConfiguration_6:
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     R2,#0x0
        MOV     R1,#0x2
        LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
//  583    }
//  584 
//  585 } // usbsrSetConfiguration
??usbsrSetConfiguration_2:
        LJMP    ??Subroutine32_0 & 0xFFFF
          CFI EndBlock cfiBlock181
//  586 
//  587 
//  588 
//  589 
//  590 /** \brief Processes the \ref GET_INTERFACE request (returns the selected alternate setting for the
//  591  * specified interface)
//  592  *
//  593  * Some USB devices have configurations with mutually exclusive interface settings. This request allows
//  594  * the host to determine the currently selected alternate setting.
//  595  *
//  596  * <b>Parameters</b>:
//  597  * - VALUE: Always 0
//  598  * - INDEX: Interface number
//  599  * - LENGTH: Always 1
//  600  *
//  601  * <b>Data (IN)</b>:
//  602  * The alternate setting for the selected interface
//  603  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  604 void usbsrGetInterface(void)
usbsrGetInterface:
          CFI Block cfiBlock182 Using cfiCommon0
          CFI Function usbsrGetInterface
        CODE
//  605 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
//  606 
//  607    // Sanity check
//  608    if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_IN_INTERFACE) || usbSetupHeader.value || (usbSetupHeader.length != 1)) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrGetInterface_0
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        XRL     A,#0x81
        JNZ     ??usbsrGetInterface_0
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_66:
        JNZ     ??usbsrGetInterface_0
        MOV     DPTR,#usbSetupHeader + 6
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??usbsrGetInterface_1
        INC     DPTR
        MOVX    A,@DPTR
??usbsrGetInterface_1:
        JZ      ??usbsrGetInterface_2
//  609       usbfwData.ep0Status = EP_STALL;
??usbsrGetInterface_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??CrossCallReturnLabel_23
//  610 
//  611    // Return the current alternate setting
//  612    } else {
//  613       usbSetupData.pBuffer = &usbfwData.pAlternateSetting[usbSetupHeader.index];
??usbsrGetInterface_2:
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ADD     A,#(usbfwData + 2) & 0xff
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#((usbfwData + 2) >> 8) & 0xff
        MOV     ?V1,A
        MOV     DPTR,#usbSetupData
        MOV     A,?V0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V1
        LCALL   ?Subroutine18 & 0xFFFF
//  614       usbSetupData.bytesLeft = 1;
//  615       usbfwData.ep0Status = EP_TX;
//  616    }
??CrossCallReturnLabel_23:
        LJMP    ?Subroutine0 & 0xFFFF
//  617 
//  618 } // usbsrGetInterface
          CFI EndBlock cfiBlock182

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine18:
          CFI Block cfiCond183 Using cfiCommon0
          CFI Function usbsrGetConfiguration
          CFI Conditional ??CrossCallReturnLabel_22
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond184 Using cfiCommon0
          CFI (cfiCond184) Function usbsrGetInterface
          CFI (cfiCond184) Conditional ??CrossCallReturnLabel_23
          CFI (cfiCond184) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond184) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond184) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond184) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond184) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond184) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond184) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond184) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond184) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond184) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond184) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond184) CFA_SP SP+-2
          CFI (cfiCond184) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker185 Using cfiCommon1
          CFI (cfiPicker185) NoFunction
          CFI (cfiPicker185) Picker
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        INC     A
        LCALL   ?Subroutine26 & 0xFFFF
??CrossCallReturnLabel_37:
        RET
          CFI (cfiCond183) CFA_SP SP+-5
          CFI (cfiCond184) CFA_SP SP+0
          CFI (cfiPicker185) CFA_SP SP+0
          CFI EndBlock cfiCond183
          CFI EndBlock cfiCond184
          CFI EndBlock cfiPicker185

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine26:
          CFI Block cfiCond186 Using cfiCommon0
          CFI Function usbsrGetStatus
          CFI Conditional ??CrossCallReturnLabel_36
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond187 Using cfiCommon0
          CFI (cfiCond187) Function usbsrGetConfiguration
          CFI (cfiCond187) Conditional ??CrossCallReturnLabel_37, ??CrossCallReturnLabel_22
          CFI (cfiCond187) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond187) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond187) CFA_SP SP+-9
          CFI Block cfiCond188 Using cfiCommon0
          CFI (cfiCond188) Function usbsrGetInterface
          CFI (cfiCond188) Conditional ??CrossCallReturnLabel_37, ??CrossCallReturnLabel_23
          CFI (cfiCond188) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond188) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond188) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond188) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond188) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond188) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond188) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond188) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond188) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond188) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond188) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond188) CFA_SP SP+-4
          CFI (cfiCond188) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker189 Using cfiCommon1
          CFI (cfiPicker189) NoFunction
          CFI (cfiPicker189) Picker
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#usbfwData + 7
        INC     A
        RET
          CFI (cfiCond186) CFA_SP SP+-5
          CFI (cfiCond187) CFA_SP SP+-7
          CFI (cfiCond188) CFA_SP SP+-2
          CFI (cfiPicker189) CFA_SP SP+0
          CFI EndBlock cfiCond186
          CFI EndBlock cfiCond187
          CFI EndBlock cfiCond188
          CFI EndBlock cfiPicker189
//  619 
//  620 
//  621 
//  622 
//  623 /** \brief Processes the \ref SET_INTERFACE request (selects an alternate setting for the specified
//  624  * interface)
//  625  *
//  626  * Some USB devices have configurations with mutually exclusive interface settings. This request allows
//  627  * the host to select the desired alternate setting.
//  628  *
//  629  * This function uses the \c ConfigureEndpoints() to automatically setup the relevant endpoint
//  630  * registers.
//  631  *
//  632  * <b>Parameters</b>:
//  633  * - VALUE: Alternate setting
//  634  * - INDEX: Interface number
//  635  * - LENGTH: Always 0
//  636  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  637 void usbsrSetInterface(void)
usbsrSetInterface:
          CFI Block cfiBlock190 Using cfiCommon0
          CFI Function usbsrSetInterface
        CODE
//  638 {
        FUNCALL usbsrSetInterface, usbdpGetInterfaceDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetInterface, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetInterface, ??ConfigureEndpoints
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetInterface, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
//  639    USB_INTERFACE_DESCRIPTOR __code *pInterface;
//  640 
//  641    // Sanity check
//  642    if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_OUT_INTERFACE) || usbSetupHeader.length) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrSetInterface_0
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??usbsrSetInterface_0
        MOV     DPTR,#usbSetupHeader + 6
        LCALL   ??Subroutine37_0 & 0xFFFF
??CrossCallReturnLabel_63:
        JNZ     ??usbsrSetInterface_0
//  643       usbfwData.ep0Status = EP_STALL;
//  644 
//  645    // Verify that the desired alternate setting is available, and then make the switch
//  646    } else {
//  647       if (pInterface = usbdpGetInterfaceDesc(usbfwData.configurationValue, usbSetupHeader.index, usbSetupHeader.value)) {
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        MOV     R6,A
        ; Setup parameters for call to function usbdpGetInterfaceDesc
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R2,A
        MOV     DPTR,#usbfwData + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   `??usbdpGetInterfaceDesc::?relay`; Banked call to: usbdpGetInterfaceDesc
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     A,R2
        ORL     A,?V1
        JZ      ??usbsrSetInterface_0
//  648          usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGING, usbSetupHeader.index);
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     A,R6
        MOV     R2,A
        MOV     R1,#0x3
        LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
//  649          usbfwData.pAlternateSetting[usbSetupHeader.index] = usbSetupHeader.value;
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ADD     A,#(usbfwData + 2) & 0xff
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#((usbfwData + 2) >> 8) & 0xff
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  650 
//  651          // Configure all endpoints in this interface
//  652          ConfigureEndpoints(pInterface);
        ; Setup parameters for call to function ConfigureEndpoints
        MOV     R2,?V0
        MOV     R3,?V1
        LCALL   `??ConfigureEndpoints::?relay`; Banked call to: ConfigureEndpoints
//  653          usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGED, usbSetupHeader.index);
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R1,#0x4
        LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
        SJMP    ??usbsrSetInterface_1
//  654 
//  655       // This interface does not exist
//  656       } else {
//  657          usbfwData.ep0Status = EP_STALL;
??usbsrSetInterface_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
//  658       }
//  659    }
//  660 
//  661 } // usbsrSetInterface
??usbsrSetInterface_1:
        LJMP    ??Subroutine32_0 & 0xFFFF
          CFI EndBlock cfiBlock190
//  662 
//  663 //@}
//  664 
//  665 
// C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_suspend.c
//    1 /******************************************************************************
//    2 
//    3  @file  usb_suspend.c
//    4 
//    5  @brief USB library common functionality.
//    6 
//    7  Group: WCS, BTS
//    8  Target Device: CC2540, CC2541
//    9 
//   10  ******************************************************************************
//   11  
//   12  Copyright (c) 2008-2016, Texas Instruments Incorporated
//   13  All rights reserved.
//   14 
//   15  IMPORTANT: Your use of this Software is limited to those specific rights
//   16  granted under the terms of a software license agreement between the user
//   17  who downloaded the software, his/her employer (which must be your employer)
//   18  and Texas Instruments Incorporated (the "License"). You may not use this
//   19  Software unless you agree to abide by the terms of the License. The License
//   20  limits your use, and you acknowledge, that the Software may not be modified,
//   21  copied or distributed unless embedded on a Texas Instruments microcontroller
//   22  or used solely and exclusively in conjunction with a Texas Instruments radio
//   23  frequency transceiver, which is integrated into your product. Other than for
//   24  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   25  works of, modify, distribute, perform, display or sell this Software and/or
//   26  its documentation for any purpose.
//   27 
//   28  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   29  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   30  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   31  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   32  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   33  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   34  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   35  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   36  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   37  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   38  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   39 
//   40  Should you have any questions regarding your right to use this Software,
//   41  contact Texas Instruments Incorporated at www.TI.com.
//   42 
//   43  ******************************************************************************
//   44  Release Name: ble_sdk_1.4.2.2
//   45  Release Date: 2016-06-09 06:57:10
//   46  *****************************************************************************/
//   47 /// \addtogroup module_usb_suspend
//   48 /// @{
//   49 #include "usb_firmware_library_headers.h"
//   50 #include "hal_board.h"
//   51 #include "hal_mcu.h"
//   52 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//   53 __xdata VFPTR pFnSuspendEnterHook=  NULL;
pFnSuspendEnterHook:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//   54 __xdata VFPTR pFnSuspendExitHook=   NULL;
pFnSuspendExitHook:
        DS 2
        REQUIRE __INIT_XDATA_Z
//   55 
//   56 #if HAL_UART_USB_SUSPEND
//   57 extern void halEnterPowerMode(void);
//   58 
//   59 /** \brief Puts the chip into power mode 1 during USB suspend.
//   60  *
//   61  * This function must be called from main (i.e. not from interrupt context) upon the reception of a
//   62  * \ref USBIRQ_EVENT_SUSPEND event. To comply with the USB specification, this must happen within 10 ms
//   63  * after the event occurs. The chip will stay in power mode 1 until a USB resume or USB reset is detected
//   64  * on the USB bus, or remote wakeup is used. During this period, the MCU can only run code from
//   65  * interrupt context.
//   66  */
//   67 void usbsuspEnter(void)
//   68 {
//   69     if (pFnSuspendEnterHook!=NULL)
//   70         pFnSuspendEnterHook();
//   71 
//   72     HAL_USB_INT_CLEAR();
//   73     HAL_USB_INT_ENABLE();
//   74 
//   75     // Disable USB clock (PLL) before entering PM1
//   76     HAL_USB_PLL_DISABLE();
//   77 
//   78  //   HAL_LED_CLR_1();
//   79 
//   80     do {
//   81         // Enter PM1, in prescribed manner as explained in CC253x User's Guide
//   82         SLEEPCMD = 0x05;
//   83         halEnterPowerMode();
//   84     } while ( usbirqData.inSuspend );
//   85 
//   86     // .... we are now up and running again
//   87 
//   88     // First make sure that the crystal oscillator is stable
//   89     while (!CC2530_IS_XOSC_STABLE());
//   90 
//   91     // Restart the USB clock (PLL)
//   92     HAL_USB_ENABLE();
//   93 
//   94     if (pFnSuspendExitHook!=NULL)
//   95         pFnSuspendExitHook();
//   96 } // usbsuspEnter
//   97 #endif
//   98 
//   99 
//  100 
//  101 /** \brief Attempts USB remote wakeup.
//  102  *
//  103  * This function can be called from interrupt context while the USB device is suspend mode. If the device
//  104  * is privileged to do so (see \c usbfwData.remoteWakeup and the \ref USBSR_EVENT_REMOTE_WAKEUP_ENABLED
//  105  * and \ref USBSR_EVENT_REMOTE_WAKEUP_DISABLED events), remote wakeup will be performed. Note that this
//  106  * function will block for 10 ms while the resume signal is set on the bus. Note: This function can only
//  107  * be called when the 48 MHz XOSC is stable.
//  108  *
//  109  * \return
//  110  *     \c TRUE if the remote wakeup was performed (the privilege had been granted), otherwise \c FALSE
//  111  *     (the device is still in suspend mode).
//  112  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  113 uint8 usbsuspDoRemoteWakeup(void)
usbsuspDoRemoteWakeup:
          CFI Block cfiBlock191 Using cfiCommon0
          CFI Function usbsuspDoRemoteWakeup
        CODE
//  114 {
        FUNCALL usbsuspDoRemoteWakeup, halMcuWaitMs
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  115    extern void halMcuWaitMs(uint16 msec);
//  116    halIntState_t   intState;
//  117 
//  118    // Make sure that it's OK
//  119    if (!usbfwData.remoteWakeup) return FALSE;
        MOV     DPTR,#usbfwData + 18
        MOVX    A,@DPTR
        JNZ     ??usbsuspDoRemoteWakeup_0
        MOV     R1,#0x0
        SJMP    ??usbsuspDoRemoteWakeup_1
//  120 
//  121    HAL_ENTER_CRITICAL_SECTION(intState);
??usbsuspDoRemoteWakeup_0:
        MOV     R6,0xa8+0x0
        CLR     0xa8.7
//  122 
//  123    // Make sure that the suspend loop does not power down the chip again
//  124    usbirqData.inSuspend = FALSE;
        MOV     usbirqData + 2,#0x0
//  125 
//  126    // Perform remote wakeup by holding the USB resume signal for 10 ms
//  127    USBPOW |= USBPOW_RESUME;
        MOV     DPTR,#0x6201
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.2
        MOVX    @DPTR,A
//  128    halMcuWaitMs(10);
        ; Setup parameters for call to function halMcuWaitMs
        MOV     R2,#0xa
        MOV     R3,#0x0
        LCALL   `??halMcuWaitMs::?relay`; Banked call to: halMcuWaitMs
//  129    USBPOW &= ~USBPOW_RESUME;
        MOV     DPTR,#0x6201
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.2
        MOVX    @DPTR,A
//  130 
//  131    // Clear the interrupt flag
//  132    HAL_USB_INT_CLEAR();
        MOV     0x8b,#0x0
        CLR     0xe8.0
//  133 
//  134    HAL_EXIT_CRITICAL_SECTION(intState);
        MOV     A,R6
        MOV     C,0xE0 /* A   */.7
        CLR     A
        RLC     A
        MOV     R0,A
        MOV     A,R6
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
//  135 
//  136    return TRUE;
        MOV     R1,#0x1
??usbsuspDoRemoteWakeup_1:
        LJMP    ?Subroutine4 & 0xFFFF
          CFI EndBlock cfiBlock191
        REQUIRE _A_IEN0
        REQUIRE P2IFG
        REQUIRE _A_IRCON2
//  137 
//  138 } // usbsuspDoRemoteWakeup

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for i>`:
        DATA16
        DW 1

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for serialNumber>`:
        DATA8
        DB 0
        DB 3
        DB 95
        DB 0
        DB 95
        DB 0
        DB 48
        DB 0
        DB 88
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??HalFlashRead::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    HalFlashRead

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??HalFlashWrite::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    HalFlashWrite

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??HalFlashErase::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    HalFlashErase

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??ublAesAuth::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublAesAuth

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??ublAesCrypt::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublAesCrypt

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??ublCfg::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublCfg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??ublExec::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublExec

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??ublInit::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??ublJump::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublJump

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??ublMassErase::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublMassErase

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??aesLoadKey::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ??aesLoadKey

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??aesInitSig::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ??aesInitSig

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??gpioInit::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ??gpioInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??vddWait::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ??vddWait

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??main::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    main

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbdpInit::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbdpFindNext::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpFindNext

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbdpGetDeviceDesc::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpGetDeviceDesc

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbdpGetConfigurationDesc::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpGetConfigurationDesc

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbdpGetInterfaceDesc::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpGetInterfaceDesc

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbdpGetStringDesc::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpGetStringDesc

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbfwInit::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbfwResetHandler::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwResetHandler

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbfwSetupHandler::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwSetupHandler

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbfwSetAllEpStatus::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwSetAllEpStatus

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbfwReadFifo::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwReadFifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbfwWriteFifo::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwWriteFifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbirqInit::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbirqInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbirqHandler::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbirqHandler

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsrGetStatus::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrGetStatus

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??ChangeFeature::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ??ChangeFeature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsrClearFeature::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrClearFeature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsrSetFeature::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrSetFeature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsrSetAddress::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrSetAddress

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsrGetDescriptor::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrGetDescriptor

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??ConfigureEndpoints::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ??ConfigureEndpoints

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsrGetConfiguration::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrGetConfiguration

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsrSetConfiguration::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrSetConfiguration

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsrGetInterface::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrGetInterface

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsrSetInterface::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrSetInterface

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??usbsuspDoRemoteWakeup::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsuspDoRemoteWakeup

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0`:
        DB 1
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 1

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
`?<Constant {255, 255, 255, 255}>`:
        DATA8
        DB 255
        DB 255
        DB 255
        DB 255

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant {255, 255, 255, 255, 255, 255, 255,`:
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
`?<Constant {255, 255, 255, 255}>_1`:
        DATA8
        DB 255
        DB 255
        DB 255
        DB 255

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant {255, 255, 255, 255, 255, 255, 255,_1`:
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_28000:
        DD 163840

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3000:
        DD 12288

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_7d:
        DD 125

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_fffffff0:
        DD 4294967280

        END
//  139 
//  140 
//  141 
//  142 //@}
//  143 
// 
// 5 822 bytes in segment BANKED_CODE
//   246 bytes in segment BANK_RELAYS
//     7 bytes in segment DATA_Z
//   129 bytes in segment NEAR_CODE
//    29 bytes in segment SFR_AN
//    44 bytes in segment XDATA_I
//    44 bytes in segment XDATA_ID
// 2 167 bytes in segment XDATA_N
//   206 bytes in segment XDATA_ROM_C
//   300 bytes in segment XDATA_Z
// 
// 6 241 bytes of CODE  memory
//   190 bytes of CONST memory (+ 16 bytes shared)
//     7 bytes of DATA  memory (+ 29 bytes shared)
// 2 511 bytes of XDATA memory
//
//Errors: none
//Warnings: 2
