###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                21/Aug/2018  17:47:51
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\hal_flash.c
#    Command line       =  
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\hal_flash.c
#        -D HAL_SB_BOOT_CODE -D HAL_DONGLE_NANO -D UBL_BUILD -lC
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-Nano\List\
#        -lA
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-Nano\List\
#        --remarks -o
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-Nano\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\app\
#        -I
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal\
#        -I
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\
#        -I
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\class_msd\
#        -I
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\library\
#        -Ohz --require_prototypes --mfc
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_exec.c
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_main.c
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_descriptor_parser.c
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_framework.c
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_interrupt.c
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_standard_requests.c
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_suspend.c
#    List file          =  
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-Nano\List\hal_flash.lst
#    Object file        =  
#        C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-Nano\Obj\hal_flash.r51
#
###############################################################################

C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\hal_flash.c
      1          /******************************************************************************
      2          
      3           @file  hal_flash.c
      4          
      5           @brief This file contains the interface to the H/W Flash driver.
      6          
      7           Group: WCS, BTS
      8           Target Device: CC2540, CC2541
      9          
     10           ******************************************************************************
     11           
     12           Copyright (c) 2006-2016, Texas Instruments Incorporated
     13           All rights reserved.
     14          
     15           IMPORTANT: Your use of this Software is limited to those specific rights
     16           granted under the terms of a software license agreement between the user
     17           who downloaded the software, his/her employer (which must be your employer)
     18           and Texas Instruments Incorporated (the "License"). You may not use this
     19           Software unless you agree to abide by the terms of the License. The License
     20           limits your use, and you acknowledge, that the Software may not be modified,
     21           copied or distributed unless embedded on a Texas Instruments microcontroller
     22           or used solely and exclusively in conjunction with a Texas Instruments radio
     23           frequency transceiver, which is integrated into your product. Other than for
     24           the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25           works of, modify, distribute, perform, display or sell this Software and/or
     26           its documentation for any purpose.
     27          
     28           YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29           PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30           INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31           NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32           TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33           NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34           LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35           INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36           OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37           OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38           (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40           Should you have any questions regarding your right to use this Software,
     41           contact Texas Instruments Incorporated at www.TI.com.
     42          
     43           ******************************************************************************
     44           Release Name: ble_sdk_1.4.2.2
     45           Release Date: 2016-06-09 06:57:10
     46           *****************************************************************************/
     47          
     48          /* ------------------------------------------------------------------------------------------------
     49           *                                          Includes
     50           * ------------------------------------------------------------------------------------------------
     51           */
     52          
     53          #include "hal_board_cfg.h"

   \                                 In  segment SFR_AN, at 0x8b
   \   unsigned char volatile __sfr P2IFG
   \                     P2IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x96
   \   unsigned char volatile __sfr ST1
   \                     ST1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x97
   \   unsigned char volatile __sfr ST2
   \                     ST2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc7
   \   unsigned char volatile __sfr MEMCTR
   \                     MEMCTR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd4
   \   unsigned char volatile __sfr DMA0CFGL
   \                     DMA0CFGL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd5
   \   unsigned char volatile __sfr DMA0CFGH
   \                     DMA0CFGH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf6
   \   unsigned char volatile __sfr P1INP
   \                     P1INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     54          #include "hal_dma.h"
     55          #include "hal_flash.h"
     56          #include "hal_mcu.h"
     57          #include "hal_types.h"
     58          
     59          /**************************************************************************************************
     60           * @fn          HalFlashRead
     61           *
     62           * @brief       This function reads 'cnt' bytes from the internal flash.
     63           *
     64           * input parameters
     65           *
     66           * @param       pg - A valid flash page number.
     67           * @param       offset - A valid offset into the page.
     68           * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
     69           * @param       cnt - A valid number of bytes to read.
     70           *
     71           * output parameters
     72           *
     73           * None.
     74           *
     75           * @return      None.
     76           **************************************************************************************************
     77           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     78          void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
   \                     HalFlashRead:
     79          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
     80            // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
     81            uint8 *pData = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
     82                           ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
   \   000007   740F         MOV     A,#0xf
   \   000009   55..         ANL     A,?V2
   \   00000B   F5..         MOV     ?V0,A
   \   00000D   75..00       MOV     ?V1,#0x0
   \   000010   740B         MOV     A,#0xb
   \   000012   78..         MOV     R0,#?V0
   \   000014   12....       LCALL   ?S_SHL
   \   000017   EA           MOV     A,R2
   \   000018   2400         ADD     A,#0x0
   \   00001A   F8           MOV     R0,A
   \   00001B   EB           MOV     A,R3
   \   00001C   3480         ADDC    A,#-0x80
   \   00001E   F9           MOV     R1,A
   \   00001F   E8           MOV     A,R0
   \   000020   2400         ADD     A,#0x0
   \   000022   E9           MOV     A,R1
   \   000023   35..         ADDC    A,?V1
   \   000025   F9           MOV     R1,A
     83            uint8 memctr = MEMCTR;  // Save to restore.
   \   000026   85C7..       MOV     ?V1,0xc7+0x0
     84          
     85          #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
     86            halIntState_t is;
     87          #endif
     88          
     89            pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
     90          
     91          #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
     92            HAL_ENTER_CRITICAL_SECTION(is);
   \   000029   A2AF         MOV     C,0xa8.7
   \   00002B   E4           CLR     A
   \   00002C   33           RLC     A
   \   00002D   F5..         MOV     ?V0,A
   \   00002F   C2AF         CLR     0xa8.7
     93          #endif
     94          
     95            // Calculate and map the containing flash bank into XDATA.
     96            MEMCTR = (MEMCTR & 0xF8) | pg;
   \   000031   E5..         MOV     A,?V2
   \   000033   C4           SWAP    A
   \   000034   540F         ANL     A,#0xf
   \   000036   FA           MOV     R2,A
   \   000037   E5C7         MOV     A,0xc7
   \   000039   54F8         ANL     A,#0xf8
   \   00003B   4A           ORL     A,R2
   \   00003C   F5C7         MOV     0xc7,A
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000046   801C         SJMP    ??HalFlashRead_0
     97          
     98            while (cnt--)
     99            {
    100              *buf++ = *pData++;
   \                     ??HalFlashRead_1:
   \   000048   8882         MOV     DPL,R0
   \   00004A   8983         MOV     DPH,R1
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   8C82         MOV     DPL,R4
   \   00004F   8D83         MOV     DPH,R5
   \   000051   F0           MOVX    @DPTR,A
   \   000052   8882         MOV     DPL,R0
   \   000054   8983         MOV     DPH,R1
   \   000056   A3           INC     DPTR
   \   000057   A882         MOV     R0,DPL
   \   000059   A983         MOV     R1,DPH
   \   00005B   8C82         MOV     DPL,R4
   \   00005D   8D83         MOV     DPH,R5
   \   00005F   A3           INC     DPTR
   \   000060   AC82         MOV     R4,DPL
   \   000062   AD83         MOV     R5,DPH
    101            }
   \                     ??HalFlashRead_0:
   \   000064   EA           MOV     A,R2
   \   000065   FE           MOV     R6,A
   \   000066   EB           MOV     A,R3
   \   000067   FF           MOV     R7,A
   \   000068   EE           MOV     A,R6
   \   000069   24FF         ADD     A,#-0x1
   \   00006B   1A           DEC     R2
   \   00006C   EF           MOV     A,R7
   \   00006D   34FF         ADDC    A,#-0x1
   \   00006F   FB           MOV     R3,A
   \   000070   EE           MOV     A,R6
   \   000071   4F           ORL     A,R7
   \   000072   70D4         JNZ     ??HalFlashRead_1
    102          
    103            MEMCTR = memctr;
   \   000074   85..C7       MOV     0xc7,?V1
    104          
    105          #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
    106            HAL_EXIT_CRITICAL_SECTION(is);
   \   000077   E5..         MOV     A,?V0
   \   000079   A2E0         MOV     C,0xE0 /* A   */.0
   \   00007B   92AF         MOV     0xa8.7,C
    107          #endif
    108          }
   \   00007D   02....       LJMP    ??Subroutine27_0 & 0xFFFF
   \   000080                REQUIRE MEMCTR
   \   000080                REQUIRE _A_IEN0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   7F03         MOV     R7,#0x3
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    109          
    110          /**************************************************************************************************
    111           * @fn          HalFlashWrite
    112           *
    113           * @brief       This function writes 'cnt' bytes to the internal flash.
    114           *
    115           * input parameters
    116           *
    117           * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
    118           * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
    119           * @param       cnt - Number of 4-byte blocks to write.
    120           *
    121           * output parameters
    122           *
    123           * None.
    124           *
    125           * @return      None.
    126           **************************************************************************************************
    127           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    128          void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
   \                     HalFlashWrite:
    129          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    130            halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
    131          
    132            HAL_DMA_SET_SOURCE(ch, buf);
   \   000005   ED           MOV     A,R5
   \   000006   90....       MOV     DPTR,#dmaCh0
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   EC           MOV     A,R4
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
    133            HAL_DMA_SET_DEST(ch, &FWDATA);
   \   00000D   A3           INC     DPTR
   \   00000E   7462         MOV     A,#0x62
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   7473         MOV     A,#0x73
   \   000014   F0           MOVX    @DPTR,A
    134            HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   541F         ANL     A,#0x1f
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   740A         MOV     A,#0xa
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ?Subroutine12 & 0xFFFF
    135            HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
   \                     ??CrossCallReturnLabel_11:
   \   000022   33           RLC     A
   \   000023   33           RLC     A
   \   000024   54FC         ANL     A,#0xfc
   \   000026   90....       MOV     DPTR,#dmaCh0 + 5
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   7406         MOV     A,#0x6
   \   00002C   78..         MOV     R0,#?V0
   \   00002E   12....       LCALL   ?US_SHR
   \   000031   E5..         MOV     A,?V0
   \   000033   90....       MOV     DPTR,#dmaCh0 + 4
   \   000036   F0           MOVX    @DPTR,A
    136            HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
    137            HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
    138            HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
   \   000037   90....       MOV     DPTR,#dmaCh0 + 6
   \   00003A   7412         MOV     A,#0x12
   \   00003C   F0           MOVX    @DPTR,A
    139            HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
    140            HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
    141            // The DMA is to be polled and shall not issue an IRQ upon completion.
    142            HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
    143            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
    144            HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
   \   00003D   A3           INC     DPTR
   \   00003E   7442         MOV     A,#0x42
   \   000040   F0           MOVX    @DPTR,A
    145            HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
   \   000041   75D1FE       MOV     0xd1,#-0x2
    146            HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
   \   000044   75D601       MOV     0xd6,#0x1
    147          
    148            FADDRL = (uint8)addr;
   \   000047   EA           MOV     A,R2
   \   000048   906271       MOV     DPTR,#0x6271
   \   00004B   F0           MOVX    @DPTR,A
    149            FADDRH = (uint8)(addr >> 8);
   \   00004C   EB           MOV     A,R3
   \   00004D   A3           INC     DPTR
   \   00004E   F0           MOVX    @DPTR,A
    150            FCTL |= 0x02;         // Trigger the DMA writes.
   \   00004F   906270       MOV     DPTR,#0x6270
   \   000052   E0           MOVX    A,@DPTR
   \   000053   D2E1         SETB    0xE0 /* A   */.1
   \   000055   F0           MOVX    @DPTR,A
    151            while (FCTL & 0x80);  // Wait until writing is done.
   \                     ??HalFlashWrite_0:
   \   000056   E0           MOVX    A,@DPTR
   \   000057   A2E7         MOV     C,0xE0 /* A   */.7
   \   000059   40FB         JC      ??HalFlashWrite_0
    152          }
   \   00005B   80..         SJMP    ??Subroutine23_0
   \   00005D                REQUIRE DMAIRQ
   \   00005D                REQUIRE DMAARM

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine23_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V1,A
   \   000007   E5..         MOV     A,?V0
   \   000009   22           RET
    153          
    154          /**************************************************************************************************
    155           * @fn          HalFlashErase
    156           *
    157           * @brief       This function erases the specified page of the internal flash.
    158           *
    159           * input parameters
    160           *
    161           * @param       pg - A valid flash page number to erase.
    162           *
    163           * output parameters
    164           *
    165           * None.
    166           *
    167           * @return      None.
    168           **************************************************************************************************
    169           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    170          void HalFlashErase(uint8 pg)
   \                     HalFlashErase:
    171          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    172            FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
   \   000004   E9           MOV     A,R1
   \   000005   C3           CLR     C
   \   000006   33           RLC     A
   \   000007   906272       MOV     DPTR,#0x6272
   \   00000A   02....       LJMP    ?Subroutine2 & 0xFFFF
    173            FCTL |= 0x01;
    174          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   906270       MOV     DPTR,#0x6270
   \   000004   E0           MOVX    A,@DPTR
   \   000005   D2E0         SETB    0xE0 /* A   */.0
   \   000007                REQUIRE ??Subroutine25_0
   \   000007                ; // Fall through to label ??Subroutine25_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine25_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                REQUIRE ??Subroutine26_0
   \   000001                ; // Fall through to label ??Subroutine26_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    175          
    176          /**************************************************************************************************
    177          */
C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_exec.c
      1          /******************************************************************************
      2          
      3           @file  ubl_exec.c
      4          
      5           @brief This module implements the executive functionality of a Universal Boot
      6                  Loader for an 8051-based SOC using the USB transport by MSD.
      7          
      8           Group: WCS, BTS
      9           Target Device: CC2540, CC2541
     10          
     11           ******************************************************************************
     12           
     13           Copyright (c) 2011-2016, Texas Instruments Incorporated
     14           All rights reserved.
     15          
     16           IMPORTANT: Your use of this Software is limited to those specific rights
     17           granted under the terms of a software license agreement between the user
     18           who downloaded the software, his/her employer (which must be your employer)
     19           and Texas Instruments Incorporated (the "License"). You may not use this
     20           Software unless you agree to abide by the terms of the License. The License
     21           limits your use, and you acknowledge, that the Software may not be modified,
     22           copied or distributed unless embedded on a Texas Instruments microcontroller
     23           or used solely and exclusively in conjunction with a Texas Instruments radio
     24           frequency transceiver, which is integrated into your product. Other than for
     25           the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     26           works of, modify, distribute, perform, display or sell this Software and/or
     27           its documentation for any purpose.
     28          
     29           YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     30           PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     31           INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     32           NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     33           TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     34           NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     35           LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     36           INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     37           OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     38           OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     39           (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     40          
     41           Should you have any questions regarding your right to use this Software,
     42           contact Texas Instruments Incorporated at www.TI.com.
     43          
     44           ******************************************************************************
     45           Release Name: ble_sdk_1.4.2.2
     46           Release Date: 2016-06-09 06:57:10
     47           *****************************************************************************/
     48          
     49          /* ------------------------------------------------------------------------------------------------
     50           *                                          Includes
     51           * ------------------------------------------------------------------------------------------------
     52           */
     53          
     54          #include <stddef.h>
     55          #include <string.h>
     56          
     57          #include "hal_board_cfg.h"
     58          #include "hal_dma.h"
     59          #include "hal_flash.h"
     60          #include "hal_types.h"
     61          #include "ubl_app.h"
     62          #include "ubl_exec.h"
     63          #include "usb_msd.h"
     64          
     65          /* ------------------------------------------------------------------------------------------------
     66           *                                          Constants
     67           * ------------------------------------------------------------------------------------------------
     68           */
     69          
     70          #if !defined HAL_DONGLE_NANO
     71          #define UBL_GPIO_USE
     72          #endif
     73          
     74          // Define the checksum-subset of the Meta Data for checksum calculation and copying so as not to
     75          // overwrite ong.
     76          #define UBL_MD_CHKLEN  (offsetof(ublMetaData_t, cntDnForced) - offsetof(ublMetaData_t, chkMD))
     77          

   \                                 In  segment XDATA_ROM_C, align 1
     78          static const uint8 unlockedSecKey[32] =
   \                     ??unlockedSecKey:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255
   \   000008   FF           DB 255
   \   000009   FF           DB 255
   \   00000A   FF           DB 255
   \   00000B   FF           DB 255
   \   00000C   FF           DB 255
   \   00000D   FF           DB 255
   \   00000E   FF           DB 255
   \   00000F   FF           DB 255
   \   000010   FF           DB 255
   \   000011   FF           DB 255
   \   000012   FF           DB 255
   \   000013   FF           DB 255
   \   000014   FF           DB 255
   \   000015   FF           DB 255
   \   000016   FF           DB 255
   \   000017   FF           DB 255
   \   000018   FF           DB 255
   \   000019   FF           DB 255
   \   00001A   FF           DB 255
   \   00001B   FF           DB 255
   \   00001C   FF           DB 255
   \   00001D   FF           DB 255
   \   00001E   FF           DB 255
   \   00001F   FF           DB 255
     79          {
     80            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     81            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
     82          };
     83          
     84          /***                 The following are "Write" addresses for HalFlashWrite().                  ***/
     85          #define UBL_META_DATA_ADDR_WR  \
     86            ((uint16)(UBL_META_DATA_PAGE * ((uint16)(HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE))) + \
     87                                            (uint16)(UBL_META_DATA_IDX / HAL_FLASH_WORD_SIZE))
     88          
     89          #define UBL_CNTDN_FORCED_ADDR (UBL_META_DATA_ADDR_WR + \
     90                                        (offsetof(ublMetaData_t, cntDnForced) / HAL_FLASH_WORD_SIZE))
     91          #define UBL_CNTDN_SECKEY_ADDR (UBL_META_DATA_ADDR_WR + \
     92                                        (offsetof(ublMetaData_t, cntDnSecKey) / HAL_FLASH_WORD_SIZE))
     93          /***                  The above are "Write" addresses for HalFlashWrite().                    ***/
     94          
     95          // Allow test & development with final structures and memeory map without the burden of having to
     96          // encrypt and sign every image to download until ready with the production build.
     97          #if !defined UBL_SECURE
     98          #define UBL_SECURE                   FALSE
     99          #endif
    100          
    101          #if UBL_SECURE
    102          static const uint8 aesKey[KEY_BLENGTH] = {
    103            // This dummy key must be replaced by a randomly generated key that is kept secret.
    104            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
    105          };
    106          #endif
    107          
    108          // Set UBL_SIGNER=TRUE in order to create a special boot loader that will accept
    109          // an un-encrypted/un-authenticated image via download and then sign it and send it back
    110          // with encryption on the read back.
    111          #if !defined UBL_SIGNER
    112          #define UBL_SIGNER                   FALSE
    113          #endif
    114          
    115          #if UBL_SIGNER
    116          #if !UBL_SECURE
    117          #error Mismatched definitions for UBL_SIGNER and UBL_SECURE.
    118          #else
    119          #warning You built a special "Signing" boot loader - do not release to market ... internal use only.
    120          #endif
    121          #endif
    122          
    123          /* ------------------------------------------------------------------------------------------------
    124           *                                           Macros
    125           * ------------------------------------------------------------------------------------------------
    126           */
    127          
    128          #define UBL_READ_ST(STCNT) st (             \
    129            do {  /* Get the sleep timer count; ST0 must be read first & re-read to verify. */\
    130              ((uint8 *) &(STCNT))[0] = ST0;          \
    131            } while (((uint8 *) &(STCNT))[0] != ST0); \
    132            ((uint8 *) &(STCNT))[1] = ST1;            \
    133            ((uint8 *) &(STCNT))[2] = ST2;            \
    134            ((uint8 *) &(STCNT))[3] = 0;              \
    135          )
    136          
    137          /* ------------------------------------------------------------------------------------------------
    138           *                                       Global Variables
    139           * ------------------------------------------------------------------------------------------------
    140           */
    141          

   \                                 In  segment XDATA_ROM_C, align 1
    142          const uint8 UBL_RC_IMG_PG_BEG = UBL_PAGE_FIRST;
   \                     UBL_RC_IMG_PG_BEG:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ROM_C, align 1
    143          const uint8 UBL_RC_IMG_PG_END = UBL_PAGE_LAST;
   \                     UBL_RC_IMG_PG_END:
   \   000000   77           DB 119
    144          
    145          /* ------------------------------------------------------------------------------------------------
    146           *                                       Global Variables
    147           * ------------------------------------------------------------------------------------------------
    148           */
    149          

   \                                 In  segment XDATA_N, align 1
    150          __no_init uint8 pgBuf[HAL_FLASH_PAGE_SIZE];  // RAM (XDATA) buffer for an Rx/Tx flash page.
   \                     pgBuf:
   \   000000                DS 2048

   \                                 In  segment XDATA_N, align 1
    151          __no_init ublMetaData_t ublMD;
   \                     ublMD:
   \   000000                DS 100
    152          
    153          /* ------------------------------------------------------------------------------------------------
    154           *                                       Local Variables
    155           * ------------------------------------------------------------------------------------------------
    156           */
    157          
    158          #if defined UBL_GPIO_USE
    159          static __no_init volatile uint8 *pForcePort;
    160          static __no_init uint8 forcePin;
    161          #endif

   \                                 In  segment XDATA_N, align 1
    162          static __no_init uint32 stStart, stDelay;
   \                     ??stStart:
   \   000000                DS 4

   \                                 In  segment XDATA_N, align 1
   \                     ??stDelay:
   \   000000                DS 4
    163          
    164          #if UBL_SECURE
    165          // Flag when built with UBL_SIGNER=TRUE to encrypt the read back.
    166          static bool signMode;
    167          #endif
    168          
    169          /* ------------------------------------------------------------------------------------------------
    170           *                                       Local Functions
    171           * ------------------------------------------------------------------------------------------------
    172           */
    173          
    174          #if UBL_SECURE
    175          static uint8 aesCheckCtrl(void *pBuf);
    176          static void  aesLoadKey(void);
    177          static void  aesInitSig(void);
    178          #endif
    179          
    180          static bool cntDnForcedDecr(void);
    181          #if defined UBL_GPIO_USE
    182          static bool gpioInit(void);
    183          #endif
    184          static void vddWait(void);
    185          
    186          /**************************************************************************************************
    187           * @fn          ublAesAuth
    188           *
    189           * @brief       Run the AES CRC-MAC authentication calculation over the RC image according to the
    190           *              AES Control Block parameters and update the control block accordingly.
    191           *              Just set CRC shadow equal to CRC when no valid security key built into the UBL.
    192           *
    193           * input parameters
    194           *
    195           * None.
    196           *
    197           * output parameters
    198           *
    199           * None.
    200           *
    201           * @return      TRUE or FALSE whether the AES signature of the image in flash is valid.
    202           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    203          uint8 ublAesAuth(void)
   \                     ublAesAuth:
    204          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    205          #if UBL_SECURE
    206            uint8 pgCnt = 0;
    207            uint8 sigBuf[KEY_BLENGTH];
    208          
    209            aes_ctrl_blk_t ctrlBlk;
    210            UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    211          
    212            aesInitSig();
    213          
    214            for (uint8 pgNum = UBL_PAGE_FIRST; pgNum <= UBL_PAGE_LAST; pgNum++)
    215            {
    216              if (!GET_BIT(ublMD.writeEn, pgNum))
    217              {
    218                continue;
    219              }
    220          
    221              pgCnt++;
    222          
    223              HalFlashRead(pgNum, 0, pgBuf, HAL_FLASH_PAGE_SIZE);
    224          
    225              for (uint16 oset = 0; oset < HAL_FLASH_PAGE_SIZE; )
    226              {
    227                if ((pgCnt == 1) && (oset == 0))
    228                {
    229                  oset += KEY_BLENGTH;  // Must not include the signature bytes in the signature calculation.
    230                }
    231                else if ((pgCnt == ctrlBlk.imageLen) && (oset == (HAL_FLASH_PAGE_SIZE - KEY_BLENGTH)))
    232                {
    233                  break;  // Need to change mode to CBC-MAC for the last block.
    234                }
    235          
    236                ENCCS |= 0x01;
    237                for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
    238                {
    239                  ENCDI = pgBuf[oset++];
    240                }
    241                while ((ENCCS & BV(3)) == 0);
    242              }
    243          
    244              if (pgCnt >= ctrlBlk.imageLen)
    245              {
    246                break;
    247              }
    248            }
    249          
    250            ENCCS = CBC | AES_ENCRYPT | 0x01;  // Switch to CBC mode for the last block.
    251          
    252            // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    253            // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    254            ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    255          
    256            for (uint16 oset = (HAL_FLASH_PAGE_SIZE - KEY_BLENGTH); oset < HAL_FLASH_PAGE_SIZE; oset++)
    257            {
    258              ENCDI = pgBuf[oset];
    259            }
    260            HAL_AES_DELAY();  // Delay required for non-DMA AES as RDY bit only goes hi after read out below.
    261          
    262            // CBC-MAC generates output on the last block.
    263            for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
    264            {
    265              sigBuf[cnt] = ENCDO;
    266            }
    267          
    268            if (ctrlBlk.allowSignCmd != 0)  // If requested to sign this image.
    269            {
    270              ctrlBlk.allowSignCmd = 0;
    271              (void)memcpy(ctrlBlk.signature, sigBuf, KEY_BLENGTH);
    272              UBL_NVM_SET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    273              UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    274            }
    275          
    276          #if UBL_SIGNER
    277            signMode = TRUE;  // Now the Signer should encrypt the read back.
    278          #else  // A signer must always return FALSE so that usb_msd.c does not save the file name to flash.
    279            if (memcmp(ctrlBlk.signature, sigBuf, KEY_BLENGTH))
    280          #endif
    281            {
    282              return FALSE;
    283            }
    284          #endif
    285          
    286            HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD.crcRC, 4);
   \   000005                ; Setup parameters for call to function HalFlashRead
   \   000005   75..04       MOV     ?V0,#0x4
   \   000008   75..00       MOV     ?V1,#0x0
   \   00000B   78..         MOV     R0,#?V0
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   7C..         MOV     R4,#ublMD & 0xff
   \   000012   7D..         MOV     R5,#(ublMD >> 8) & 0xff
   \   000014   7A9C         MOV     R2,#-0x64
   \   000016   7B06         MOV     R3,#0x6
   \   000018   7901         MOV     R1,#0x1
   \   00001A   12....       LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?DEALLOC_XSTACK8
    287          
    288            ublMD.crcShdw = ublMD.crcRC;
   \   000022   90....       MOV     DPTR,#ublMD
   \   000025   12....       LCALL   ??Subroutine24_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000028   A3           INC     DPTR
   \   000029   E8           MOV     A,R0
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E9           MOV     A,R1
   \   00002D   F0           MOVX    @DPTR,A
    289            ublMD.crcRC = UBL_CRC_ERASED;  // Do not write zero to the same bits more than twice.
   \   00002E   90....       MOV     DPTR,#ublMD
   \   000031   74FF         MOV     A,#-0x1
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   F0           MOVX    @DPTR,A
    290            HalFlashWrite(UBL_META_DATA_ADDR_WR, (uint8 *)&ublMD.crcRC, 1);
   \   000036                ; Setup parameters for call to function HalFlashWrite
   \   000036   75..01       MOV     ?V0,#0x1
   \   000039   78..         MOV     R0,#?V0
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   7C..         MOV     R4,#ublMD & 0xff
   \   000040   7D..         MOV     R5,#(ublMD >> 8) & 0xff
   \   000042   7AA7         MOV     R2,#-0x59
   \   000044   7B03         MOV     R3,#0x3
   \   000046   12....       LCALL   `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
    291          
    292            return TRUE;
   \   00004E   7901         MOV     R1,#0x1
   \   000050   80..         SJMP    ??Subroutine23_0
    293          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine24_0:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    294          
    295          /**************************************************************************************************
    296           * @fn          ublAesCrypt
    297           *
    298           * @brief       UBL AES encryption/decyption for the low-level transport driver.
    299           *              Just return when no valid security key built into the UBL.
    300           *
    301           * input parameters
    302           *
    303           * @param       pgNum - HAL Flash page number corresponding to the pgBuf.
    304           * @param       pgBuf - Pointer to the page buffer to crypt in place.
    305           *
    306           * output parameters
    307           *
    308           * @param       pgBuf - Pointer to the page buffer of crypted bytes.
    309           *
    310           * @return      TRUE or FALSE whether the AES image page is valid (i.e. the ctrl block on 1st page).
    311           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    312          uint8 ublAesCrypt(uint8 pgNum, uint8 *pgBuf)
                                                       ^
Remark[Pe2349]: declaration hides variable "pgBuf" (declared at line 150)
   \                     ublAesCrypt:
    313          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    314          #if UBL_SECURE
    315            if (!UBL_SIGNER || signMode)
    316            {
    317              // A0: L-encoding of L-1 = 2-1 = 1; starting 2-byte CTR at 1.
    318              uint8 ivNonce[KEY_BLENGTH] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
    319              uint8 *pBuf = pgBuf;
    320          
    321              ENCCS = CTR | AES_LOAD_IV | 0x01;
    322          
    323              // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    324              // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    325              ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    326          
    327              for (uint8 idx = 0; idx < KEY_BLENGTH; idx++)
    328              {
    329                ENCDI = ivNonce[idx];
    330              }
    331              while ((ENCCS & BV(3)) == 0);
    332          
    333              for (uint8 cnt = 0; cnt < (HAL_FLASH_PAGE_SIZE / KEY_BLENGTH); cnt++)
    334              {
    335                ENCCS = CTR | AES_ENCRYPT | 0x01;
    336          
    337                // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    338                // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    339                ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    340          
    341                for (uint8 blk = 0; blk < 4; blk++)
    342                {
    343                  for (uint8 idx = 0; idx < 4; idx++)
    344                  {
    345                    ENCDI = pBuf[idx];
    346                  }
    347          
    348                  HAL_AES_DELAY();  // Delay required for non-DMA AES as RDY bit only goes hi after read out.
    349          
    350                  for (uint8 idx = 0; idx < 4; idx++)
    351                  {
    352                    pBuf[idx] = ENCDO;
    353                  }
    354          
    355                  pBuf += 4;
    356                }
    357              }
    358          
    359              if ((pgNum == UBL_PAGE_FIRST) && !aesCheckCtrl(pgBuf))
    360              {
    361                return FALSE;
    362              }
    363            }
    364          #else
    365            (void)pgNum;
    366            (void)pgBuf;
    367          #endif
    368          
    369            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
    370          }
    371          
    372          /**************************************************************************************************
    373           * @fn          ublCfg
    374           *
    375           * @brief       Configure according to the received meta-data file if it checks out.
    376           *
    377           * input parameters
    378           *
    379           * @param       pMD - Pointer to the received meta-data file.
    380           *
    381           * output parameters
    382           *
    383           * None.
    384           *
    385           * @return      TRUE if the cfg file is acceptable; FALSE otherwise.
    386           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    387          bool ublCfg(ublMetaData_t *pMD)
   \                     ublCfg:
    388          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    389            // Thwart an attempt to break-in by an exhaustive Security Key trial-and-error.
    390            if (!UBL_UNLOCKED && (memcmp(&ublMD.secKey, &pMD->secKey, sizeof(ublMD.secKey)) != 0))
   \   00000E   90....       MOV     DPTR,#ublMD + 99
   \   000011   E0           MOVX    A,@DPTR
   \   000012   6071         JZ      ??ublCfg_0
   \   000014                ; Setup parameters for call to function memcmp
   \   000014   75..20       MOV     ?V0,#0x20
   \   000017   75..00       MOV     ?V1,#0x0
   \   00001A   78..         MOV     R0,#?V0
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F   EE           MOV     A,R6
   \   000020   2408         ADD     A,#0x8
   \   000022   FC           MOV     R4,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FD           MOV     R5,A
   \   000026   7A..         MOV     R2,#(ublMD + 8) & 0xff
   \   000028   7B..         MOV     R3,#((ublMD + 8) >> 8) & 0xff
   \   00002A   12....       LCALL   `??memcmp::?relay`   ; Banked call to: memcmp
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000032   8B..         MOV     ?V1,R3
   \   000034   EA           MOV     A,R2
   \   000035   45..         ORL     A,?V1
   \   000037   604C         JZ      ??ublCfg_0
    391            {
    392              if (ublMD.cntDnSecKey == 0)
   \   000039   90....       MOV     DPTR,#ublMD + 96
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F9           MOV     R1,A
   \   00003E   700F         JNZ     ??ublCfg_1
    393              {
    394                ublMassErase(TRUE);  // Force the erase of all pages outside of the UBL image.
   \   000040                ; Setup parameters for call to function ublMassErase
   \   000040   7901         MOV     R1,#0x1
   \   000042   12....       LCALL   `??ublMassErase::?relay`; Banked call to: ublMassErase
    395                HAL_SYSTEM_RESET();
   \   000045   C2AF         CLR     0xa8.7
   \   000047   75C9AB       MOV     0xc9,#-0x55
   \   00004A   75C95B       MOV     0xc9,#0x5b
   \                     ??ublCfg_2:
   \   00004D   80FE         SJMP    ??ublCfg_2
    396              }
    397              else
    398              {
    399                uint8 mask = 0x01;
   \                     ??ublCfg_1:
   \   00004F   7801         MOV     R0,#0x1
   \   000051   8004         SJMP    ??ublCfg_3
    400          
    401                while ((mask & ublMD.cntDnSecKey) == 0)
    402                {
    403                  mask <<= 1;
   \                     ??ublCfg_4:
   \   000053   E8           MOV     A,R0
   \   000054   C3           CLR     C
   \   000055   33           RLC     A
   \   000056   F8           MOV     R0,A
    404                }
   \                     ??ublCfg_3:
   \   000057   E8           MOV     A,R0
   \   000058   59           ANL     A,R1
   \   000059   60F8         JZ      ??ublCfg_4
    405                ublMD.cntDnSecKey ^= mask;
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   68           XRL     A,R0
   \   00005D   F0           MOVX    @DPTR,A
    406          
    407                // This will write zero to exactly one bit, so no bit is written to zero twice.
    408                uint8 secKeyAndPad[4] = { 0xFF, 0xFF, 0xFF, 0xFF };
   \   00005E   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255}>`
   \   000061   AC..         MOV     R4,?XSP + 0
   \   000063   AD..         MOV     R5,?XSP + 1
   \   000065   7404         MOV     A,#0x4
   \   000067   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    409                secKeyAndPad[0] ^= mask;
   \   00006A   12....       LCALL   ?Subroutine11 & 0xFFFF
    410                HalFlashWrite(UBL_CNTDN_SECKEY_ADDR, secKeyAndPad, 1);
    411              }
    412            }
   \                     ??CrossCallReturnLabel_9:
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000070   7402         MOV     A,#0x2
   \   000072   12....       LCALL   ?XSTACK_DISP102_8
   \   000075   7ABF         MOV     R2,#-0x41
   \   000077   7B03         MOV     R3,#0x3
   \   000079   12....       LCALL   `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?DEALLOC_XSTACK8
    413            else
    414            {
    415              UBL_UNLOCK();
    416              (void)memcpy(&ublMD.chkMD, &pMD->chkMD, UBL_MD_CHKLEN);
    417              ublMD.crcShdw = UBL_CRC_ZEROED;  // Receiving a "cfg" file is a de facto force of UBL mode.
    418              return TRUE;
    419            }
    420          
    421            return FALSE;
   \   000081   7900         MOV     R1,#0x0
   \   000083   802B         SJMP    ??ublCfg_5
   \                     ??ublCfg_0:
   \   000085   90....       MOV     DPTR,#ublMD + 99
   \   000088   E4           CLR     A
   \   000089   F0           MOVX    @DPTR,A
   \   00008A                ; Setup parameters for call to function memcpy
   \   00008A   75..58       MOV     ?V0,#0x58
   \   00008D   F5..         MOV     ?V1,A
   \   00008F   78..         MOV     R0,#?V0
   \   000091   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000094   EE           MOV     A,R6
   \   000095   2404         ADD     A,#0x4
   \   000097   FC           MOV     R4,A
   \   000098   E4           CLR     A
   \   000099   3F           ADDC    A,R7
   \   00009A   FD           MOV     R5,A
   \   00009B   7A..         MOV     R2,#(ublMD + 4) & 0xff
   \   00009D   7B..         MOV     R3,#((ublMD + 4) >> 8) & 0xff
   \   00009F   12....       LCALL   `??memcpy::?relay`   ; Banked call to: memcpy
   \   0000A2   7402         MOV     A,#0x2
   \   0000A4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A7   90....       MOV     DPTR,#ublMD + 2
   \   0000AA   E4           CLR     A
   \   0000AB   F0           MOVX    @DPTR,A
   \   0000AC   A3           INC     DPTR
   \   0000AD   F0           MOVX    @DPTR,A
   \   0000AE   7901         MOV     R1,#0x1
   \                     ??ublCfg_5:
   \   0000B0   7404         MOV     A,#0x4
   \   0000B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B5   02....       LJMP    ??Subroutine23_0 & 0xFFFF
   \   0000B8                REQUIRE _A_IEN0
   \   0000B8                REQUIRE WDCTL
    422          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   68           XRL     A,R0
   \   000008   F0           MOVX    @DPTR,A
   \   000009                ; Setup parameters for call to function HalFlashWrite
   \   000009                ; Setup parameters for call to function HalFlashWrite
   \   000009   75..01       MOV     ?V0,#0x1
   \   00000C   75..00       MOV     ?V1,#0x0
   \   00000F   78..         MOV     R0,#?V0
   \   000011   22           RET
    423          
    424          /**************************************************************************************************
    425           * @fn          ublExec
    426           *
    427           * @brief       UBL executive loop for polling and managing environment.
    428           *
    429           * input parameters
    430           *
    431           * None.
    432           *
    433           * output parameters
    434           *
    435           * None.
    436           *
    437           * @return      None.
    438           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    439          void ublExec(void)
   \                     ublExec:
    440          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    441            while (1)
    442            {
    443              // No continual waits for VDD_MIN_NV - Vdd is assumed to be stable on a USB-powered device.
    444              //vddWait();
    445          
    446              if (usb_msd_poll() == TRUE)  // TRUE == "Eject".
   \                     ??ublExec_0:
   \   00000A                ; Setup parameters for call to function usb_msd_poll
   \   00000A   12....       LCALL   `??usb_msd_poll::?relay`; Banked call to: usb_msd_poll
   \   00000D   E9           MOV     A,R1
   \   00000E   6401         XRL     A,#0x1
   \   000010   90....       MOV     DPTR,#ublMD
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??ublExec_1 & 0xFFFF
    447              {
    448                break;
    449              }
    450          
    451              if (UBL_RC_VALID && (ublMD.dlyJmp != 0))
   \   000018   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00001B   7003         JNZ     ??ublExec_2
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   69           XRL     A,R1
   \                     ??ublExec_2:
   \   000020   70E8         JNZ     ??ublExec_0
   \   000022   90....       MOV     DPTR,#ublMD
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F4           CPL     A
   \   000027   7003         JNZ     ??ublExec_3
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F4           CPL     A
   \                     ??ublExec_3:
   \   00002C   60DC         JZ      ??ublExec_0
   \   00002E   E8           MOV     A,R0
   \   00002F   49           ORL     A,R1
   \   000030   60D8         JZ      ??ublExec_0
   \   000032   90....       MOV     DPTR,#ublMD + 6
   \   000035   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000038   60D0         JZ      ??ublExec_0
    452              {
    453          #if defined UBL_GPIO_USE
    454                if (!GET_BIT(ublMD.cfgDiscs+0, gpioUseNot) &&
    455                    (GET_BIT(ublMD.cfgDiscs+0, gpioPolarity) == ((*pForcePort & BV(forcePin)) != 0)))
    456                {
    457                  ublMD.crcShdw = UBL_CRC_ZEROED;
    458                }
    459                else
    460          #endif
    461                {
    462                  uint32 stDelta;
    463                  UBL_READ_ST(stDelta);  // Get the free-running count of 30.5 usec timer ticks.
   \                     ??ublExec_4:
   \   00003A   E595         MOV     A,0x95
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   F0           MOVX    @DPTR,A
   \   000043   6595         XRL     A,0x95
   \   000045   70F3         JNZ     ??ublExec_4
   \   000047   E596         MOV     A,0x96
   \   000049   C0E0         PUSH    A
   \   00004B   7401         MOV     A,#0x1
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   D0E0         POP     A
   \   000052   F0           MOVX    @DPTR,A
   \   000053   E597         MOV     A,0x97
   \   000055   C0E0         PUSH    A
   \   000057   7402         MOV     A,#0x2
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   D0E0         POP     A
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   7403         MOV     A,#0x3
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   E4           CLR     A
   \   000065   F0           MOVX    @DPTR,A
    464                  stDelta -= stStart;  // Calculate the elapsed ticks of the free-running timer.
   \   000066   90....       MOV     DPTR,#??stStart
   \   000069   78..         MOV     R0,#?V0
   \   00006B   12....       LCALL   ?L_MOV_X
   \   00006E   85..82       MOV     DPL,?XSP + 0
   \   000071   85..83       MOV     DPH,?XSP + 1
   \   000074   78..         MOV     R0,#?V0
   \   000076   12....       LCALL   ?L_SUB_FROM_X
    465                  ((uint8 *)&stDelta)[3] = 0;  // Adjust for a carry on the 24-bit ST counter.
   \   000079   7403         MOV     A,#0x3
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   E4           CLR     A
   \   00007F   F0           MOVX    @DPTR,A
    466          
    467                  if (stDelta > stDelay)
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   78..         MOV     R0,#?V0
   \   000088   12....       LCALL   ?L_MOV_X
   \   00008B   90....       MOV     DPTR,#??stDelay
   \   00008E   78..         MOV     R0,#?V0
   \   000090   12....       LCALL   ?UL_GT_X
   \   000093   4003         JC      $+5
   \   000095   02....       LJMP    ??ublExec_0 & 0xFFFF
   \   000098   801A         SJMP    ??ublExec_5
    468                  {
    469                    break;
    470                  }
    471                }
    472              }
    473            }
    474          
    475            if (UBL_RC_VALID)
   \                     ??ublExec_1:
   \   00009A   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00009D   7003         JNZ     ??ublExec_6
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   69           XRL     A,R1
   \                     ??ublExec_6:
   \   0000A2   7016         JNZ     ??ublExec_7
   \   0000A4   90....       MOV     DPTR,#ublMD
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   F4           CPL     A
   \   0000A9   7003         JNZ     ??ublExec_8
   \   0000AB   A3           INC     DPTR
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   F4           CPL     A
   \                     ??ublExec_8:
   \   0000AE   600A         JZ      ??ublExec_7
   \   0000B0   E8           MOV     A,R0
   \   0000B1   49           ORL     A,R1
   \   0000B2   6006         JZ      ??ublExec_7
    476            {
    477              usb_msd_uninit();
   \                     ??ublExec_5:
   \   0000B4                ; Setup parameters for call to function usb_msd_uninit
   \   0000B4   12....       LCALL   `??usb_msd_uninit::?relay`; Banked call to: usb_msd_uninit
    478              ublJump();
   \   0000B7                ; Setup parameters for call to function ublJump
   \   0000B7   12....       LCALL   `??ublJump::?relay`  ; Banked call to: ublJump
    479            }
    480          }
   \                     ??ublExec_7:
   \   0000BA   7404         MOV     A,#0x4
   \   0000BC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BF   02....       LJMP    ?Subroutine3 & 0xFFFF
   \   0000C2                REQUIRE ST0
   \   0000C2                REQUIRE ST1
   \   0000C2                REQUIRE ST2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   68           XRL     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    481          
    482          /**************************************************************************************************
    483           * @fn          ublInit
    484           *
    485           * @brief       UBL environment initialization in preparation for running.
    486           *
    487           * input parameters
    488           *
    489           * None.
    490           *
    491           * output parameters
    492           *
    493           * None.
    494           *
    495           * @return      None.
    496           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    497          void ublInit(void)
   \                     ublInit:
    498          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    499            HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD, sizeof(ublMetaData_t));
   \   00000A                ; Setup parameters for call to function HalFlashRead
   \   00000A   75..64       MOV     ?V0,#0x64
   \   00000D   75..00       MOV     ?V1,#0x0
   \   000010   78..         MOV     R0,#?V0
   \   000012   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000015   7C..         MOV     R4,#ublMD & 0xff
   \   000017   7D..         MOV     R5,#(ublMD >> 8) & 0xff
   \   000019   7A9C         MOV     R2,#-0x64
   \   00001B   7B06         MOV     R3,#0x6
   \   00001D   7901         MOV     R1,#0x1
   \   00001F   12....       LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?DEALLOC_XSTACK8
    500          
    501            // If the RC image area is erased or the Application doesn't care about security, unlock the UBL.
    502            if (memcmp(ublMD.secKey, unlockedSecKey, sizeof(unlockedSecKey)) == 0)
   \   000027                ; Setup parameters for call to function memcmp
   \   000027   75..20       MOV     ?V0,#0x20
   \   00002A   78..         MOV     R0,#?V0
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   7C..         MOV     R4,#??unlockedSecKey & 0xff
   \   000031   7D..         MOV     R5,#(??unlockedSecKey >> 8) & 0xff
   \   000033   7A..         MOV     R2,#(ublMD + 8) & 0xff
   \   000035   7B..         MOV     R3,#((ublMD + 8) >> 8) & 0xff
   \   000037   12....       LCALL   `??memcmp::?relay`   ; Banked call to: memcmp
   \   00003A   7402         MOV     A,#0x2
   \   00003C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003F   8B..         MOV     ?V1,R3
   \   000041   EA           MOV     A,R2
   \   000042   45..         ORL     A,?V1
   \   000044   7005         JNZ     ??ublInit_0
    503            {
    504              UBL_UNLOCK();
   \   000046   90....       MOV     DPTR,#ublMD + 99
   \   000049   E4           CLR     A
   \   00004A   F0           MOVX    @DPTR,A
    505            }
    506          
    507            if (UBL_RC_VALID)
   \                     ??ublInit_0:
   \   00004B   90....       MOV     DPTR,#ublMD
   \   00004E   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000051   7003         JNZ     ??ublInit_1
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   69           XRL     A,R1
   \                     ??ublInit_1:
   \   000056   6003         JZ      $+5
   \   000058   02....       LJMP    ??ublInit_2 & 0xFFFF
   \   00005B   90....       MOV     DPTR,#ublMD
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F4           CPL     A
   \   000060   7003         JNZ     ??ublInit_3
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F4           CPL     A
   \                     ??ublInit_3:
   \   000065   7003         JNZ     $+5
   \   000067   02....       LJMP    ??ublInit_2 & 0xFFFF
   \   00006A   E8           MOV     A,R0
   \   00006B   49           ORL     A,R1
   \   00006C   7003         JNZ     $+5
   \   00006E   02....       LJMP    ??ublInit_2 & 0xFFFF
    508            {
    509              if ((ublMD.cntDnForced == 0) || (cntDnForcedDecr() == FALSE))
   \   000071   90....       MOV     DPTR,#ublMD + 92
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F9           MOV     R1,A
   \   000076   603C         JZ      ??ublInit_4
   \   000078   7801         MOV     R0,#0x1
   \   00007A   8004         SJMP    ??ublInit_5
   \                     ??ublInit_6:
   \   00007C   E8           MOV     A,R0
   \   00007D   C3           CLR     C
   \   00007E   33           RLC     A
   \   00007F   F8           MOV     R0,A
   \                     ??ublInit_5:
   \   000080   E8           MOV     A,R0
   \   000081   59           ANL     A,R1
   \   000082   60F8         JZ      ??ublInit_6
   \   000084   E0           MOVX    A,@DPTR
   \   000085   68           XRL     A,R0
   \   000086   F0           MOVX    @DPTR,A
   \   000087   7008         JNZ     ??ublInit_7
   \   000089   90....       MOV     DPTR,#ublMD + 2
   \   00008C   E4           CLR     A
   \   00008D   F0           MOVX    @DPTR,A
   \   00008E   A3           INC     DPTR
   \   00008F   8069         SJMP    ??ublInit_8
   \                     ??ublInit_7:
   \   000091   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255}>_1`
   \   000094   AC..         MOV     R4,?XSP + 0
   \   000096   AD..         MOV     R5,?XSP + 1
   \   000098   7404         MOV     A,#0x4
   \   00009A   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   00009D   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0000A0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A3   7402         MOV     A,#0x2
   \   0000A5   12....       LCALL   ?XSTACK_DISP102_8
   \   0000A8   7ABE         MOV     R2,#-0x42
   \   0000AA   7B03         MOV     R3,#0x3
   \   0000AC   12....       LCALL   `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
   \   0000AF   7402         MOV     A,#0x2
   \   0000B1   12....       LCALL   ?DEALLOC_XSTACK8
    510              {
    511          #if defined UBL_GPIO_USE
    512                if (GET_BIT(ublMD.cfgDiscs+0, gpioUseNot) || (gpioInit() == FALSE))
    513          #endif
    514                {
    515                  if (ublMD.dlyJmp == 0)
   \                     ??ublInit_4:
   \   0000B4   90....       MOV     DPTR,#ublMD + 6
   \   0000B7   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0000BA   45..         ORL     A,?V1
   \   0000BC   7005         JNZ     ??ublInit_9
    516                  {
    517                    ublJump();
   \   0000BE                ; Setup parameters for call to function ublJump
   \   0000BE   12....       LCALL   `??ublJump::?relay`  ; Banked call to: ublJump
   \   0000C1   8038         SJMP    ??ublInit_2
    518                  }
    519                  else
    520                  {
    521                    stDelay = (ublMD.dlyJmp * 4096UL) / 125;
   \                     ??ublInit_9:
   \   0000C3   E4           CLR     A
   \   0000C4   F5..         MOV     ?V2,A
   \   0000C6   F5..         MOV     ?V3,A
   \   0000C8   740C         MOV     A,#0xc
   \   0000CA   78..         MOV     R0,#?V0
   \   0000CC   12....       LCALL   ?L_SHL
   \   0000CF   90....       MOV     DPTR,#__Constant_7d
   \   0000D2   78..         MOV     R0,#?V4
   \   0000D4   12....       LCALL   ?L_MOV_X
   \   0000D7   78..         MOV     R0,#?V0
   \   0000D9   79..         MOV     R1,#?V4
   \   0000DB   12....       LCALL   ?UL_DIV_MOD
   \   0000DE   90....       MOV     DPTR,#??stDelay
   \   0000E1   78..         MOV     R0,#?V0
   \   0000E3   12....       LCALL   ?L_MOV_TO_X
    522                    UBL_READ_ST(stStart);
   \                     ??ublInit_10:
   \   0000E6   E595         MOV     A,0x95
   \   0000E8   90....       MOV     DPTR,#??stStart
   \   0000EB   F0           MOVX    @DPTR,A
   \   0000EC   6595         XRL     A,0x95
   \   0000EE   70F6         JNZ     ??ublInit_10
   \   0000F0   E596         MOV     A,0x96
   \   0000F2   A3           INC     DPTR
   \   0000F3   F0           MOVX    @DPTR,A
   \   0000F4   E597         MOV     A,0x97
   \   0000F6   A3           INC     DPTR
   \   0000F7   F0           MOVX    @DPTR,A
   \   0000F8   A3           INC     DPTR
   \   0000F9   E4           CLR     A
   \                     ??ublInit_8:
   \   0000FA   F0           MOVX    @DPTR,A
    523                  }
    524                }
    525              }
    526            }
    527          
    528            vddWait();  // Stricter wait then in main, looking for safe Vdd for writing flash.
   \                     ??ublInit_2:
   \   0000FB   7810         MOV     R0,#0x10
   \                     ??ublInit_11:
   \   0000FD   75B60F       MOV     0xb6,#0xf
   \                     ??ublInit_12:
   \   000100   E5B4         MOV     A,0xb4
   \   000102   A2E7         MOV     C,0xE0 /* A   */.7
   \   000104   50FA         JNC     ??ublInit_12
   \   000106   E5BB         MOV     A,0xbb
   \   000108   C3           CLR     C
   \   000109   944E         SUBB    A,#0x4e
   \   00010B   40F0         JC      ??ublInit_11
   \   00010D   18           DEC     R0
   \   00010E   E8           MOV     A,R0
   \   00010F   70EC         JNZ     ??ublInit_11
    529          
    530          #if UBL_SECURE
    531            aesLoadKey();
    532          
    533            aes_ctrl_blk_t ctrlBlk;
    534            UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    535          
    536            if ((ctrlBlk.allowSignCmd != 0) && (ctrlBlk.imageLen != 0xFF)) // If requested to sign this image.
    537            {
    538              // Signing after checking UBL_RC_VALID ensures run as MSD again so encrypted image can be read.
    539              (void)ublAesAuth();
    540            }
    541          
    542          #if UBL_SIGNER  // A signer must allow image read back of what was written.
    543            for (uint8 idx = 0; idx < 16; idx++)
    544            {
    545              ublMD.readLock[idx] = ublMD.writeEn[idx] ^ 0xFF;
    546            }
    547          #endif
    548          #endif
    549          
    550            usb_msd_init();  // Initialize USB-MSD as late as possible for time limits after enabling D+ line.
   \   000111                ; Setup parameters for call to function usb_msd_init
   \   000111   12....       LCALL   `??usb_msd_init::?relay`; Banked call to: usb_msd_init
    551          }
   \   000114   7404         MOV     A,#0x4
   \   000116   12....       LCALL   ?DEALLOC_XSTACK8
   \   000119   7F08         MOV     R7,#0x8
   \   00011B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00011E                REQUIRE ST0
   \   00011E                REQUIRE ST1
   \   00011E                REQUIRE ST2
   \   00011E                REQUIRE ADCCON3
   \   00011E                REQUIRE ADCCON1
   \   00011E                REQUIRE ADCH
    552          
    553          /**************************************************************************************************
    554           * @fn          ublJump
    555           *
    556           * @brief       Execute a simple long jump from non-banked UBL code to non-banked RC code space.
    557           *
    558           * input parameters
    559           *
    560           * None.
    561           *
    562           * output parameters
    563           *
    564           * None.
    565           *
    566           * @return      None.
    567           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    568          void ublJump(void)
   \                     ublJump:
    569          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    570            asm("LJMP 0x820\n");  // Immediate jump to run-code.
   \   000000   020820       LJMP 0x820
    571            HAL_SYSTEM_RESET();
   \   000003   C2AF         CLR     0xa8.7
   \   000005   75C9AB       MOV     0xc9,#-0x55
   \   000008   75C95B       MOV     0xc9,#0x5b
   \                     ??ublJump_0:
   \   00000B   80FE         SJMP    ??ublJump_0
   \   00000D                REQUIRE _A_IEN0
   \   00000D                REQUIRE WDCTL
    572          }
    573          
    574          /**************************************************************************************************
    575           * @fn          ublMassErase
    576           *
    577           * @brief       Erase all pages enabled for mass-erase (not including UBL pages or lock bits page).
    578           *
    579           * input parameters
    580           *
    581           * @param       eraseAll - Flag to override the 'eraseEn' bits of the Meta Data.
    582           *
    583           * output parameters
    584           *
    585           * None.
    586           *
    587           * @return      None.
    588           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    589          void ublMassErase(bool eraseAll)
   \                     ublMassErase:
    590          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    591            for (uint8 pg = UBL_RC_IMG_PG_BEG+1; pg <= UBL_PAGE_LAST; pg++)
   \   000004   7802         MOV     R0,#0x2
    592            {
    593              if (eraseAll || GET_BIT(ublMD.eraseEn, pg))
   \                     ??ublMassErase_0:
   \   000006   E9           MOV     A,R1
   \   000007   7027         JNZ     ??ublMassErase_1
   \   000009   E8           MOV     A,R0
   \   00000A   13           RRC     A
   \   00000B   13           RRC     A
   \   00000C   13           RRC     A
   \   00000D   541F         ANL     A,#0x1f
   \   00000F   FA           MOV     R2,A
   \   000010   74..         MOV     A,#(ublMD + 40) & 0xff
   \   000012   2A           ADD     A,R2
   \   000013   F582         MOV     DPL,A
   \   000015   E4           CLR     A
   \   000016   34..         ADDC    A,#((ublMD + 40) >> 8) & 0xff
   \   000018   F583         MOV     DPH,A
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   C0E0         PUSH    A
   \   00001D   7407         MOV     A,#0x7
   \   00001F   58           ANL     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   D0E0         POP     A
   \   000023   BA0002       CJNE    R2,#0x0,??ublMassErase_2
   \   000026   8004         SJMP    ??ublMassErase_3
   \                     ??ublMassErase_2:
   \   000028   C3           CLR     C
   \   000029   13           RRC     A
   \   00002A   DAFC         DJNZ    R2,??ublMassErase_2
   \                     ??ublMassErase_3:
   \   00002C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002E   500E         JNC     ??ublMassErase_4
    594              {
    595                FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
   \                     ??ublMassErase_1:
   \   000030   E8           MOV     A,R0
   \   000031   C3           CLR     C
   \   000032   33           RLC     A
   \   000033   906272       MOV     DPTR,#0x6272
   \   000036   F0           MOVX    @DPTR,A
    596                FCTL |= 0x01;
   \   000037   906270       MOV     DPTR,#0x6270
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   D2E0         SETB    0xE0 /* A   */.0
   \   00003D   F0           MOVX    @DPTR,A
    597              }
    598            }
   \                     ??ublMassErase_4:
   \   00003E   08           INC     R0
   \   00003F   E8           MOV     A,R0
   \   000040   C3           CLR     C
   \   000041   9478         SUBB    A,#0x78
   \   000043   40C1         JC      ??ublMassErase_0
    599          
    600            // Now erase the page with the filename.
    601            FADDRH = UBL_RC_IMG_PG_BEG * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
   \   000045   906272       MOV     DPTR,#0x6272
   \   000048   7402         MOV     A,#0x2
   \   00004A   02....       LJMP    ?Subroutine2 & 0xFFFF
    602            FCTL |= 0x01;
    603          }
    604          
    605          #if UBL_SECURE
    606          /**************************************************************************************************
    607           * @fn          aesCheckCtrl
    608           *
    609           * @brief       Check validity of a AES Control Block before writing it to flash.
    610           *
    611           * input parameters
    612           *
    613           * @param       pBuf - Pointer to the buffer containing the control block.
    614           *
    615           * output parameters
    616           *
    617           * None.
    618           *
    619           * @return      TRUE or FALSE for control block valid.
    620           */
    621          static uint8 aesCheckCtrl(void *pBuf)
    622          {
    623            uint8 sigBuf[KEY_BLENGTH] =
    624             {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    625            aes_ctrl_blk_t *pCtl = (aes_ctrl_blk_t *)pBuf;
    626          
    627          #if UBL_SIGNER
    628            if ( memcmp(pCtl->signature, sigBuf, sizeof(sigBuf))
    629                    || (pCtl->imageLen == 0)
    630                    || (pCtl->imageLen > UBL_PAGE_LAST)
    631                    || (pCtl->allowSignCmd == 0))
    632          #else
    633            if (!memcmp(pCtl->signature, sigBuf, sizeof(sigBuf))
    634                    || (pCtl->imageLen == 0)
    635                    || (pCtl->imageLen > UBL_PAGE_LAST)
    636                    || (pCtl->allowSignCmd != 0))
    637          #endif
    638            {
    639              return FALSE;
    640            }
    641          
    642            return TRUE;
    643          }
    644          
    645          /**************************************************************************************************
    646           * @fn          aesLoadKey
    647           *
    648           * @brief       Load the shared secret key into the AES for operations.
    649           *
    650           * input parameters
    651           *
    652           * None.
    653           *
    654           * output parameters
    655           *
    656           * None.
    657           *
    658           * @return      None.
    659           */
    660          static void aesLoadKey(void)
    661          {
    662            // Read the security key from flash 1 byte at a time to thwart an interrupt & read XDATA attack.
    663            uint8 *keyPtr = (uint8 *)aesKey;
    664          
    665            ENCCS = ECB | AES_LOAD_KEY | 0x01;
    666          
    667            // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    668            // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    669            ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    670          
    671            for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
    672            {
    673              ENCDI = *keyPtr++;
    674            }
    675          }
    676          
    677          /**************************************************************************************************
    678           * @fn          aesInitSig
    679           *
    680           * @brief       Initialize the AES for signature calculation.
    681           *
    682           * input parameters
    683           *
    684           * None.
    685           *
    686           * output parameters
    687           *
    688           * None.
    689           *
    690           * @return      None.
    691           */
    692          static void aesInitSig(void)
    693          {
    694            aes_ctrl_blk_t ctrlBlk;
    695            UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    696          
    697            ENCCS = CBC_MAC | AES_LOAD_IV | 0x01;
    698          
    699            // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    700            // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    701            ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    702          
    703            for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
    704            {
    705              ENCDI = 0;
    706            }
    707          
    708            ENCCS = CBC_MAC | AES_ENCRYPT | 0x01;
    709          
    710            // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    711            // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    712            ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    713          
    714            ENCDI = 0x3A;  // B0 Flag: Res=0, A_Data=0, (M-2)/2=7, (L-1)=2.
    715          
    716            ENCDI = LO_UINT16(ctrlBlk.spare[0]);
    717            ENCDI = HI_UINT16(ctrlBlk.spare[0]);
    718            for (uint8 idx = 0; idx < 10; idx++)
    719            {
    720              ENCDI = ctrlBlk.nonce10[idx];
    721            }
    722          
    723            // Image length in 3 bytes, MSB to LSB order - the Signature bytes are not to be included.
    724            uint32 imageLen = 2048UL * ctrlBlk.imageLen - KEY_BLENGTH;
    725            ENCDI = ((uint8 *)&imageLen)[2];
    726            ENCDI = ((uint8 *)&imageLen)[1];
    727            ENCDI = ((uint8 *)&imageLen)[0];
    728          
    729            while ((ENCCS & BV(3)) == 0);
    730          }
    731          #endif
    732          
    733          /**************************************************************************************************
    734           * @fn          cntDnForcedDecr
    735           *
    736           * @brief       Decrement the cntDnForced.
    737           *
    738           * input parameters
    739           *
    740           * None.
    741           *
    742           * output parameters
    743           *
    744           * None.
    745           *
    746           * @return      TRUE if the dlyJmp decrements to zero; FALSE otherwise.
    747           */
    748          static bool cntDnForcedDecr(void)
    749          {
    750            uint8 mask = 0x01;
    751          
    752            while ((mask & ublMD.cntDnForced) == 0)
    753            {
    754              mask <<= 1;
    755            }
    756            ublMD.cntDnForced ^= mask;
    757          
    758            if (ublMD.cntDnForced == 0)
    759            {
    760              // Don't write the zero to flash in case of another cold-boot before re-programming, just
    761              // force boot now by faking the CRC-shdw as zeroed.
    762              ublMD.crcShdw = UBL_CRC_ZEROED;  // No need to zero crcShdw in flash, this will always run.
    763              return TRUE;
    764            }
    765            else
    766            {
    767              // This will write zero to exactly one bit, so no bit is written to zero twice.
    768              uint8 forcedAndPad[4] = { 0xFF, 0xFF, 0xFF, 0xFF };
    769              forcedAndPad[0] ^= mask;
    770              HalFlashWrite(UBL_CNTDN_FORCED_ADDR, forcedAndPad, 1);
    771              return FALSE;
    772            }
    773          }
    774          
    775          #if defined UBL_GPIO_USE
    776          /**************************************************************************************************
    777           * @fn          gpioInit
    778           *
    779           * @brief       Initialize the generic GPIO force configuration.
    780           *
    781           * input parameters
    782           *
    783           * None.
    784           *
    785           * output parameters
    786           *
    787           * None.
    788           *
    789           * @return      TRUE if the GPIO is already forcing UBL mode; FALSE otherwise.
    790           */
    791          static bool gpioInit(void)
    792          {
    793            volatile uint8 *ptr;
    794            uint8 port = ublMD.gpioPort / 8;
    795            uint8 pin = ublMD.gpioPort % 8;
    796          
    797            ptr = ((port == 0) ? &X_P0SEL : ((port == 1) ? &X_P1SEL : &X_P2SEL));
    798            *ptr &= ~BV(pin);
    799          
    800            ptr = ((port == 0) ? &X_P0DIR : ((port == 1) ? &X_P1DIR : &X_P2DIR));
    801            *ptr &= ~BV(pin);
    802          
    803            ptr = ((port == 0) ? &X_P0INP : ((port == 1) ? &X_P1INP : &X_P2INP));
    804            if (GET_BIT(ublMD.cfgDiscs+0, gpioPullTri))     // If pulling.
    805            {
    806              if (GET_BIT(ublMD.cfgDiscs+0, gpioPullUpDn))  // If pulling up.
    807              {
    808                P2INP &= ~BV(port + 5);
    809              }
    810              else                                          // If pulling down.
    811              {
    812                P2INP |= BV(port + 5); \
    813              }
    814              *ptr &= ~BV(pin);
    815            }
    816            else                                            // Tri-state.
    817            {
    818              *ptr |=  BV(pin);
    819            }
    820          
    821            forcePin = pin;
    822            pForcePort = ((port == 0) ? &X_P0 : ((port == 1) ? &X_P1 : &X_P2));
    823          
    824            if (GET_BIT(ublMD.cfgDiscs+0, gpioPolarity) == ((*pForcePort & BV(forcePin)) != 0))
    825            {
    826              ublMD.crcShdw = UBL_CRC_ZEROED;
    827              return TRUE;
    828            }
    829          
    830            return FALSE;
    831          }
    832          #endif
    833          
    834          /**************************************************************************************************
    835           * @fn          vddWait
    836           *
    837           * @brief       Loop waiting for 16 reads of the Vdd over the safe minimum to erase/write flash.
    838           *
    839           * input parameters
    840           *
    841           * None.
    842           *
    843           * output parameters
    844           *
    845           * None.
    846           *
    847           * @return      None.
    848           */
    849          static void vddWait(void)
    850          {
    851            uint8 cnt = 16;
    852          
    853            do {
    854              do {
    855                ADCCON3 = 0x0F;
    856                while (!(ADCCON1 & 0x80));
    857              } while (ADCH < VDD_MIN_NV);
    858            } while (--cnt);
    859          }
    860          
    861          /**************************************************************************************************
    862          */
C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_main.c
      1          /******************************************************************************
      2          
      3           @file  ubl_main.c
      4          
      5           @brief This module implements the main functionality of a Universal Boot
      6                  Loader for an 8051-based SOC via the USB by MSD. The functionality is
      7                  similar to ZStack OnBoard.c and hal_startup.c.
      8          
      9           Group: WCS, BTS
     10           Target Device: CC2540, CC2541
     11          
     12           ******************************************************************************
     13           
     14           Copyright (c) 2011-2016, Texas Instruments Incorporated
     15           All rights reserved.
     16          
     17           IMPORTANT: Your use of this Software is limited to those specific rights
     18           granted under the terms of a software license agreement between the user
     19           who downloaded the software, his/her employer (which must be your employer)
     20           and Texas Instruments Incorporated (the "License"). You may not use this
     21           Software unless you agree to abide by the terms of the License. The License
     22           limits your use, and you acknowledge, that the Software may not be modified,
     23           copied or distributed unless embedded on a Texas Instruments microcontroller
     24           or used solely and exclusively in conjunction with a Texas Instruments radio
     25           frequency transceiver, which is integrated into your product. Other than for
     26           the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     27           works of, modify, distribute, perform, display or sell this Software and/or
     28           its documentation for any purpose.
     29          
     30           YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     31           PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     32           INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     33           NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     34           TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     35           NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     36           LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     37           INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     38           OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     39           OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     40           (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     41          
     42           Should you have any questions regarding your right to use this Software,
     43           contact Texas Instruments Incorporated at www.TI.com.
     44          
     45           ******************************************************************************
     46           Release Name: ble_sdk_1.4.2.2
     47           Release Date: 2016-06-09 06:57:10
     48           *****************************************************************************/
     49          
     50          /* ------------------------------------------------------------------------------------------------
     51           *                                          Includes
     52           * ------------------------------------------------------------------------------------------------
     53           */
     54          
     55          #include "hal_board_cfg.h"
     56          #include "hal_dma.h"
     57          #include "hal_flash.h"
     58          #include "ubl_app.h"
     59          #include "ubl_exec.h"
     60          #include "usb_interrupt.h"
     61          
     62          /* ------------------------------------------------------------------------------------------------
     63           *                                       Global Variables
     64           * ------------------------------------------------------------------------------------------------
     65           */
     66          

   \                                 In  segment XDATA_N, align 1
     67          __no_init halDMADesc_t dmaCh0;  // Needed by the HAL flash write.
   \                     dmaCh0:
   \   000000                DS 8
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                       Local Functions
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          
     74          static void vddWait(void);
     75          
     76          // If the code model is banked, low_level_init must be declared
     77          // __near_func elsa a ?BRET is performed
     78          //
     79          #if (__CODE_MODEL__ == 2)
     80          __near_func __root char
     81          #else
     82          __root char
     83          #endif
     84          __low_level_init(void);
     85          
     86          /**************************************************************************************************
     87           * @fn          __low_level_init
     88           *
     89           * @brief       Abort boot loader as soon as possible after a Watchdog reset with a valid RC image.
     90           *              This function is called by the IAR start-up code before doing normal initialization
     91           *              of the data segments.
     92           *
     93           * input parameters
     94           *
     95           * None.
     96           *
     97           * output parameters
     98           *
     99           * None.
    100           *
    101           * @return      0 - don't intialize data segments / 1 - do initialization.
    102           */
    103          #if (__CODE_MODEL__ == 2)

   \                                 In  segment NEAR_CODE, align 1, keep-with-next, root
    104          __near_func __root char
    105          #else
    106          __root char
    107          #endif
    108          __low_level_init(void)
   \                     __low_level_init:
   \   000000                REQUIRE __low_level_init_call
    109          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    110            // Map flash bank #7 into XDATA for access to "ROM mapped as data".
    111            MEMCTR = (MEMCTR & 0xF8) | 0x07;
   \   000005   43C707       ORL     0xc7,#0x7
    112          
    113            if (ResetWasWatchDog)
   \   000008   E59D         MOV     A,0x9d
   \   00000A   5418         ANL     A,#0x18
   \   00000C   6410         XRL     A,#0x10
   \   00000E   7042         JNZ     ??__low_level_init_0
    114            {
    115              // Read from Flash the minimum subset of ublMetaData_t necessary for UBL_RC_VALID().
    116              HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD.crcRC, 4);
   \   000010                ; Setup parameters for call to function HalFlashRead
   \   000010   75..04       MOV     ?V0,#0x4
   \   000013   75..00       MOV     ?V1,#0x0
   \   000016   78..         MOV     R0,#?V0
   \   000018   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001B   7C..         MOV     R4,#ublMD & 0xff
   \   00001D   7D..         MOV     R5,#(ublMD >> 8) & 0xff
   \   00001F   7A9C         MOV     R2,#-0x64
   \   000021   7B06         MOV     R3,#0x6
   \   000023   7901         MOV     R1,#0x1
   \   000025   12....       LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000028   7402         MOV     A,#0x2
   \   00002A   12....       LCALL   ?DEALLOC_XSTACK8
    117          
    118              if (UBL_RC_VALID)
   \   00002D   90....       MOV     DPTR,#ublMD
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F8           MOV     R0,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F9           MOV     R1,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   68           XRL     A,R0
   \   000038   7003         JNZ     ??__low_level_init_1
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   69           XRL     A,R1
   \                     ??__low_level_init_1:
   \   00003D   7013         JNZ     ??__low_level_init_0
   \   00003F   90....       MOV     DPTR,#ublMD
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F4           CPL     A
   \   000044   7003         JNZ     ??__low_level_init_2
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F4           CPL     A
   \                     ??__low_level_init_2:
   \   000049   6007         JZ      ??__low_level_init_0
   \   00004B   E8           MOV     A,R0
   \   00004C   49           ORL     A,R1
   \   00004D   6003         JZ      ??__low_level_init_0
    119              {
    120                ublJump();
   \   00004F                ; Setup parameters for call to function ublJump
   \   00004F   12....       LCALL   `??ublJump::?relay`  ; Banked call to: ublJump
    121              }
    122            }
    123          
    124            vddWait();
   \                     ??__low_level_init_0:
   \   000052   7810         MOV     R0,#0x10
   \                     ??__low_level_init_3:
   \   000054   75B60F       MOV     0xb6,#0xf
   \                     ??__low_level_init_4:
   \   000057   E5B4         MOV     A,0xb4
   \   000059   A2E7         MOV     C,0xE0 /* A   */.7
   \   00005B   50FA         JNC     ??__low_level_init_4
   \   00005D   E5BB         MOV     A,0xbb
   \   00005F   C3           CLR     C
   \   000060   944A         SUBB    A,#0x4a
   \   000062   40F0         JC      ??__low_level_init_3
   \   000064   18           DEC     R0
   \   000065   E8           MOV     A,R0
   \   000066   70EC         JNZ     ??__low_level_init_3
    125            HAL_BOARD_INIT();
   \   000068   75A800       MOV     0xa8,#0x0
   \   00006B   75B800       MOV     0xb8,#0x0
   \   00006E   759A00       MOV     0x9a,#0x0
   \   000071   75C680       MOV     0xc6,#-0x80
   \   000074   906270       MOV     DPTR,#0x6270
   \   000077   7408         MOV     A,#0x8
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   53F3FE       ANL     0xf3,#0xfe
   \   00007D   53FDFE       ANL     0xfd,#0xfe
   \   000080   538FFE       ANL     0x8f,#0xfe
   \   000083   43F720       ORL     0xf7,#0x20
   \   000086   53F3FD       ANL     0xf3,#0xfd
   \   000089   53FDFD       ANL     0xfd,#0xfd
   \   00008C   538FFD       ANL     0x8f,#0xfd
   \   00008F   43F720       ORL     0xf7,#0x20
   \   000092   53F3FB       ANL     0xf3,#0xfb
   \   000095   53FDFB       ANL     0xfd,#0xfb
   \   000098   538FFB       ANL     0x8f,#0xfb
   \   00009B   43F720       ORL     0xf7,#0x20
   \   00009E   53F3F7       ANL     0xf3,#0xf7
   \   0000A1   53FDF7       ANL     0xfd,#0xf7
   \   0000A4   538FF7       ANL     0x8f,#0xf7
   \   0000A7   43F720       ORL     0xf7,#0x20
   \   0000AA   53F3EF       ANL     0xf3,#0xef
   \   0000AD   53FDEF       ANL     0xfd,#0xef
   \   0000B0   538FEF       ANL     0x8f,#0xef
   \   0000B3   43F720       ORL     0xf7,#0x20
   \   0000B6   53F3DF       ANL     0xf3,#0xdf
   \   0000B9   53FDDF       ANL     0xfd,#0xdf
   \   0000BC   538FDF       ANL     0x8f,#0xdf
   \   0000BF   43F720       ORL     0xf7,#0x20
   \   0000C2   53F3BF       ANL     0xf3,#0xbf
   \   0000C5   53FDBF       ANL     0xfd,#0xbf
   \   0000C8   538FBF       ANL     0x8f,#0xbf
   \   0000CB   43F720       ORL     0xf7,#0x20
   \   0000CE   53F37F       ANL     0xf3,#0x7f
   \   0000D1   53FD7F       ANL     0xfd,#0x7f
   \   0000D4   538F7F       ANL     0x8f,#0x7f
   \   0000D7   43F720       ORL     0xf7,#0x20
   \   0000DA   53F4FD       ANL     0xf4,#0xfd
   \   0000DD   53FEFD       ANL     0xfe,#0xfd
   \   0000E0   53F6FD       ANL     0xf6,#0xfd
   \   0000E3   43F740       ORL     0xf7,#0x40
   \   0000E6   53F4FB       ANL     0xf4,#0xfb
   \   0000E9   53FEFB       ANL     0xfe,#0xfb
   \   0000EC   53F6FB       ANL     0xf6,#0xfb
   \   0000EF   43F740       ORL     0xf7,#0x40
   \   0000F2   53F4F7       ANL     0xf4,#0xf7
   \   0000F5   53FEF7       ANL     0xfe,#0xf7
   \   0000F8   53F6F7       ANL     0xf6,#0xf7
   \   0000FB   43F740       ORL     0xf7,#0x40
   \   0000FE   53F4EF       ANL     0xf4,#0xef
   \   000101   53FEEF       ANL     0xfe,#0xef
   \   000104   53F6EF       ANL     0xf6,#0xef
   \   000107   43F740       ORL     0xf7,#0x40
   \   00010A   53F4DF       ANL     0xf4,#0xdf
   \   00010D   53FEDF       ANL     0xfe,#0xdf
   \   000110   53F6DF       ANL     0xf6,#0xdf
   \   000113   43F740       ORL     0xf7,#0x40
   \   000116   53F4BF       ANL     0xf4,#0xbf
   \   000119   53FEBF       ANL     0xfe,#0xbf
   \   00011C   53F6BF       ANL     0xf6,#0xbf
   \   00011F   43F740       ORL     0xf7,#0x40
   \   000122   53F47F       ANL     0xf4,#0x7f
   \   000125   53FE7F       ANL     0xfe,#0x7f
   \   000128   53F67F       ANL     0xf6,#0x7f
   \   00012B   43F740       ORL     0xf7,#0x40
   \   00012E   53F5F7       ANL     0xf5,#0xf7
   \   000131   53FFF7       ANL     0xff,#0xf7
   \   000134   53F7F7       ANL     0xf7,#0xf7
   \   000137   43F780       ORL     0xf7,#0x80
   \   00013A   53F5EF       ANL     0xf5,#0xef
   \   00013D   53FFEF       ANL     0xff,#0xef
   \   000140   53F7EF       ANL     0xf7,#0xef
   \   000143   43F780       ORL     0xf7,#0x80
   \   000146   43F706       ORL     0xf7,#0x6
    126          
    127            // Choose if segment initialization should be done or not: 0 to omit seg_init; 1 to run seg_init.
    128            return 1;
   \   000149   7901         MOV     R1,#0x1
   \   00014B   7F02         MOV     R7,#0x2
   \   00014D   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000150                REQUIRE MEMCTR
   \   000150                REQUIRE SLEEPSTA
   \   000150                REQUIRE _A_IEN0
   \   000150                REQUIRE _A_IEN1
   \   000150                REQUIRE IEN2
   \   000150                REQUIRE CLKCONCMD
   \   000150                REQUIRE P0SEL
   \   000150                REQUIRE P0DIR
   \   000150                REQUIRE P0INP
   \   000150                REQUIRE P2INP
   \   000150                REQUIRE P1SEL
   \   000150                REQUIRE P1DIR
   \   000150                REQUIRE P1INP
   \   000150                REQUIRE P2SEL
   \   000150                REQUIRE P2DIR
   \   000150                REQUIRE ADCCON3
   \   000150                REQUIRE ADCCON1
   \   000150                REQUIRE ADCH
    129          }
    130          
    131          /**************************************************************************************************
    132           * @fn          main
    133           *
    134           * @brief       ISR for the reset vector, invoked by IAR after all segment initialization.
    135           *
    136           * input parameters
    137           *
    138           * None.
    139           *
    140           * output parameters
    141           *
    142           * None.
    143           *
    144           * @return      None.
    145           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    146          void main(void)
   \                     main:
    147          {
   \   000000                ; Auto size: 0
    148            /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
    149             * descriptors in addition to just Channel 0.
    150             */
    151            HAL_DMA_SET_ADDR_DESC0(&dmaCh0);
   \   000000   74..         MOV     A,#(dmaCh0 >> 8) & 0xff
   \   000002   F5D5         MOV     0xd5,A
   \   000004   75D4..       MOV     0xd4,#dmaCh0 & 0xff
    152          
    153            ublInit();
   \   000007                ; Setup parameters for call to function ublInit
   \   000007   12....       LCALL   `??ublInit::?relay`  ; Banked call to: ublInit
    154            ublExec();
   \   00000A                ; Setup parameters for call to function ublExec
   \   00000A   12....       LCALL   `??ublExec::?relay`  ; Banked call to: ublExec
    155          
    156            HAL_SYSTEM_RESET();
   \   00000D   C2AF         CLR     0xa8.7
   \   00000F   75C9AB       MOV     0xc9,#-0x55
   \   000012   75C95B       MOV     0xc9,#0x5b
   \                     ??main_0:
   \   000015   80FE         SJMP    ??main_0
   \   000017                REQUIRE DMA0CFGH
   \   000017                REQUIRE DMA0CFGL
   \   000017                REQUIRE _A_IEN0
   \   000017                REQUIRE WDCTL
    157          }
    158          
    159          /**************************************************************************************************
    160           * @fn          vddWait
    161           *
    162           * @brief       Loop waiting for 16 reads of the Vdd over the safe minimum to run.
    163           *
    164           * input parameters
    165           *
    166           * None.
    167           *
    168           * output parameters
    169           *
    170           * None.
    171           *
    172           * @return      None.
    173           */
    174          static void vddWait(void)
    175          {
    176            uint8 cnt = 16;
    177          
    178            do {
    179              do {
    180                ADCCON3 = 0x0F;
    181                while (!(ADCCON1 & 0x80));
    182              } while (ADCH < VDD_MIN_RUN);
    183            } while (--cnt);
    184          }
    185          
    186          /**************************************************************************************************
    187          */
C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_descriptor_parser.c
      1          /******************************************************************************
      2          
      3           @file  usb_descriptor_parser.c
      4          
      5           @brief Parser for USB descriptor structures.
      6          
      7           Group: WCS, BTS
      8           Target Device: CC2540, CC2541
      9          
     10           ******************************************************************************
     11           
     12           Copyright (c) 2004-2016, Texas Instruments Incorporated
     13           All rights reserved.
     14          
     15           IMPORTANT: Your use of this Software is limited to those specific rights
     16           granted under the terms of a software license agreement between the user
     17           who downloaded the software, his/her employer (which must be your employer)
     18           and Texas Instruments Incorporated (the "License"). You may not use this
     19           Software unless you agree to abide by the terms of the License. The License
     20           limits your use, and you acknowledge, that the Software may not be modified,
     21           copied or distributed unless embedded on a Texas Instruments microcontroller
     22           or used solely and exclusively in conjunction with a Texas Instruments radio
     23           frequency transceiver, which is integrated into your product. Other than for
     24           the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25           works of, modify, distribute, perform, display or sell this Software and/or
     26           its documentation for any purpose.
     27          
     28           YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29           PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30           INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31           NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32           TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33           NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34           LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35           INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36           OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37           OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38           (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40           Should you have any questions regarding your right to use this Software,
     41           contact Texas Instruments Incorporated at www.TI.com.
     42          
     43           ******************************************************************************
     44           Release Name: ble_sdk_1.4.2.2
     45           Release Date: 2016-06-09 06:57:10
     46           *****************************************************************************/
     47          
     48          /// \addtogroup module_usb_descriptor_parser
     49          /// @{
     50          #define USBDESCRIPTORPARSER_C ///< Modifies the behavior of "EXTERN" in usb_descriptor_parser.h
     51          #include "usb_firmware_library_headers.h"
     52          #include "hal_flash.h"
     53          
     54          //-------------------------------------------------------------------------------------------------------
     55          // USBDP internal module data

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     56          static USBDP_DATA __xdata usbdpData; ///< USBDP internal module data
   \                     ??usbdpData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     57          
     58          //-------------------------------------------------------------------------------------------------------
     59          // String descriptors (2-byte unicode data).
     60          
     61          // Language ID.

   \                                 In  segment XDATA_ROM_C, align 1
     62          static const uint8 languageId[4] = {
   \                     ??languageId:
   \   000000   04           DB 4
   \   000001   03           DB 3
   \   000002   09           DB 9
   \   000003   04           DB 4
     63            4,
     64            DESC_TYPE_STRING,
     65            0x09, 0x04  /* US-EN */
     66          };
     67          
     68          // Manufacturer.

   \                                 In  segment XDATA_ROM_C, align 1
     69          static const uint8 manufacturer[36] = {
   \                     ??manufacturer:
   \   000000   24           DB 36
   \   000001   03           DB 3
   \   000002   54           DB 84
   \   000003   00           DB 0
   \   000004   65           DB 101
   \   000005   00           DB 0
   \   000006   78           DB 120
   \   000007   00           DB 0
   \   000008   61           DB 97
   \   000009   00           DB 0
   \   00000A   73           DB 115
   \   00000B   00           DB 0
   \   00000C   20           DB 32
   \   00000D   00           DB 0
   \   00000E   49           DB 73
   \   00000F   00           DB 0
   \   000010   6E           DB 110
   \   000011   00           DB 0
   \   000012   73           DB 115
   \   000013   00           DB 0
   \   000014   74           DB 116
   \   000015   00           DB 0
   \   000016   72           DB 114
   \   000017   00           DB 0
   \   000018   75           DB 117
   \   000019   00           DB 0
   \   00001A   6D           DB 109
   \   00001B   00           DB 0
   \   00001C   65           DB 101
   \   00001D   00           DB 0
   \   00001E   6E           DB 110
   \   00001F   00           DB 0
   \   000020   74           DB 116
   \   000021   00           DB 0
   \   000022   73           DB 115
   \   000023   00           DB 0
     70            36,
     71            DESC_TYPE_STRING,
     72            'T', 0,
     73            'e', 0,
     74            'x', 0,
     75            'a', 0,
     76            's', 0,
     77            ' ', 0,
     78            'I', 0,
     79            'n', 0,
     80            's', 0,
     81            't', 0,
     82            'r', 0,
     83            'u', 0,
     84            'm', 0,
     85            'e', 0,
     86            'n', 0,
     87            't', 0,
     88            's', 0
     89          };
     90          
     91          // Product.
     92          #if defined HAL_SB_BOOT_CODE

   \                                 In  segment XDATA_ROM_C, align 1
     93          static const uint8 product[36] = {
   \                     ??product:
   \   000000   24           DB 36
   \   000001   03           DB 3
   \   000002   54           DB 84
   \   000003   00           DB 0
   \   000004   49           DB 73
   \   000005   00           DB 0
   \   000006   20           DB 32
   \   000007   00           DB 0
   \   000008   43           DB 67
   \   000009   00           DB 0
   \   00000A   43           DB 67
   \   00000B   00           DB 0
   \   00000C   32           DB 50
   \   00000D   00           DB 0
   \   00000E   35           DB 53
   \   00000F   00           DB 0
   \   000010   33           DB 51
   \   000011   00           DB 0
   \   000012   31           DB 49
   \   000013   00           DB 0
   \   000014   20           DB 32
   \   000015   00           DB 0
   \   000016   55           DB 85
   \   000017   00           DB 0
   \   000018   53           DB 83
   \   000019   00           DB 0
   \   00001A   42           DB 66
   \   00001B   00           DB 0
   \   00001C   20           DB 32
   \   00001D   00           DB 0
   \   00001E   4D           DB 77
   \   00001F   00           DB 0
   \   000020   53           DB 83
   \   000021   00           DB 0
   \   000022   44           DB 68
   \   000023   00           DB 0
     94            36,
     95            DESC_TYPE_STRING,
     96            'T', 0,
     97            'I', 0,
     98            ' ', 0,
     99            'C', 0,
    100            'C', 0,
    101            '2', 0,
    102            '5', 0,
    103            '3', 0,
    104            '1', 0,
    105            ' ', 0,
    106            'U', 0,
    107            'S', 0,
    108            'B', 0,
    109            ' ', 0,
    110            'M', 0,
    111            'S', 0,
    112            'D', 0
    113          };
    114          #else
    115          static const uint8 product[36] = {
    116            36,
    117            DESC_TYPE_STRING,
    118            'T', 0,
    119            'I', 0,
    120            ' ', 0,
    121            'C', 0,
    122            'C', 0,
    123            '2', 0,
    124            '5', 0,
    125            '3', 0,
    126            '1', 0,
    127            ' ', 0,
    128            'U', 0,
    129            'S', 0,
    130            'B', 0,
    131            ' ', 0,
    132            'C', 0,
    133            'D', 0,
    134            'C', 0
    135          };
    136          #endif
    137          
    138          // Serial Number.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    139          static uint8 serialNumber[42] = {
   \                     ??serialNumber:
   \   000000                DS 42
   \   00002A                REQUIRE `?<Initializer for serialNumber>`
   \   00002A                REQUIRE __INIT_XDATA_I
    140            0,  // Initializing to zero vice 42 is the indication to usbdpGetStringDesc() to fill w/ IEEE.
    141            DESC_TYPE_STRING,
    142            // Setup for using the 16 nibbles of the hex representation of the IEEE address.
    143            '_', 0,
    144            '_', 0,
    145            '0', 0,
    146            'X', 0,
    147          };
    148          

   \                                 In  segment XDATA_ROM_C, align 1
    149          const uint8 hexDigit[16] = {
   \                     hexDigit:
   \   000000   30           DB 48
   \   000001   31           DB 49
   \   000002   32           DB 50
   \   000003   33           DB 51
   \   000004   34           DB 52
   \   000005   35           DB 53
   \   000006   36           DB 54
   \   000007   37           DB 55
   \   000008   38           DB 56
   \   000009   39           DB 57
   \   00000A   41           DB 65
   \   00000B   42           DB 66
   \   00000C   43           DB 67
   \   00000D   44           DB 68
   \   00000E   45           DB 69
   \   00000F   46           DB 70
    150            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
    151          
    152          /** \brief	Initializes a search
    153          *
    154          * This function must be called before each new search to reset \ref USBDP_DATA.pDesc.
    155          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    156          void usbdpInit(void)
   \                     usbdpInit:
    157          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    158             usbdpData.pDesc = (const uint8 __code *) usbDescriptorMarker.pUsbDescStart;
   \   000004   90....       MOV     DPTR,#usbDescriptorMarker
   \   000007   12....       LCALL   ??Subroutine24_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   00000A   90....       MOV     DPTR,#??usbdpData
   \   00000D   E8           MOV     A,R0
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   E9           MOV     A,R1
   \   000011   02....       LJMP    ??Subroutine25_0 & 0xFFFF
    159          } // usbdpInit
    160          
    161          
    162          
    163          
    164          /** \brief	Locates the descriptor of the wanted type
    165          *
    166          * This function parses through the USB descriptors until:
    167          * \li It hits one with <tt>bDescriptorType = wantedType</tt>, in which case it returns a pointer to
    168          *     that descriptor, and exits. \ref USBDP_DATA.pDesc will then point to the next descriptor.
    169          * \li It hits one with <tt>bDescriptorType = haltAtType</tt>, in which case it returns a NULL-pointer,
    170          *     and exits. \ref USBDP_DATA.pDesc will then point to that descriptor.
    171          * \li \ref USBDP_DATA.pDesc = \ref usbDescEnd, in which case it returns a NULL-pointer, and exits.
    172          *     \ref USBDP_DATA.pDesc will continue to point to \ref usbDescEnd.
    173          *
    174          * \note To begin a search with this function, \ref usbdpInit should be called first. It should not be
    175          *       called when continuing a search - for instance after a call to \ref usbdpGetConfigurationDesc().
    176          *
    177          * \param[in]       wantedType
    178          *     The wanted descriptor type (e.g. \ref DESC_TYPE_CONFIG)
    179          * \param[in]       haltAtType
    180          *     The parser halts when it reaches this descriptor type, unless \c haltAtType is \c 0 (which in any
    181          *     case is an invalid \c bDescriptorType value).
    182          *
    183          * \return
    184          *     A pointer to the wanted descriptor type, or \c NULL if it was not found.
    185          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    186          void __code* usbdpFindNext(uint8 wantedType, uint8 haltAtType)
   \                     usbdpFindNext:
    187          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   FC           MOV     R4,A
   \   000006   EA           MOV     A,R2
   \   000007   FD           MOV     R5,A
    188             void __code *pResult;
    189             pResult = NULL;
   \   000008   7A00         MOV     R2,#0x0
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   8003         SJMP    ??CrossCallReturnLabel_2
    190          
    191             // As long as we haven't reached the end...
    192             while (usbdpData.pDesc != (void __code *) usbDescriptorMarker.pUsbDescEnd) {
    193          
    194                // If we have a match on wantedType...
    195                if (usbdpData.pDesc[DESC_TYPE_IDX] == wantedType) {
    196                   pResult = (void __code*) usbdpData.pDesc;
    197                   usbdpData.pDesc += usbdpData.pDesc[DESC_LENGTH_IDX];
    198                   break;
    199          
    200                // If we have a match on haltAtType...
    201                } else if (usbdpData.pDesc[DESC_TYPE_IDX] == haltAtType) {
    202                   if (haltAtType) break;
    203                }
    204          
    205                // Move on to the next descriptor
    206                usbdpData.pDesc += usbdpData.pDesc[DESC_LENGTH_IDX];
   \                     ??usbdpFindNext_0:
   \   00000E   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000011   90....       MOV     DPTR,#??usbdpData
   \   000014   12....       LCALL   ??Subroutine24_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000017   90....       MOV     DPTR,#usbDescriptorMarker + 2
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   68           XRL     A,R0
   \   00001C   7003         JNZ     ??usbdpFindNext_1
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   69           XRL     A,R1
   \                     ??usbdpFindNext_1:
   \   000021   6022         JZ      ??usbdpFindNext_2
   \   000023   90....       MOV     DPTR,#??usbdpData + 1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F583         MOV     DPH,A
   \   000029   8882         MOV     DPL,R0
   \   00002B   A3           INC     DPTR
   \   00002C   E4           CLR     A
   \   00002D   93           MOVC    A,@A+DPTR
   \   00002E   F8           MOV     R0,A
   \   00002F   EC           MOV     A,R4
   \   000030   68           XRL     A,R0
   \   000031   700B         JNZ     ??usbdpFindNext_3
   \   000033   90....       MOV     DPTR,#??usbdpData
   \   000036   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000039   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00003C   8007         SJMP    ??usbdpFindNext_2
   \                     ??usbdpFindNext_3:
   \   00003E   ED           MOV     A,R5
   \   00003F   68           XRL     A,R0
   \   000040   70CC         JNZ     ??usbdpFindNext_0
   \   000042   ED           MOV     A,R5
   \   000043   60C9         JZ      ??usbdpFindNext_0
    207             }
    208          
    209             return pResult;
   \                     ??usbdpFindNext_2:
   \   000045   80..         SJMP    ??Subroutine26_0
    210          } // usbdpFindNext

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   90....       MOV     DPTR,#??usbdpData
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F583         MOV     DPH,A
   \   000009   8882         MOV     DPL,R0
   \   00000B   E4           CLR     A
   \   00000C   93           MOVC    A,@A+DPTR
   \   00000D   F8           MOV     R0,A
   \   00000E   90....       MOV     DPTR,#??usbdpData
   \   000011   E0           MOVX    A,@DPTR
   \   000012   28           ADD     A,R0
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   3400         ADDC    A,#0x0
   \   000018   F9           MOV     R1,A
   \   000019   90....       MOV     DPTR,#??usbdpData
   \   00001C   E8           MOV     A,R0
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   E9           MOV     A,R1
   \   000020   F0           MOVX    @DPTR,A
   \   000021   22           RET
    211          
    212          
    213          
    214          
    215          /** \brief	Locates the (one and only) device descriptor
    216          *
    217          * \note It is not necessary to call \ref usbdpInit() before this function.
    218          *
    219          * \return
    220          *     A pointer to the \ref USB_DEVICE_DESCRIPTOR, or \c NULL if it was not found.
    221          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    222          USB_DEVICE_DESCRIPTOR __code* usbdpGetDeviceDesc(void)
   \                     usbdpGetDeviceDesc:
    223          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    224             usbdpInit();
   \   000004   12....       LCALL   ?Subroutine10 & 0xFFFF
    225             return usbdpFindNext(DESC_TYPE_DEVICE, 0);
   \                     ??CrossCallReturnLabel_7:
   \   000007                ; Setup parameters for call to function usbdpFindNext
   \   000007   7A00         MOV     R2,#0x0
   \   000009   7901         MOV     R1,#0x1
   \   00000B   12....       LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
   \   00000E   80..         SJMP    ??Subroutine26_0
    226          } // usbdpGetDeviceDesc
    227          
    228          
    229          
    230          
    231          /** \brief	Locates a configuration descriptor
    232          *
    233          * The search will either look for a descriptor with a specific
    234          * \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue, or simply take the n'th descriptor (by "index")
    235          *
    236          * \note It is not necessary to call \ref usbdpInit() before this function.
    237          *
    238          * \param[in]       cfgValue
    239          *     The configuration value to search for (\ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue), or
    240          *     0 to find descriptor by index
    241          * \param[in]       cfgIndex
    242          *     A zero-based index for the configuration descriptor to find.
    243          *     This value is ignored unless \c cfgValue is 0.
    244          *
    245          * \return
    246          *     A pointer to the \ref USB_DEVICE_DESCRIPTOR, or \c NULL if it was not found.
    247          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    248          USB_CONFIGURATION_DESCRIPTOR __code* usbdpGetConfigurationDesc(uint8 cfgValue, uint8 cfgIndex)
   \                     usbdpGetConfigurationDesc:
    249          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FF           MOV     R7,A
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
    250             USB_CONFIGURATION_DESCRIPTOR __code *pConfigurationDesc;
    251             usbdpInit();
   \   000009   12....       LCALL   ?Subroutine10 & 0xFFFF
    252          
    253             // As long as there are more configuration descriptors...
    254             while (pConfigurationDesc = usbdpFindNext(DESC_TYPE_CONFIG, 0)) {
   \                     ??CrossCallReturnLabel_8:
   \   00000C                ; Setup parameters for call to function usbdpFindNext
   \   00000C   7A00         MOV     R2,#0x0
   \   00000E   7902         MOV     R1,#0x2
   \   000010   12....       LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
   \   000013   EA           MOV     A,R2
   \   000014   4B           ORL     A,R3
   \   000015   601C         JZ      ??usbdpGetConfigurationDesc_0
    255          
    256                // Search by value?
    257                if (cfgValue) {
   \   000017   EF           MOV     A,R7
   \   000018   6010         JZ      ??usbdpGetConfigurationDesc_1
    258                   if (cfgValue == pConfigurationDesc->bConfigurationValue) break;
   \   00001A   8A82         MOV     DPL,R2
   \   00001C   8B83         MOV     DPH,R3
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E4           CLR     A
   \   000024   93           MOVC    A,@A+DPTR
   \   000025   6F           XRL     A,R7
   \   000026   70E4         JNZ     ??CrossCallReturnLabel_8
   \   000028   8009         SJMP    ??usbdpGetConfigurationDesc_0
    259          
    260                // Search by index? (search cfgIndex+1 times)
    261                } else if (!cfgIndex--) {
   \                     ??usbdpGetConfigurationDesc_1:
   \   00002A   EE           MOV     A,R6
   \   00002B   F8           MOV     R0,A
   \   00002C   74FF         MOV     A,#-0x1
   \   00002E   28           ADD     A,R0
   \   00002F   FE           MOV     R6,A
   \   000030   04           INC     A
   \   000031   70D9         JNZ     ??CrossCallReturnLabel_8
    262                   break;
    263                }
    264             }
    265          
    266             return pConfigurationDesc;
   \                     ??usbdpGetConfigurationDesc_0:
   \   000033   02....       LJMP    ??Subroutine23_0 & 0xFFFF
    267          } // usbdpGetConfigurationDesc
    268          
    269          
    270          
    271          
    272          /** \brief	Locates an interface descriptor
    273          *
    274          * The function will first go to the configuration descriptor that matches the supplied configuration
    275          * value, and then locate the interface descriptor that matches the given interface number and alternate
    276          * setting.
    277          *
    278          * \note It is not necessary to call \ref usbdpInit() before this function.
    279          *
    280          * \param[in]       cfgValue
    281          *     The configuration value (\ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue)
    282          * \param[in]       intNumber
    283          *     The interface number (\ref USB_INTERFACE_DESCRIPTOR.bInterfaceNumber)
    284          * \param[in]       altSetting
    285          *     The alternate setting (\ref USB_INTERFACE_DESCRIPTOR.bAlternateSetting)
    286          *
    287          * \return
    288          *     A pointer to the \ref USB_INTERFACE_DESCRIPTOR, or \c NULL if it was not found.
    289          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    290          USB_INTERFACE_DESCRIPTOR __code* usbdpGetInterfaceDesc(uint8 cfgValue, uint8 intNumber, uint8 altSetting)
   \                     usbdpGetInterfaceDesc:
    291          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FF           MOV     R7,A
   \   000007   8B..         MOV     ?V0,R3
    292             USB_INTERFACE_DESCRIPTOR __code *pInterfaceDesc;
    293          
    294             // First get to the correct configuration
    295             usbdpGetConfigurationDesc(cfgValue, 0);
   \   000009                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   12....       LCALL   `??usbdpGetConfigurationDesc::?relay`; Banked call to: usbdpGetConfigurationDesc
    296          
    297             // Then find a match on the interface
    298             while (pInterfaceDesc = usbdpFindNext(DESC_TYPE_INTERFACE, DESC_TYPE_CONFIG)) {
   \                     ??usbdpGetInterfaceDesc_0:
   \   00000E                ; Setup parameters for call to function usbdpFindNext
   \   00000E   7A02         MOV     R2,#0x2
   \   000010   7904         MOV     R1,#0x4
   \   000012   12....       LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
   \   000015   EA           MOV     A,R2
   \   000016   4B           ORL     A,R3
   \   000017   6018         JZ      ??usbdpGetInterfaceDesc_1
    299                if ((pInterfaceDesc->bInterfaceNumber == intNumber) && (pInterfaceDesc->bAlternateSetting == altSetting)) {
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E4           CLR     A
   \   000020   93           MOVC    A,@A+DPTR
   \   000021   6F           XRL     A,R7
   \   000022   70EA         JNZ     ??usbdpGetInterfaceDesc_0
   \   000024   8A82         MOV     DPL,R2
   \   000026   8B83         MOV     DPH,R3
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   E4           CLR     A
   \   00002C   93           MOVC    A,@A+DPTR
   \   00002D   65..         XRL     A,?V0
   \   00002F   70DD         JNZ     ??usbdpGetInterfaceDesc_0
    300                   break;
    301                }
    302             }
    303          
    304             return pInterfaceDesc;
   \                     ??usbdpGetInterfaceDesc_1:
   \   000031   02....       LJMP    ?Subroutine3 & 0xFFFF
    305          } // usbdpGetInterfaceDesc
    306          
    307          
    308          
    309          
    310          /** \brief	Locates a string descriptor
    311          *
    312          * \note It is not necessary to call \ref usbdpInit() before this function.
    313          *
    314          * \param[in]       strIndex
    315          *     A zero-based index that matches the "iXxxxxxxxxx" string indexes in the other descriptors
    316          *
    317          * \return
    318          *     A pointer to the \ref USB_INTERFACE_DESCRIPTOR, or \c NULL if it was not found.
    319          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    320          USB_STRING_DESCRIPTOR* usbdpGetStringDesc(uint8 strIndex)
   \                     usbdpGetStringDesc:
    321          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
    322            USB_STRING_DESCRIPTOR *pStringDesc = NULL;
   \   00000B   7A00         MOV     R2,#0x0
   \   00000D   7B00         MOV     R3,#0x0
    323          
    324          #ifdef MS_EXT_C_ID
    325            /* TODO: Find the Microsoft OS String Descriptor?
    326            usbdpInit();
    327          
    328            if (strIndex == 0xEE){
    329              // Find the Microsoft OS String Descriptor
    330              do{
    331                pStringDesc = usbdpFindNext(DESC_TYPE_STRING, 0);
    332              }while (pStringDesc != NULL && pStringDesc->bLength != 18);
    333            } else
    334            */
    335          #endif
    336            {
    337              switch (strIndex)
   \   00000F   600B         JZ      ??usbdpGetStringDesc_0
   \   000011   14           DEC     A
   \   000012   600E         JZ      ??usbdpGetStringDesc_1
   \   000014   14           DEC     A
   \   000015   6011         JZ      ??usbdpGetStringDesc_2
   \   000017   14           DEC     A
   \   000018   6014         JZ      ??usbdpGetStringDesc_3
   \   00001A   8078         SJMP    ??usbdpGetStringDesc_4
    338              {
    339              case 0:
    340                pStringDesc = (USB_STRING_DESCRIPTOR *)languageId;
   \                     ??usbdpGetStringDesc_0:
   \   00001C   7A..         MOV     R2,#??languageId & 0xff
   \   00001E   7B..         MOV     R3,#(??languageId >> 8) & 0xff
    341                break;
   \   000020   8072         SJMP    ??usbdpGetStringDesc_4
    342          
    343              case 1:
    344                pStringDesc = (USB_STRING_DESCRIPTOR *)manufacturer;
   \                     ??usbdpGetStringDesc_1:
   \   000022   7A..         MOV     R2,#??manufacturer & 0xff
   \   000024   7B..         MOV     R3,#(??manufacturer >> 8) & 0xff
    345                break;
   \   000026   806C         SJMP    ??usbdpGetStringDesc_4
    346          
    347              case 2:
    348                pStringDesc = (USB_STRING_DESCRIPTOR *)product;
   \                     ??usbdpGetStringDesc_2:
   \   000028   7A..         MOV     R2,#??product & 0xff
   \   00002A   7B..         MOV     R3,#(??product >> 8) & 0xff
    349                break;
   \   00002C   8066         SJMP    ??usbdpGetStringDesc_4
    350          
    351              case 3:
    352                if (serialNumber[0] == 0)
   \                     ??usbdpGetStringDesc_3:
   \   00002E   90....       MOV     DPTR,#??serialNumber
   \   000031   E0           MOVX    A,@DPTR
   \   000032   705C         JNZ     ??usbdpGetStringDesc_5
    353                {
    354          #if (defined HAL_SB_BOOT_CODE || defined CC253X_MACNP || defined CC2531DK)
    355                  #include <string.h>
    356                  uint8 aExtendedAddress[HAL_FLASH_IEEE_SIZE] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
   \   000034   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
   \   000037   AC..         MOV     R4,?XSP + 0
   \   000039   AD..         MOV     R5,?XSP + 1
   \   00003B   7408         MOV     A,#0x8
   \   00003D   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    357                  /*
    358                  uint8 nullAddr[HAL_FLASH_IEEE_SIZE] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    359                  uint8 aExtendedAddress[HAL_FLASH_IEEE_SIZE];
    360          
    361                  // Attempt to read the extended address from the location on the lock bits page
    362                  // where the programming tools know to reserve it.
    363                  HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_IEEE_OSET,
    364                                  aExtendedAddress, HAL_FLASH_IEEE_SIZE);
    365          
    366                  if (!memcmp(aExtendedAddress, nullAddr, HAL_FLASH_IEEE_SIZE))
    367                  {
    368                    // Attempt to read the extended address from the designated location in the Info Page.
    369                    memcpy(aExtendedAddress, (uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), HAL_FLASH_IEEE_SIZE);
    370                  }
    371                   */
    372          #endif
    373                  // Load the 16 nibbles of the hex representation of the IEEE address into the serialNumber
    374                  // string in big-endian (i.e. human-readable) order.
    375                  for (uint8 idx = sizeof(serialNumber)-2, cnt=0; cnt < HAL_FLASH_IEEE_SIZE; cnt++, idx -= 4)
   \   000040   7C28         MOV     R4,#0x28
   \   000042   7D00         MOV     R5,#0x0
    376                  {
    377                    serialNumber[idx]   = hexDigit[aExtendedAddress[cnt] & 0x0F];
   \                     ??usbdpGetStringDesc_6:
   \   000044   ED           MOV     A,R5
   \   000045   F8           MOV     R0,A
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   E582         MOV     A,DPL
   \   00004E   28           ADD     A,R0
   \   00004F   F582         MOV     DPL,A
   \   000051   E4           CLR     A
   \   000052   3583         ADDC    A,DPH
   \   000054   F583         MOV     DPH,A
   \   000056   E0           MOVX    A,@DPTR
   \   000057   FF           MOV     R7,A
   \   000058   EC           MOV     A,R4
   \   000059   F8           MOV     R0,A
   \   00005A   74..         MOV     A,#??serialNumber & 0xff
   \   00005C   28           ADD     A,R0
   \   00005D   F8           MOV     R0,A
   \   00005E   E4           CLR     A
   \   00005F   34..         ADDC    A,#(??serialNumber >> 8) & 0xff
   \   000061   F9           MOV     R1,A
   \   000062   EF           MOV     A,R7
   \   000063   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000066   8882         MOV     DPL,R0
   \   000068   8983         MOV     DPH,R1
   \   00006A   F0           MOVX    @DPTR,A
    378                    serialNumber[idx-2] = hexDigit[aExtendedAddress[cnt] / 16];
   \   00006B   EF           MOV     A,R7
   \   00006C   C4           SWAP    A
   \   00006D   12....       LCALL   ?Subroutine5 & 0xFFFF
    379                  }
   \                     ??CrossCallReturnLabel_1:
   \   000070   C0E0         PUSH    A
   \   000072   E8           MOV     A,R0
   \   000073   24FE         ADD     A,#-0x2
   \   000075   F582         MOV     DPL,A
   \   000077   E9           MOV     A,R1
   \   000078   34FF         ADDC    A,#-0x1
   \   00007A   F583         MOV     DPH,A
   \   00007C   D0E0         POP     A
   \   00007E   F0           MOVX    @DPTR,A
   \   00007F   0D           INC     R5
   \   000080   74FC         MOV     A,#-0x4
   \   000082   2C           ADD     A,R4
   \   000083   FC           MOV     R4,A
   \   000084   ED           MOV     A,R5
   \   000085   C3           CLR     C
   \   000086   9408         SUBB    A,#0x8
   \   000088   40BA         JC      ??usbdpGetStringDesc_6
    380                  serialNumber[0] = sizeof(serialNumber);
   \   00008A   90....       MOV     DPTR,#??serialNumber
   \   00008D   742A         MOV     A,#0x2a
   \   00008F   F0           MOVX    @DPTR,A
    381                }
    382                pStringDesc = (USB_STRING_DESCRIPTOR *)serialNumber;
   \                     ??usbdpGetStringDesc_5:
   \   000090   7A..         MOV     R2,#??serialNumber & 0xff
   \   000092   7B..         MOV     R3,#(??serialNumber >> 8) & 0xff
    383                break;
    384          
    385              default:
    386                break;
    387              }
    388            }
    389          
    390            return pStringDesc;
   \                     ??usbdpGetStringDesc_4:
   \   000094   7408         MOV     A,#0x8
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   \   000099   02....       LJMP    ?Subroutine4 & 0xFFFF
    391          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   540F         ANL     A,#0xf
   \   000002   FA           MOV     R2,A
   \   000003   74..         MOV     A,#hexDigit & 0xff
   \   000005   2A           ADD     A,R2
   \   000006   F582         MOV     DPL,A
   \   000008   E4           CLR     A
   \   000009   34..         ADDC    A,#(hexDigit >> 8) & 0xff
   \   00000B   F583         MOV     DPH,A
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    392          /// @}
    393          
    394          
C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_framework.c
      1          /******************************************************************************
      2          
      3           @file  usb_framework.c
      4          
      5           @brief USB library common functionality.
      6          
      7           Group: WCS, BTS
      8           Target Device: CC2540, CC2541
      9          
     10           ******************************************************************************
     11           
     12           Copyright (c) 2004-2016, Texas Instruments Incorporated
     13           All rights reserved.
     14          
     15           IMPORTANT: Your use of this Software is limited to those specific rights
     16           granted under the terms of a software license agreement between the user
     17           who downloaded the software, his/her employer (which must be your employer)
     18           and Texas Instruments Incorporated (the "License"). You may not use this
     19           Software unless you agree to abide by the terms of the License. The License
     20           limits your use, and you acknowledge, that the Software may not be modified,
     21           copied or distributed unless embedded on a Texas Instruments microcontroller
     22           or used solely and exclusively in conjunction with a Texas Instruments radio
     23           frequency transceiver, which is integrated into your product. Other than for
     24           the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25           works of, modify, distribute, perform, display or sell this Software and/or
     26           its documentation for any purpose.
     27          
     28           YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29           PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30           INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31           NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32           TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33           NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34           LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35           INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36           OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37           OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38           (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40           Should you have any questions regarding your right to use this Software,
     41           contact Texas Instruments Incorporated at www.TI.com.
     42          
     43           ******************************************************************************
     44           Release Name: ble_sdk_1.4.2.2
     45           Release Date: 2016-06-09 06:57:10
     46           *****************************************************************************/
     47          
     48          /// \addtogroup module_usb_framework
     49          /// @{
     50          #define USBFRAMEWORK_C ///< Modifies the behavior of "EXTERN" in usb_framework.h
     51          #include "usb_firmware_library_headers.h"

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   USBFW_DATA usbfwData
   \                     usbfwData:
   \   000000                DS 20
   \   000014                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   USB_SETUP_DATA usbSetupData
   \                     usbSetupData:
   \   000000                DS 5
   \   000005                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   USB_SETUP_HEADER usbSetupHeader
   \                     usbSetupHeader:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
     52          #include "usb_board_cfg.h"
     53          
     54          // Function pointer used by usbfwSetupHandler()

   \                                 In  segment DATA_Z, align 1, keep-with-next
     55          static VFPTR __data ProcessFunc;
   \                     ??ProcessFunc:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_DATA_Z
     56          
     57          /** \brief Initializes the USB framework
     58           *
     59           * This function should be called when the microcontroller is ready to accept USB traffic. It enables the
     60           * USB peripheral unit and enables the pull-up resistor on the D+ line. Endpoint status, current
     61           * configuration value, etc. are initialized and evenetually re-initialized in the
     62           * \ref usbfwResetHandler() function.
     63           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     64          void usbfwInit(void)
   \                     usbfwInit:
     65          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
     66              // Set default values
     67              usbfwData.selfPowered = (usbdpGetConfigurationDesc(1, 0)->bmAttributes & 0x40) ? TRUE : FALSE;
   \   000005                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   000005   7A00         MOV     R2,#0x0
   \   000007   7901         MOV     R1,#0x1
   \   000009   12....       LCALL   `??usbdpGetConfigurationDesc::?relay`; Banked call to: usbdpGetConfigurationDesc
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E4           CLR     A
   \   000018   93           MOVC    A,@A+DPTR
   \   000019   A2E6         MOV     C,0xE0 /* A   */.6
   \   00001B   90....       MOV     DPTR,#usbfwData + 19
   \   00001E   5004         JNC     ??usbfwInit_0
   \   000020   7401         MOV     A,#0x1
   \   000022   8001         SJMP    ??usbfwInit_1
   \                     ??usbfwInit_0:
   \   000024   E4           CLR     A
   \                     ??usbfwInit_1:
   \   000025   F0           MOVX    @DPTR,A
     68              usbfwData.remoteWakeup = FALSE;
   \   000026   90....       MOV     DPTR,#usbfwData + 18
   \   000029   E4           CLR     A
   \   00002A   F0           MOVX    @DPTR,A
     69          
     70              HAL_USB_ENABLE();
   \   00002B   90620F       MOV     DPTR,#0x620f
   \   00002E   7403         MOV     A,#0x3
   \   000030   F0           MOVX    @DPTR,A
   \                     ??usbfwInit_2:
   \   000031   E0           MOVX    A,@DPTR
   \   000032   A2E7         MOV     C,0xE0 /* A   */.7
   \   000034   50FB         JNC     ??usbfwInit_2
     71          
     72              // Enable Resume Interrupt
     73              HAL_USB_RESUME_INT_ENABLE();
     74          
     75          } // usbfwInit
   \   000036   02....       LJMP    ??Subroutine23_0 & 0xFFFF
     76          
     77          
     78          
     79          
     80          /** \brief Handles USB reset signalling
     81           *
     82           * This function should be called, either from the USB interrupt or the main loop, when the \c USBCIF.RST
     83           * flag has been set. Keep in mind that all bits in \c USBCIF register are cleared when the register is
     84           * read. The function puts the device into the default state (not yet addressed), and puts all endpoints
     85           * (except EP0) into the \ref EP_HALT state
     86           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     87          void usbfwResetHandler(void)
   \                     usbfwResetHandler:
     88          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     89          
     90             // Reset the USB state
     91             usbfwData.usbState = DEV_DEFAULT;
   \   000004   90....       MOV     DPTR,#usbfwData
   \   000007   7402         MOV     A,#0x2
   \   000009   F0           MOVX    @DPTR,A
     92             usbfwData.configurationValue = 0;
   \   00000A   A3           INC     DPTR
   \   00000B   E4           CLR     A
   \   00000C   F0           MOVX    @DPTR,A
     93          
     94             // Reset all endpoints
     95             usbfwData.ep0Status = EP_IDLE;
   \   00000D   90....       MOV     DPTR,#usbfwData + 7
   \   000010   F0           MOVX    @DPTR,A
     96             usbfwSetAllEpStatus(EP_HALT);
   \   000011                ; Setup parameters for call to function usbfwSetAllEpStatus
   \   000011   7903         MOV     R1,#0x3
   \   000013   12....       LCALL   `??usbfwSetAllEpStatus::?relay`; Banked call to: usbfwSetAllEpStatus
     97          
     98             // Reset last function pointer
     99             ProcessFunc = NULL;
   \   000016   75..00       MOV     ??ProcessFunc+0x0,#0x0
   \   000019   75..00       MOV     ??ProcessFunc+0x1,#0x0
    100          
    101          } // usbfwResetHandler
   \   00001C   02....       LJMP    ??Subroutine26_0 & 0xFFFF
    102          
    103          
    104          
    105          
    106          /** \brief USB Setup Handler
    107           *
    108           * This function should be called either from the USB interrupt or the main loop when the \c USBIIF.EP0IF
    109           * flag has been set. Keep in mind that all bits in \c USBIIF register are cleared when the register is
    110           * read. A detailed description of the framework is found in the \ref section_setup_handler_usage
    111           * section.
    112           *
    113           * \note The USB header data is always little-endian, so if a big-endian compiler is used (such as Keil
    114           * C51), the 16-bit values in the \ref usbSetupHeader must be flipped before they are used.
    115           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   90....       MOV     DPTR,#usbSetupData + 3
   \   000003                REQUIRE ??Subroutine24_0
   \   000003                ; // Fall through to label ??Subroutine24_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    116          void usbfwSetupHandler(void)
   \                     usbfwSetupHandler:
    117          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    118             uint8 controlReg;
    119             uint8 bytesNow;
    120             uint8 oldEndpoint;
    121          
    122             // Save the old index setting, then select endpoint 0 and fetch the control register
    123             oldEndpoint = USBFW_GET_SELECTED_ENDPOINT();
   \   000005   90620E       MOV     DPTR,#0x620e
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FE           MOV     R6,A
    124             USBFW_SELECT_ENDPOINT(0);
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
    125             controlReg = USBCS0;
   \   00000C   906211       MOV     DPTR,#0x6211
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FF           MOV     R7,A
    126          
    127             // The last transfer was ended prematurely by a new SETUP packet
    128             if (controlReg & USBCS0_SETUP_END) {
   \   000011   A2E4         MOV     C,0xE0 /* A   */.4
   \   000013   501D         JNC     ??usbfwSetupHandler_0
    129                USBCS0 = USBCS0_CLR_SETUP_END;
   \   000015   7480         MOV     A,#-0x80
   \   000017   F0           MOVX    @DPTR,A
    130                usbfwData.ep0Status = EP_CANCEL;
   \   000018   90....       MOV     DPTR,#usbfwData + 7
   \   00001B   7407         MOV     A,#0x7
   \   00001D   F0           MOVX    @DPTR,A
    131                if (ProcessFunc) ProcessFunc();
   \   00001E   E5..         MOV     A,??ProcessFunc+0x0
   \   000020   45..         ORL     A,??ProcessFunc+0x1
   \   000022   6009         JZ      ??usbfwSetupHandler_1
   \   000024                ; Setup parameters for indirect call
   \   000024   85..82       MOV     DPL,??ProcessFunc+0x0
   \   000027   85..83       MOV     DPH,??ProcessFunc+0x1
   \   00002A   12....       LCALL   ?CALL_IND
    132                usbfwData.ep0Status = EP_IDLE;
   \                     ??usbfwSetupHandler_1:
   \   00002D   90....       MOV     DPTR,#usbfwData + 7
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
    133             }
    134          
    135             // A STALL handshake was transmitted to the PC
    136             if (controlReg & USBCS0_SENT_STALL) {
   \                     ??usbfwSetupHandler_0:
   \   000032   EF           MOV     A,R7
   \   000033   A2E2         MOV     C,0xE0 /* A   */.2
   \   000035   500B         JNC     ??usbfwSetupHandler_2
    137                USBCS0 = 0x00;
   \   000037   906211       MOV     DPTR,#0x6211
   \   00003A   E4           CLR     A
   \   00003B   F0           MOVX    @DPTR,A
    138                usbfwData.ep0Status = EP_IDLE;
   \   00003C   90....       MOV     DPTR,#usbfwData + 7
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   8064         SJMP    ??usbfwSetupHandler_3
    139             }
    140          
    141             // Receive OUT packets
    142             if (usbfwData.ep0Status == EP_RX) {
   \                     ??usbfwSetupHandler_2:
   \   000042   90....       MOV     DPTR,#usbfwData + 7
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   7402         MOV     A,#0x2
   \   000049   68           XRL     A,R0
   \   00004A   7043         JNZ     ??usbfwSetupHandler_4
    143          
    144                // Read FIFO
    145                bytesNow = USBCNT0;
   \   00004C   906216       MOV     DPTR,#0x6216
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   FF           MOV     R7,A
    146                usbfwReadFifo(&USBF0, bytesNow, usbSetupData.pBuffer);
   \   000051                ; Setup parameters for call to function usbfwReadFifo
   \   000051   90....       MOV     DPTR,#usbSetupData
   \   000054   12....       LCALL   ?PUSH_XSTACK8_X_THREE
   \   000057   EF           MOV     A,R7
   \   000058   F9           MOV     R1,A
   \   000059   7A20         MOV     R2,#0x20
   \   00005B   7B62         MOV     R3,#0x62
   \   00005D   12....       LCALL   `??usbfwReadFifo::?relay`; Banked call to: usbfwReadFifo
   \   000060   7403         MOV     A,#0x3
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
    147                usbSetupData.bytesLeft -= bytesNow;
   \   000065   EF           MOV     A,R7
   \   000066   F8           MOV     R0,A
   \   000067   90....       MOV     DPTR,#usbSetupData + 3
   \   00006A   12....       LCALL   ?Subroutine15 & 0xFFFF
    148                usbSetupData.pBuffer += bytesNow;
   \                     ??CrossCallReturnLabel_16:
   \   00006D   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000070   E9           MOV     A,R1
   \   000071   2F           ADD     A,R7
   \   000072   12....       LCALL   ?Subroutine19 & 0xFFFF
    149          
    150                // Arm the endpoint
    151                USBCS0 = usbSetupData.bytesLeft ? USBCS0_CLR_OUTPKT_RDY : (USBCS0_CLR_OUTPKT_RDY | USBCS0_DATA_END);
   \                     ??CrossCallReturnLabel_24:
   \   000075   A3           INC     DPTR
   \   000076   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000079   6004         JZ      ??usbfwSetupHandler_5
   \   00007B   7440         MOV     A,#0x40
   \   00007D   8002         SJMP    ??usbfwSetupHandler_6
   \                     ??usbfwSetupHandler_5:
   \   00007F   7448         MOV     A,#0x48
   \                     ??usbfwSetupHandler_6:
   \   000081   906211       MOV     DPTR,#0x6211
   \   000084   F0           MOVX    @DPTR,A
    152          
    153                // Make a call to the appropriate request handler when done
    154                if (usbSetupData.bytesLeft == 0) {
   \   000085   E8           MOV     A,R0
   \   000086   49           ORL     A,R1
   \   000087   6003         JZ      $+5
   \   000089   02....       LJMP    ??usbfwSetupHandler_7 & 0xFFFF
   \   00008C   02....       LJMP    ??usbfwSetupHandler_8 & 0xFFFF
    155                   if (ProcessFunc) ProcessFunc();
    156                   usbfwData.ep0Status = EP_IDLE;
    157                }
    158          
    159                // Return here since nothing more will happen until the next interrupt
    160                USBFW_SELECT_ENDPOINT(oldEndpoint);
    161                return;
    162          
    163             // Let the application handle the reception
    164             } else if (usbfwData.ep0Status == EP_MANUAL_RX) {
   \                     ??usbfwSetupHandler_4:
   \   00008F   7406         MOV     A,#0x6
   \   000091   68           XRL     A,R0
   \   000092   7009         JNZ     ??usbfwSetupHandler_9
    165                ProcessFunc();
   \   000094                ; Setup parameters for indirect call
   \   000094   85..82       MOV     DPL,??ProcessFunc+0x0
   \   000097   85..83       MOV     DPH,??ProcessFunc+0x1
   \   00009A   12....       LCALL   ?CALL_IND
    166             }
    167          
    168             // Receive SETUP header
    169             if (usbfwData.ep0Status == EP_IDLE) {
   \                     ??usbfwSetupHandler_9:
   \   00009D   90....       MOV     DPTR,#usbfwData + 7
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   6003         JZ      $+5
   \   0000A3   02....       LJMP    ??usbfwSetupHandler_10 & 0xFFFF
    170                if (controlReg & USBCS0_OUTPKT_RDY) {
   \                     ??usbfwSetupHandler_3:
   \   0000A6   EF           MOV     A,R7
   \   0000A7   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000A9   4003         JC      $+5
   \   0000AB   02....       LJMP    ??usbfwSetupHandler_7 & 0xFFFF
    171                   usbfwReadFifo(&USBF0, 8, (uint8 __xdata *) &usbSetupHeader);
   \   0000AE                ; Setup parameters for call to function usbfwReadFifo
   \   0000AE   75....       MOV     ?V0,#usbSetupHeader & 0xff
   \   0000B1   75....       MOV     ?V1,#(usbSetupHeader >> 8) & 0xff
   \   0000B4   75..00       MOV     ?V2,#0x0
   \   0000B7   78..         MOV     R0,#?V0
   \   0000B9   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000BC   7908         MOV     R1,#0x8
   \   0000BE   7A20         MOV     R2,#0x20
   \   0000C0   7B62         MOV     R3,#0x62
   \   0000C2   12....       LCALL   `??usbfwReadFifo::?relay`; Banked call to: usbfwReadFifo
   \   0000C5   7403         MOV     A,#0x3
   \   0000C7   12....       LCALL   ?DEALLOC_XSTACK8
    172          
    173                   // Handle control transfers individually
    174                   ProcessFunc = NULL;
   \   0000CA   75..00       MOV     ??ProcessFunc+0x0,#0x0
   \   0000CD   75..00       MOV     ??ProcessFunc+0x1,#0x0
    175                   switch (usbSetupHeader.requestType & (RT_MASK_TYPE | RT_MASK_DIR)) {
   \   0000D0   90....       MOV     DPTR,#usbSetupHeader
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   54E0         ANL     A,#0xe0
   \   0000D6   601D         JZ      ??usbfwSetupHandler_11
   \   0000D8   24E0         ADD     A,#-0x20
   \   0000DA   7003         JNZ     $+5
   \   0000DC   02....       LJMP    ??usbfwSetupHandler_12 & 0xFFFF
   \   0000DF   24E0         ADD     A,#-0x20
   \   0000E1   6072         JZ      ??usbfwSetupHandler_13
   \   0000E3   24C0         ADD     A,#-0x40
   \   0000E5   6048         JZ      ??usbfwSetupHandler_14
   \   0000E7   24E0         ADD     A,#-0x20
   \   0000E9   7003         JNZ     $+5
   \   0000EB   02....       LJMP    ??usbfwSetupHandler_15 & 0xFFFF
   \   0000EE   24E0         ADD     A,#-0x20
   \   0000F0   606E         JZ      ??usbfwSetupHandler_16
   \   0000F2   02....       LJMP    ??usbfwSetupHandler_17 & 0xFFFF
    176          
    177                      // Standard requests with data from the host (OUT)
    178                   case RT_STD_OUT:
    179                      switch (usbSetupHeader.request) {
   \                     ??usbfwSetupHandler_11:
   \   0000F5   A3           INC     DPTR
   \   0000F6   E0           MOVX    A,@DPTR
   \   0000F7   14           DEC     A
   \   0000F8   6026         JZ      ??usbfwSetupHandler_18
   \   0000FA   24FE         ADD     A,#-0x2
   \   0000FC   601D         JZ      ??usbfwSetupHandler_19
   \   0000FE   24FE         ADD     A,#-0x2
   \   000100   600A         JZ      ??usbfwSetupHandler_20
   \   000102   24FC         ADD     A,#-0x4
   \   000104   601F         JZ      ??usbfwSetupHandler_21
   \   000106   24FE         ADD     A,#-0x2
   \   000108   6020         JZ      ??usbfwSetupHandler_22
   \   00010A   8075         SJMP    ??usbfwSetupHandler_17
    180                      case SET_ADDRESS:       usbsrSetAddress(); break;
   \                     ??usbfwSetupHandler_20:
   \   00010C                ; Setup parameters for call to function usbsrSetAddress
   \   00010C   12....       LCALL   `??usbsrSetAddress::?relay`; Banked call to: usbsrSetAddress
    181                      case SET_FEATURE:       usbsrSetFeature(); break;
    182                      case CLEAR_FEATURE:     usbsrClearFeature(); break;
    183                      case SET_CONFIGURATION: usbsrSetConfiguration(); break;
    184                      case SET_INTERFACE:     usbsrSetInterface(); break;
    185                      case SET_DESCRIPTOR:    /*usbsrHookSetDescriptor(); break; - unsupported */
    186                      default:                usbfwData.ep0Status = EP_STALL; break;
    187                      }
    188                      break;
    189          
    190                      // Standard requests with data to the host (IN)
    191                   case RT_STD_IN:
    192                      switch (usbSetupHeader.request) {
    193                      case GET_STATUS:        usbsrGetStatus(); break;
    194                      case GET_DESCRIPTOR:    usbsrGetDescriptor(); break;
    195                      case GET_CONFIGURATION: usbsrGetConfiguration(); break;
    196                      case GET_INTERFACE:     usbsrGetInterface(); break;
    197                      case SYNCH_FRAME:       /*usbsrHookSynchFrame(); break; - unsupported */
    198                      default:                usbfwData.ep0Status = EP_STALL; break;
    199                      }
    200                      break;
    201          
    202                      // Vendor requests
    203                   case RT_VEND_OUT:
    204                      ProcessFunc = usbvrHookProcessOut; usbvrHookProcessOut();
    205                      break;
    206                   case RT_VEND_IN:
    207                      ProcessFunc = usbvrHookProcessIn; usbvrHookProcessIn();
    208                      break;
    209          
    210                      // Class requests
    211                   case RT_CLASS_OUT:
    212                      ProcessFunc = usbcrHookProcessOut; usbcrHookProcessOut();
    213                      break;
    214                   case RT_CLASS_IN:
    215                      ProcessFunc = usbcrHookProcessIn; usbcrHookProcessIn();
    216                      break;
    217          
    218                      // Unrecognized request: Stall the endpoint
    219                   default:
    220                      usbfwData.ep0Status = EP_STALL;
    221                      break;
    222                   }
    223          
    224                   // Arm/stall the endpoint
    225                   USBCS0 = (usbfwData.ep0Status == EP_STALL) ? (USBCS0_CLR_OUTPKT_RDY | USBCS0_SEND_STALL) : USBCS0_CLR_OUTPKT_RDY;
   \                     ??usbfwSetupHandler_23:
   \   00010F   90....       MOV     DPTR,#usbfwData + 7
   \   000112   E0           MOVX    A,@DPTR
   \   000113   6404         XRL     A,#0x4
   \   000115   7072         JNZ     ??usbfwSetupHandler_24
   \                     ??usbfwSetupHandler_25:
   \   000117   7860         MOV     R0,#0x60
   \   000119   8070         SJMP    ??usbfwSetupHandler_26
   \                     ??usbfwSetupHandler_19:
   \   00011B                ; Setup parameters for call to function usbsrSetFeature
   \   00011B   12....       LCALL   `??usbsrSetFeature::?relay`; Banked call to: usbsrSetFeature
   \   00011E   80EF         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_18:
   \   000120                ; Setup parameters for call to function usbsrClearFeature
   \   000120   12....       LCALL   `??usbsrClearFeature::?relay`; Banked call to: usbsrClearFeature
   \   000123   80EA         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_21:
   \   000125                ; Setup parameters for call to function usbsrSetConfiguration
   \   000125   12....       LCALL   `??usbsrSetConfiguration::?relay`; Banked call to: usbsrSetConfiguration
   \   000128   80E5         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_22:
   \   00012A                ; Setup parameters for call to function usbsrSetInterface
   \   00012A   12....       LCALL   `??usbsrSetInterface::?relay`; Banked call to: usbsrSetInterface
   \   00012D   80E0         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_14:
   \   00012F   A3           INC     DPTR
   \   000130   E0           MOVX    A,@DPTR
   \   000131   600E         JZ      ??usbfwSetupHandler_27
   \   000133   24FA         ADD     A,#-0x6
   \   000135   600F         JZ      ??usbfwSetupHandler_28
   \   000137   24FE         ADD     A,#-0x2
   \   000139   6010         JZ      ??usbfwSetupHandler_29
   \   00013B   24FE         ADD     A,#-0x2
   \   00013D   6011         JZ      ??usbfwSetupHandler_30
   \   00013F   8040         SJMP    ??usbfwSetupHandler_17
   \                     ??usbfwSetupHandler_27:
   \   000141                ; Setup parameters for call to function usbsrGetStatus
   \   000141   12....       LCALL   `??usbsrGetStatus::?relay`; Banked call to: usbsrGetStatus
   \   000144   80C9         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_28:
   \   000146                ; Setup parameters for call to function usbsrGetDescriptor
   \   000146   12....       LCALL   `??usbsrGetDescriptor::?relay`; Banked call to: usbsrGetDescriptor
   \   000149   80C4         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_29:
   \   00014B                ; Setup parameters for call to function usbsrGetConfiguration
   \   00014B   12....       LCALL   `??usbsrGetConfiguration::?relay`; Banked call to: usbsrGetConfiguration
   \   00014E   80BF         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_30:
   \   000150                ; Setup parameters for call to function usbsrGetInterface
   \   000150   12....       LCALL   `??usbsrGetInterface::?relay`; Banked call to: usbsrGetInterface
   \   000153   80BA         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_13:
   \   000155   75....       MOV     ??ProcessFunc+0x0,#`??usbvrHookProcessOut::?relay` & 0xff
   \   000158   75....       MOV     ??ProcessFunc+0x1,#(`??usbvrHookProcessOut::?relay` >> 8) & 0xff
   \   00015B                ; Setup parameters for call to function usbvrHookProcessOut
   \   00015B   12....       LCALL   `??usbvrHookProcessOut::?relay`; Banked call to: usbvrHookProcessOut
   \   00015E   80AF         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_16:
   \   000160   75....       MOV     ??ProcessFunc+0x0,#`??usbvrHookProcessIn::?relay` & 0xff
   \   000163   75....       MOV     ??ProcessFunc+0x1,#(`??usbvrHookProcessIn::?relay` >> 8) & 0xff
   \   000166                ; Setup parameters for call to function usbvrHookProcessIn
   \   000166   12....       LCALL   `??usbvrHookProcessIn::?relay`; Banked call to: usbvrHookProcessIn
   \   000169   80A4         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_12:
   \   00016B   75....       MOV     ??ProcessFunc+0x0,#`??usbcrHookProcessOut::?relay` & 0xff
   \   00016E   75....       MOV     ??ProcessFunc+0x1,#(`??usbcrHookProcessOut::?relay` >> 8) & 0xff
   \   000171                ; Setup parameters for call to function usbcrHookProcessOut
   \   000171   12....       LCALL   `??usbcrHookProcessOut::?relay`; Banked call to: usbcrHookProcessOut
   \   000174   8099         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_15:
   \   000176   75....       MOV     ??ProcessFunc+0x0,#`??usbcrHookProcessIn::?relay` & 0xff
   \   000179   75....       MOV     ??ProcessFunc+0x1,#(`??usbcrHookProcessIn::?relay` >> 8) & 0xff
   \   00017C                ; Setup parameters for call to function usbcrHookProcessIn
   \   00017C   12....       LCALL   `??usbcrHookProcessIn::?relay`; Banked call to: usbcrHookProcessIn
   \   00017F   808E         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_17:
   \   000181   90....       MOV     DPTR,#usbfwData + 7
   \   000184   7404         MOV     A,#0x4
   \   000186   F0           MOVX    @DPTR,A
   \   000187   808E         SJMP    ??usbfwSetupHandler_25
    226                }
    227             }
   \                     ??usbfwSetupHandler_24:
   \   000189   7840         MOV     R0,#0x40
   \                     ??usbfwSetupHandler_26:
   \   00018B   E8           MOV     A,R0
   \   00018C   906211       MOV     DPTR,#0x6211
   \   00018F   F0           MOVX    @DPTR,A
    228          
    229             // Transmit IN packets
    230             if (usbfwData.ep0Status == EP_TX) {
   \                     ??usbfwSetupHandler_10:
   \   000190   90....       MOV     DPTR,#usbfwData + 7
   \   000193   E0           MOVX    A,@DPTR
   \   000194   F8           MOV     R0,A
   \   000195   7401         MOV     A,#0x1
   \   000197   68           XRL     A,R0
   \   000198   705D         JNZ     ??usbfwSetupHandler_31
    231                controlReg = USBCS0_INPKT_RDY;
   \   00019A   7F02         MOV     R7,#0x2
    232          
    233                // The last frame should contain 0 to (EP0_PACKET_SIZE - 1) bytes
    234                if (usbSetupData.bytesLeft < EP0_PACKET_SIZE) {
   \   00019C   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00019F   C3           CLR     C
   \   0001A0   E8           MOV     A,R0
   \   0001A1   9420         SUBB    A,#0x20
   \   0001A3   E9           MOV     A,R1
   \   0001A4   9400         SUBB    A,#0x0
   \   0001A6   5007         JNC     ??usbfwSetupHandler_32
    235                   bytesNow = usbSetupData.bytesLeft;
   \   0001A8   E8           MOV     A,R0
   \   0001A9   F5..         MOV     ?V0,A
    236                   controlReg |= USBCS0_DATA_END;
   \   0001AB   7F0A         MOV     R7,#0xa
   \   0001AD   8003         SJMP    ??usbfwSetupHandler_33
    237          
    238                   // All other packets should have the maximum length
    239                } else {
    240                   bytesNow = EP0_PACKET_SIZE;
   \                     ??usbfwSetupHandler_32:
   \   0001AF   75..20       MOV     ?V0,#0x20
    241                }
    242          
    243                // Load the FIFO and move the pointer
    244                usbfwWriteFifo(&USBF0, bytesNow, usbSetupData.pBuffer);
   \                     ??usbfwSetupHandler_33:
   \   0001B2                ; Setup parameters for call to function usbfwWriteFifo
   \   0001B2   90....       MOV     DPTR,#usbSetupData
   \   0001B5   12....       LCALL   ?PUSH_XSTACK8_X_THREE
   \   0001B8   A9..         MOV     R1,?V0
   \   0001BA   7A20         MOV     R2,#0x20
   \   0001BC   7B62         MOV     R3,#0x62
   \   0001BE   12....       LCALL   `??usbfwWriteFifo::?relay`; Banked call to: usbfwWriteFifo
   \   0001C1   7403         MOV     A,#0x3
   \   0001C3   12....       LCALL   ?DEALLOC_XSTACK8
    245                usbSetupData.pBuffer += bytesNow;
   \   0001C6   AC..         MOV     R4,?V0
   \   0001C8   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   0001CB   E9           MOV     A,R1
   \   0001CC   2C           ADD     A,R4
   \   0001CD   12....       LCALL   ?Subroutine19 & 0xFFFF
    246                usbSetupData.bytesLeft -= bytesNow;
   \                     ??CrossCallReturnLabel_25:
   \   0001D0   A8..         MOV     R0,?V0
   \   0001D2   A3           INC     DPTR
   \   0001D3   12....       LCALL   ?Subroutine15 & 0xFFFF
    247          
    248                // Arm the FIFO (even for a zero-length packet)
    249                USBCS0 = controlReg;
   \                     ??CrossCallReturnLabel_17:
   \   0001D6   EF           MOV     A,R7
   \   0001D7   906211       MOV     DPTR,#0x6211
   \   0001DA   F0           MOVX    @DPTR,A
    250          
    251                // Make a call to the appropriate request handler when done
    252                if (bytesNow < EP0_PACKET_SIZE) {
   \   0001DB   E8           MOV     A,R0
   \   0001DC   C3           CLR     C
   \   0001DD   9420         SUBB    A,#0x20
   \   0001DF   5024         JNC     ??usbfwSetupHandler_7
    253                   if (ProcessFunc) ProcessFunc();
   \                     ??usbfwSetupHandler_8:
   \   0001E1   E5..         MOV     A,??ProcessFunc+0x0
   \   0001E3   45..         ORL     A,??ProcessFunc+0x1
   \   0001E5   6009         JZ      ??usbfwSetupHandler_34
   \   0001E7                ; Setup parameters for indirect call
   \   0001E7   85..82       MOV     DPL,??ProcessFunc+0x0
   \   0001EA   85..83       MOV     DPH,??ProcessFunc+0x1
   \   0001ED   12....       LCALL   ?CALL_IND
    254                   usbfwData.ep0Status = EP_IDLE;
   \                     ??usbfwSetupHandler_34:
   \   0001F0   90....       MOV     DPTR,#usbfwData + 7
   \   0001F3   E4           CLR     A
   \   0001F4   F0           MOVX    @DPTR,A
   \   0001F5   800E         SJMP    ??usbfwSetupHandler_7
    255                }
    256          
    257             // Let the application handle the transmission
    258             } else if (usbfwData.ep0Status == EP_MANUAL_TX) {
   \                     ??usbfwSetupHandler_31:
   \   0001F7   7405         MOV     A,#0x5
   \   0001F9   68           XRL     A,R0
   \   0001FA   7009         JNZ     ??usbfwSetupHandler_7
    259                ProcessFunc();
   \   0001FC                ; Setup parameters for indirect call
   \   0001FC   85..82       MOV     DPL,??ProcessFunc+0x0
   \   0001FF   85..83       MOV     DPH,??ProcessFunc+0x1
   \   000202   12....       LCALL   ?CALL_IND
    260             }
    261          
    262             // Restore the old index setting
    263             USBFW_SELECT_ENDPOINT(oldEndpoint);
   \                     ??usbfwSetupHandler_7:
   \   000205   EE           MOV     A,R6
   \   000206   90620E       MOV     DPTR,#0x620e
   \   000209                REQUIRE ?Subroutine0
   \   000209                ; // Fall through to label ?Subroutine0
    264          
    265          } // usbfwSetupHandler

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                REQUIRE ??Subroutine27_0
   \   000001                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   F9           MOV     R1,A
   \   000001   E4           CLR     A
   \   000002   3A           ADDC    A,R2
   \   000003   FA           MOV     R2,A
   \   000004   90....       MOV     DPTR,#usbSetupData
   \   000007   E9           MOV     A,R1
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EA           MOV     A,R2
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   EB           MOV     A,R3
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   C3           CLR     C
   \   000001   E0           MOVX    A,@DPTR
   \   000002   98           SUBB    A,R0
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   9400         SUBB    A,#0x0
   \   000008   F0           MOVX    @DPTR,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   90....       MOV     DPTR,#usbSetupData
   \   000003                REQUIRE ??Subroutine28_0
   \   000003                ; // Fall through to label ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine29_0
   \   000003                ; // Fall through to label ??Subroutine29_0
    266          
    267          
    268          
    269          
    270          /** \brief Changes the state of endpoint 1-5 IN/OUT
    271           *
    272           * This is an internal function used by the library.
    273           *
    274           * \param[in]       status
    275           *     The new status for each endpoint
    276           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    277          void usbfwSetAllEpStatus(EP_STATUS status)
   \                     usbfwSetAllEpStatus:
    278          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    279             uint8 n;
    280             for (n = 0; n < sizeof(usbfwData.pEpInStatus); n++)
    281                 usbfwData.pEpInStatus[n] = status;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#usbfwData + 8
   \   000008   7805         MOV     R0,#0x5
   \                     ??usbfwSetAllEpStatus_0:
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   D8FC         DJNZ    R0,??usbfwSetAllEpStatus_0
    282             for (n = 0; n < sizeof(usbfwData.pEpOutStatus); n++)
    283                 usbfwData.pEpOutStatus[n] = status;
   \   00000E   90....       MOV     DPTR,#usbfwData + 13
   \   000011   7805         MOV     R0,#0x5
   \                     ??usbfwSetAllEpStatus_1:
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   D8FC         DJNZ    R0,??usbfwSetAllEpStatus_1
    284          } // usbfwSetAllEpStatus
   \   000017   02....       LJMP    ??Subroutine26_0 & 0xFFFF
    285          
    286          
    287          
    288          
    289          /** \brief Reads from the selected OUT endpoint FIFO, without using DMA
    290           *
    291           * The FIFO must be re-armed after reading it empty (using the \ref USBFW_ARM_OUT_ENDPOINT() macro). This
    292           * is not necessary when flushing the FIFO.
    293           *
    294           * \param[in]       *pFifo
    295           *     Pointer to the FIFO (\c &USBFx)
    296           * \param[in]       count
    297           *     The number of bytes to read
    298           * \param[in]       *pData
    299           *     A pointer to the storage location for the read data (in any memory space)
    300           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    301          void usbfwReadFifo(uint8 volatile __xdata *pFifo, uint8 count, void __generic *pData)
   \                     usbfwReadFifo:
    302          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
   \   000009   E9           MOV     A,R1
   \   00000A   F8           MOV     R0,A
    303             uint8 __generic *pTemp = pData;
   \   00000B   7409         MOV     A,#0x9
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ??Subroutine28_0 & 0xFFFF
    304             if (count) {
   \                     ??CrossCallReturnLabel_38:
   \   000013   E8           MOV     A,R0
   \   000014   6011         JZ      ??usbfwReadFifo_0
    305                do {
    306                   *(pTemp++) = *pFifo;
   \                     ??usbfwReadFifo_1:
   \   000016   8C82         MOV     DPL,R4
   \   000018   8D83         MOV     DPH,R5
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   12....       LCALL   ?C_GPTR_STORE
   \   00001E   E9           MOV     A,R1
   \   00001F   2401         ADD     A,#0x1
   \   000021   09           INC     R1
   \   000022   E4           CLR     A
   \   000023   3A           ADDC    A,R2
   \   000024   FA           MOV     R2,A
    307                } while (--count);
   \   000025   D8EF         DJNZ    R0,??usbfwReadFifo_1
    308             }
    309          } // usbfwReadFifo
   \                     ??usbfwReadFifo_0:
   \   000027   80..         SJMP    ?Subroutine4
    310          
    311          
    312          
    313          
    314          /** \brief Writes to the selected IN endpoint FIFO, without using DMA
    315           *
    316           * Note that the FIFO must be armed in order to be transmitted (using the \ref USBFW_ARM_IN_ENDPOINT()
    317           * macro).
    318           *
    319           * \param[in]       *pFifo
    320           *     Pointer to the FIFO (\c &USBFx)
    321           * \param[in]       count
    322           *     The number of bytes to write
    323           * \param[in]       *pData
    324           *     A pointer to the data to be written (from any memory space)
    325           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    326          void usbfwWriteFifo(uint8 volatile __xdata *pFifo, uint8 count, void __generic *pData)
   \                     usbfwWriteFifo:
    327          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
   \   000009   E9           MOV     A,R1
   \   00000A   F8           MOV     R0,A
    328             uint8 __generic *pTemp = pData;
   \   00000B   7409         MOV     A,#0x9
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ??Subroutine28_0 & 0xFFFF
    329             if (count) {
   \                     ??CrossCallReturnLabel_39:
   \   000013   E8           MOV     A,R0
   \   000014   6011         JZ      ??usbfwWriteFifo_0
    330                do {
    331                   *pFifo = *(pTemp++);
   \                     ??usbfwWriteFifo_1:
   \   000016   12....       LCALL   ?C_GPTR_LOAD
   \   000019   8C82         MOV     DPL,R4
   \   00001B   8D83         MOV     DPH,R5
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   E9           MOV     A,R1
   \   00001F   2401         ADD     A,#0x1
   \   000021   09           INC     R1
   \   000022   E4           CLR     A
   \   000023   3A           ADDC    A,R2
   \   000024   FA           MOV     R2,A
    332                } while (--count);
   \   000025   D8EF         DJNZ    R0,??usbfwWriteFifo_1
    333             }
    334          } // usbfwWriteFifo
   \                     ??usbfwWriteFifo_0:
   \   000027                REQUIRE ?Subroutine4
   \   000027                ; // Fall through to label ?Subroutine4
    335          
    336          
    337          /// @}
    338          
C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_interrupt.c
      1          /******************************************************************************
      2          
      3           @file  usb_interrupt.c
      4          
      5           @brief USB library interrupt initialisation and ISR.
      6          
      7           Group: WCS, BTS
      8           Target Device: CC2540, CC2541
      9          
     10           ******************************************************************************
     11           
     12           Copyright (c) 2008-2016, Texas Instruments Incorporated
     13           All rights reserved.
     14          
     15           IMPORTANT: Your use of this Software is limited to those specific rights
     16           granted under the terms of a software license agreement between the user
     17           who downloaded the software, his/her employer (which must be your employer)
     18           and Texas Instruments Incorporated (the "License"). You may not use this
     19           Software unless you agree to abide by the terms of the License. The License
     20           limits your use, and you acknowledge, that the Software may not be modified,
     21           copied or distributed unless embedded on a Texas Instruments microcontroller
     22           or used solely and exclusively in conjunction with a Texas Instruments radio
     23           frequency transceiver, which is integrated into your product. Other than for
     24           the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25           works of, modify, distribute, perform, display or sell this Software and/or
     26           its documentation for any purpose.
     27          
     28           YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29           PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30           INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31           NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32           TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33           NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34           LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35           INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36           OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37           OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38           (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40           Should you have any questions regarding your right to use this Software,
     41           contact Texas Instruments Incorporated at www.TI.com.
     42          
     43           ******************************************************************************
     44           Release Name: ble_sdk_1.4.2.2
     45           Release Date: 2016-06-09 06:57:10
     46           *****************************************************************************/
     47          
     48          /// \addtogroup module_usb_interrupt
     49          /// @{
     50          #define USBINTERRUPT_C ///< Modifies the behavior of "EXTERN" in usb_interrupt.h
     51          #include "usb_firmware_library_headers.h"

   \                                 In  segment DATA_Z, align 1, keep-with-next
   \   USBIRQ_DATA __data usbirqData
   \                     usbirqData:
   \   000000                DS 5
   \   000005                REQUIRE __INIT_DATA_Z
     52          #include "usb_board_cfg.h"
     53          #include "hal_flash.h"
     54          
     55          /** \brief Initializes the \ref module_usb_interrupt module
     56           *
     57           * This function should be called after the \ref module_usb_framework module has been initialized.
     58           * Use interrupt group priority control (refer to the CC2531 datasheet) to adjust the priority of the
     59           * USB interrupt relative to other interrupts.
     60           *
     61           * \param[in]       irqMask
     62           *     A bit mask containing USBIRQ_EVENT bits for all events that shall be reported
     63           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   758B00       MOV     0x8b,#0x0
   \   000003   C2E8         CLR     0xe8.0
   \   000005                REQUIRE ??Subroutine23_0
   \   000005                ; // Fall through to label ??Subroutine23_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     64          void usbirqInit(uint16 irqMask)
   \                     usbirqInit:
     65          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
     66              // Initialize variables
     67              usbirqData.eventMask = 0x0000;
   \   000005   75..00       MOV     usbirqData+0x0,#0x0
   \   000008   75..00       MOV     usbirqData+0x1,#0x0
     68              usbirqData.inSuspend = FALSE;
   \   00000B   75..00       MOV     usbirqData + 2,#0x0
     69              usbirqData.irqMask = irqMask;
   \   00000E   8A..         MOV     usbirqData + 3+0x0,R2
   \   000010   8B..         MOV     usbirqData + 3+0x1,R3
     70          
     71              // Select which IRQ flags to handle
     72              USBCIE = irqMask;
   \   000012   EA           MOV     A,R2
   \   000013   90620B       MOV     DPTR,#0x620b
   \   000016   F0           MOVX    @DPTR,A
     73              USBIIE = irqMask >> 4;
   \   000017   8A..         MOV     ?V0,R2
   \   000019   8B..         MOV     ?V1,R3
   \   00001B   7404         MOV     A,#0x4
   \   00001D   78..         MOV     R0,#?V0
   \   00001F   12....       LCALL   ?US_SHR
   \   000022   E5..         MOV     A,?V0
   \   000024   906207       MOV     DPTR,#0x6207
   \   000027   F0           MOVX    @DPTR,A
     74              USBOIE = (irqMask >> 9) & 0x3E;
   \   000028   8A..         MOV     ?V0,R2
   \   00002A   8B..         MOV     ?V1,R3
   \   00002C   7409         MOV     A,#0x9
   \   00002E   78..         MOV     R0,#?V0
   \   000030   12....       LCALL   ?US_SHR
   \   000033   E5..         MOV     A,?V0
   \   000035   543E         ANL     A,#0x3e
   \   000037   906209       MOV     DPTR,#0x6209
   \   00003A   F0           MOVX    @DPTR,A
     75          
     76              HAL_USB_INT_CLEAR();
   \   00003B   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   00003E                REQUIRE P2IFG
   \   00003E                REQUIRE _A_IRCON2
     77              HAL_USB_INT_ENABLE();
     78          
     79          } // usbirqInit
     80          
     81          
     82          
     83          /** \brief USB interrupt handler
     84           *
     85           * Clears the P2 interrupt flag and converts all USB interrupt flags into events.
     86           * The interrupt also lets \ref usbsuspEnter() break from the suspend loop.
     87           */
     88          #if defined HAL_SB_BOOT_CODE

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     89          void usbirqHandler(void)
   \                     usbirqHandler:
     90          #else
     91          #pragma vector=P2INT_VECTOR
     92          __interrupt void usbirqHandler(void)
     93          #endif
     94          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
     95             uint8 usbcif;
     96          
     97             // First make sure that the crystal oscillator is stable
     98             while (!CC2530_IS_XOSC_STABLE());
   \                     ??usbirqHandler_0:
   \   000005   E59D         MOV     A,0x9d
   \   000007   A2E6         MOV     C,0xE0 /* A   */.6
   \   000009   50FA         JNC     ??usbirqHandler_0
     99          
    100             // Special handling for reset interrupts
    101             usbcif = USBCIF;
   \   00000B   906206       MOV     DPTR,#0x6206
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F9           MOV     R1,A
    102             if (usbcif & USBCIF_RSTIF) {
   \   000010   A2E2         MOV     C,0xE0 /* A   */.2
   \   000012   5034         JNC     ??usbirqHandler_1
    103          
    104                 // All interrupts (except suspend) are by default enabled by hardware, so
    105                 // re-initialize the enable bits to avoid unwanted interrupts
    106                 USBCIE = usbirqData.irqMask;
   \   000014   AA..         MOV     R2,usbirqData + 3+0x0
   \   000016   EA           MOV     A,R2
   \   000017   90620B       MOV     DPTR,#0x620b
   \   00001A   F0           MOVX    @DPTR,A
    107                 USBIIE = usbirqData.irqMask >> 4;
   \   00001B   F5..         MOV     ?V0,A
   \   00001D   85....       MOV     ?V1,usbirqData + 3+0x1
   \   000020   7404         MOV     A,#0x4
   \   000022   78..         MOV     R0,#?V0
   \   000024   12....       LCALL   ?US_SHR
   \   000027   E5..         MOV     A,?V0
   \   000029   906207       MOV     DPTR,#0x6207
   \   00002C   F0           MOVX    @DPTR,A
    108                 USBOIE = (usbirqData.irqMask >> 9) & 0x3E;
   \   00002D   8A..         MOV     ?V0,R2
   \   00002F   85....       MOV     ?V1,usbirqData + 3+0x1
   \   000032   7409         MOV     A,#0x9
   \   000034   78..         MOV     R0,#?V0
   \   000036   12....       LCALL   ?US_SHR
   \   000039   E5..         MOV     A,?V0
   \   00003B   543E         ANL     A,#0x3e
   \   00003D   906209       MOV     DPTR,#0x6209
   \   000040   F0           MOVX    @DPTR,A
    109          
    110                 // Enable suspend mode when suspend signaling is detected on the bus
    111                 USBPOW |= USBPOW_SUSPEND_EN;
   \   000041   906201       MOV     DPTR,#0x6201
   \   000044   E0           MOVX    A,@DPTR
   \   000045   D2E0         SETB    0xE0 /* A   */.0
   \   000047   F0           MOVX    @DPTR,A
    112             }
    113          
    114             // Record events (keeping existing)
    115             usbirqData.eventMask |= (uint16) usbcif;
   \                     ??usbirqHandler_1:
   \   000048   E9           MOV     A,R1
   \   000049   78..         MOV     R0,#usbirqData
   \   00004B   46           ORL     A,@R0
   \   00004C   F6           MOV     @R0,A
    116             usbirqData.eventMask |= (uint16) USBIIF << 4;
   \   00004D   906202       MOV     DPTR,#0x6202
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F5..         MOV     ?V0,A
   \   000053   75..00       MOV     ?V1,#0x0
   \   000056   7404         MOV     A,#0x4
   \   000058   78..         MOV     R0,#?V0
   \   00005A   12....       LCALL   ?S_SHL
   \   00005D   78..         MOV     R0,#usbirqData
   \   00005F   E5..         MOV     A,?V0
   \   000061   46           ORL     A,@R0
   \   000062   F6           MOV     @R0,A
   \   000063   08           INC     R0
   \   000064   E5..         MOV     A,?V1
   \   000066   46           ORL     A,@R0
   \   000067   F6           MOV     @R0,A
    117             usbirqData.eventMask |= (uint16) USBOIF << 9;
   \   000068   906204       MOV     DPTR,#0x6204
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   F5..         MOV     ?V0,A
   \   00006E   75..00       MOV     ?V1,#0x0
   \   000071   7409         MOV     A,#0x9
   \   000073   78..         MOV     R0,#?V0
   \   000075   12....       LCALL   ?S_SHL
   \   000078   78..         MOV     R0,#usbirqData + 1
   \   00007A   E5..         MOV     A,?V1
   \   00007C   46           ORL     A,@R0
   \   00007D   F6           MOV     @R0,A
    118          
    119             // If we get a suspend event, we should always enter suspend mode. We must,
    120             // however be sure that we exit the suspend loop upon resume or reset
    121             // signaling.
    122             if (usbcif & USBCIF_SUSPENDIF) {
   \   00007E   E9           MOV     A,R1
   \   00007F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000081   5003         JNC     ??usbirqHandler_2
    123                usbirqData.inSuspend = TRUE;
   \   000083   75..01       MOV     usbirqData + 2,#0x1
    124             }
    125             if (usbcif & (USBCIF_RSTIF | USBCIF_RESUMEIF)) {
   \                     ??usbirqHandler_2:
   \   000086   7406         MOV     A,#0x6
   \   000088   59           ANL     A,R1
   \   000089   6003         JZ      ??usbirqHandler_3
    126                usbirqData.inSuspend = FALSE;
   \   00008B   75..00       MOV     usbirqData + 2,#0x0
    127             }
    128             if (P2IFG & P2IFG_DPIF) {
   \                     ??usbirqHandler_3:
   \   00008E   E58B         MOV     A,0x8b
   \   000090   A2E5         MOV     C,0xE0 /* A   */.5
   \   000092   5006         JNC     ??usbirqHandler_4
    129                // Resume interrupt detected on D+ line while in suspend
    130                P2IFG = (P2IFG_DPIF ^ 0xFF);
   \   000094   758BDF       MOV     0x8b,#-0x21
    131                usbirqData.inSuspend = FALSE;
   \   000097   75..00       MOV     usbirqData + 2,#0x0
    132             }
    133          
    134             // Handle event which need immediate processing
    135             usbirqHookProcessEvents();
   \                     ??usbirqHandler_4:
   \   00009A                ; Setup parameters for call to function usbirqHookProcessEvents
   \   00009A   12....       LCALL   `??usbirqHookProcessEvents::?relay`; Banked call to: usbirqHookProcessEvents
    136          
    137             // Clear the interrupt
    138             HAL_USB_INT_CLEAR();
   \   00009D   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   0000A0                REQUIRE SLEEPSTA
   \   0000A0                REQUIRE P2IFG
   \   0000A0                REQUIRE _A_IRCON2
    139          
    140          } // usbirqHandler
    141          
    142          //@}
    143          
C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_standard_requests.c
      1          /******************************************************************************
      2          
      3           @file  usb_standard_requests.c
      4          
      5           @brief Handle USB standard requests.
      6          
      7           Group: WCS, BTS
      8           Target Device: CC2540, CC2541
      9          
     10           ******************************************************************************
     11           
     12           Copyright (c) 2004-2016, Texas Instruments Incorporated
     13           All rights reserved.
     14          
     15           IMPORTANT: Your use of this Software is limited to those specific rights
     16           granted under the terms of a software license agreement between the user
     17           who downloaded the software, his/her employer (which must be your employer)
     18           and Texas Instruments Incorporated (the "License"). You may not use this
     19           Software unless you agree to abide by the terms of the License. The License
     20           limits your use, and you acknowledge, that the Software may not be modified,
     21           copied or distributed unless embedded on a Texas Instruments microcontroller
     22           or used solely and exclusively in conjunction with a Texas Instruments radio
     23           frequency transceiver, which is integrated into your product. Other than for
     24           the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25           works of, modify, distribute, perform, display or sell this Software and/or
     26           its documentation for any purpose.
     27          
     28           YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29           PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30           INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31           NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32           TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33           NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34           LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35           INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36           OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37           OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38           (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40           Should you have any questions regarding your right to use this Software,
     41           contact Texas Instruments Incorporated at www.TI.com.
     42          
     43           ******************************************************************************
     44           Release Name: ble_sdk_1.4.2.2
     45           Release Date: 2016-06-09 06:57:10
     46           *****************************************************************************/
     47          
     48          /// \addtogroup module_usb_standard_requests
     49          /// @{
     50          #include "usb_firmware_library_headers.h"
     51          #include "hal_types.h"
     52          #include "hal_board.h"
     53          
     54          
     55          
     56          /** \brief Processes the \ref GET_STATUS request (returns status for the specified recipient)
     57           *
     58           * The recipient bits in \ref USB_SETUP_HEADER.requestType specify the desired recipient. This is either the
     59           * (one and only) device, a specific interface, or a specific endpoint. Some of the status bits can be
     60           * changed with the SET_FEATURE and CLEAR_FEATURE requests.
     61           *
     62           * <b>Parameters</b>:
     63           * - VALUE: Always 0
     64           * - INDEX: Depends upon the recipient:
     65           *     - DEVICE: Always 0
     66           *     - INTERFACE: Interface number
     67           *     - ENDPOINT: Endpoint address
     68           * - LENGTH: Always 2
     69           *
     70           * <b>Data (IN)</b>:
     71           * Depends upon the recipient (the bit field illustrations are MSB first, LSB last):
     72           * - DEVICE: <tt>00000000.000000RS</tt>, where R(1) = DEVICE_REMOTE_WAKEUP and S(0) = SELF_POWERED
     73           * - INTERFACE: <tt>00000000.00000000</tt> (all bits are reserved)
     74           * - ENDPOINT: <tt>00000000.0000000H</tt>, where H(0) = ENDPOINT_HALT
     75           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     76          void usbsrGetStatus(void)
   \                     usbsrGetStatus:
     77          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     78             uint8 endpoint;
     79             static uint16 __xdata status;
     80          
     81             // Common sanity check
     82             if (usbSetupHeader.value || HI_UINT16(usbSetupHeader.index) || (usbSetupHeader.length != 2)) {
   \   000004   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000007   6003         JZ      $+5
   \   000009   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6003         JZ      $+5
   \   000013   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6402         XRL     A,#0x2
   \   00001A   7002         JNZ     ??usbsrGetStatus_1
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \                     ??usbsrGetStatus_1:
   \   00001E   6003         JZ      $+5
   \   000020   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
     83                usbfwData.ep0Status = EP_STALL;
     84          
     85             // Return status for device, interface, or endpoint
     86             } else {
     87                switch (usbSetupHeader.requestType) {
   \   000023   90....       MOV     DPTR,#usbSetupHeader
   \   000026   E0           MOVX    A,@DPTR
   \   000027   2480         ADD     A,#-0x80
   \   000029   6009         JZ      ??usbsrGetStatus_2
   \   00002B   14           DEC     A
   \   00002C   604C         JZ      ??usbsrGetStatus_3
   \   00002E   14           DEC     A
   \   00002F   6059         JZ      ??usbsrGetStatus_4
   \   000031   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
     88          
     89                   // Device status:
     90                   //     Bit 0: Self powered
     91                   //     Bit 1: Remote wake-up allowed
     92                case RT_IN_DEVICE:
     93          
     94                   // Sanity check
     95                   if (LO_UINT16(usbSetupHeader.index)) {
   \                     ??usbsrGetStatus_2:
   \   000034   E8           MOV     A,R0
   \   000035   6003         JZ      $+5
   \   000037   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
     96                      usbfwData.ep0Status = EP_STALL;
     97          
     98                   // Get the bit values from the USBFW_DATA struct
     99                   } else {
    100          
    101                      // Self powered?
    102                      status = usbfwData.selfPowered ? 0x0001 : 0x0000;
   \   00003A   90....       MOV     DPTR,#usbfwData + 19
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   90....       MOV     DPTR,#??status
   \   000041   6007         JZ      ??usbsrGetStatus_5
   \   000043   7401         MOV     A,#0x1
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   E4           CLR     A
   \   000048   8003         SJMP    ??usbsrGetStatus_6
   \                     ??usbsrGetStatus_5:
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \                     ??usbsrGetStatus_6:
   \   00004D   F0           MOVX    @DPTR,A
    103          
    104                      // Remote wakeup?
    105                      if (usbfwData.remoteWakeup) status |= 0x0002;
   \   00004E   90....       MOV     DPTR,#usbfwData + 18
   \   000051   E0           MOVX    A,@DPTR
   \   000052   6007         JZ      ??usbsrGetStatus_7
   \   000054   90....       MOV     DPTR,#??status
   \   000057   E0           MOVX    A,@DPTR
   \   000058   4402         ORL     A,#0x2
   \                     ??usbsrGetStatus_8:
   \   00005A   F0           MOVX    @DPTR,A
    106                   }
    107                   break;
    108          
    109                   // Interface status:
    110                   //     All bits are reserved
    111                case RT_IN_INTERFACE:
    112          
    113                   // Sanity check
    114                   if (usbfwData.usbState != DEV_CONFIGURED) {
    115                      usbfwData.ep0Status = EP_STALL;
    116                   } else {
    117                      status = 0x0000;
    118                   }
    119                   break;
    120          
    121                   // Endpoint status:
    122                   //     Bit 0: Endpoint halted
    123                case RT_IN_ENDPOINT:
    124                   endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
    125          
    126                   // Sanity check
    127                   if ((usbfwData.usbState != DEV_CONFIGURED) || (endpoint > 5)) {
    128                      usbfwData.ep0Status = EP_STALL;
    129          
    130                   // Translate endpoint address to status index and return the status
    131                   } else {
    132          
    133                      // IN
    134                      if (LO_UINT16(usbSetupHeader.index) & 0x80) {
    135                         status = (usbfwData.pEpInStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
    136          
    137                      // OUT
    138                      } else {
    139                         status = (usbfwData.pEpOutStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
    140                      }
    141                   }
    142                   break;
    143          
    144                default:
    145                   usbfwData.ep0Status = EP_STALL;
    146                   break;
    147                }
    148          
    149                if (usbfwData.ep0Status != EP_STALL) {
   \                     ??usbsrGetStatus_7:
   \   00005B   90....       MOV     DPTR,#usbfwData + 7
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   6404         XRL     A,#0x4
   \   000061   6014         JZ      ??usbsrGetStatus_9
    150                   // Send it
    151                   usbSetupData.pBuffer = (uint8 __generic *)&status;
   \   000063   90....       MOV     DPTR,#usbSetupData
   \   000066   74..         MOV     A,#??status & 0xff
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   74..         MOV     A,#(??status >> 8) & 0xff
   \   00006C   F0           MOVX    @DPTR,A
   \   00006D   A3           INC     DPTR
   \   00006E   E4           CLR     A
   \   00006F   F0           MOVX    @DPTR,A
    152                   usbSetupData.bytesLeft = 2;
   \   000070   A3           INC     DPTR
   \   000071   7402         MOV     A,#0x2
   \   000073   12....       LCALL   ?Subroutine22 & 0xFFFF
    153                   usbfwData.ep0Status = EP_TX;
    154                }
   \                     ??CrossCallReturnLabel_28:
   \   000076   F0           MOVX    @DPTR,A
    155             }
    156          } // usbsrGetStatus
   \                     ??usbsrGetStatus_9:
   \   000077   02....       LJMP    ??Subroutine26_0 & 0xFFFF
   \                     ??usbsrGetStatus_3:
   \   00007A   90....       MOV     DPTR,#usbfwData
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   6404         XRL     A,#0x4
   \   000080   7050         JNZ     ??usbsrGetStatus_0
   \                     ??usbsrGetStatus_10:
   \   000082   90....       MOV     DPTR,#??status
   \   000085   E4           CLR     A
   \   000086   F0           MOVX    @DPTR,A
   \   000087   A3           INC     DPTR
   \   000088   80D0         SJMP    ??usbsrGetStatus_8
   \                     ??usbsrGetStatus_4:
   \   00008A   E8           MOV     A,R0
   \   00008B   547F         ANL     A,#0x7f
   \   00008D   FA           MOV     R2,A
   \   00008E   90....       MOV     DPTR,#usbfwData
   \   000091   E0           MOVX    A,@DPTR
   \   000092   6404         XRL     A,#0x4
   \   000094   703C         JNZ     ??usbsrGetStatus_0
   \   000096   EA           MOV     A,R2
   \   000097   C3           CLR     C
   \   000098   9406         SUBB    A,#0x6
   \   00009A   5036         JNC     ??usbsrGetStatus_0
   \   00009C   74..         MOV     A,#usbfwData & 0xff
   \   00009E   2A           ADD     A,R2
   \   00009F   F582         MOV     DPL,A
   \   0000A1   E4           CLR     A
   \   0000A2   34..         ADDC    A,#(usbfwData >> 8) & 0xff
   \   0000A4   F583         MOV     DPH,A
   \   0000A6   E8           MOV     A,R0
   \   0000A7   5480         ANL     A,#0x80
   \   0000A9   600E         JZ      ??usbsrGetStatus_11
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   6403         XRL     A,#0x3
   \   0000B5   70CB         JNZ     ??usbsrGetStatus_10
   \   0000B7   800F         SJMP    ??usbsrGetStatus_12
   \                     ??usbsrGetStatus_11:
   \   0000B9   E582         MOV     A,DPL
   \   0000BB   240C         ADD     A,#0xc
   \   0000BD   F582         MOV     DPL,A
   \   0000BF   5002         JNC     ??usbsrGetStatus_13
   \   0000C1   0583         INC     DPH
   \                     ??usbsrGetStatus_13:
   \   0000C3   E0           MOVX    A,@DPTR
   \   0000C4   6403         XRL     A,#0x3
   \   0000C6   70BA         JNZ     ??usbsrGetStatus_10
   \                     ??usbsrGetStatus_12:
   \   0000C8   90....       MOV     DPTR,#??status
   \   0000CB   7401         MOV     A,#0x1
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   E4           CLR     A
   \   0000D0   8088         SJMP    ??usbsrGetStatus_8
   \                     ??usbsrGetStatus_0:
   \   0000D2   90....       MOV     DPTR,#usbfwData + 7
   \   0000D5   7404         MOV     A,#0x4
   \   0000D7   809D         SJMP    ??CrossCallReturnLabel_28

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000003                REQUIRE ??Subroutine30_0
   \   000003                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E4           CLR     A
   \   000003   F0           MOVX    @DPTR,A
   \   000004   90....       MOV     DPTR,#usbfwData + 7
   \   000007   04           INC     A
   \   000008   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??status:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    157          
    158          
    159          
    160          
    161          /** \brief Internal function used for the very similar \ref SET_FEATURE and \ref CLEAR_FEATURE requests
    162           *
    163           * This function either sets or clears the specified feature on the specified recipient.
    164           *
    165           * \param[in]       set
    166           *     When TRUE, the feature is set. When FALSE, the feature is cleared.
    167           *
    168           * \return
    169           *     TRUE if the selected feature is supported by the USB library. FALSE to indicate that
    170           *     \ref usbsrHookClearFeature() or \ref usbsrHookSetFeature() must be called.
    171           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    172          static uint8 ChangeFeature(uint8 set)
   \                     ??ChangeFeature:
    173          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    174             uint8 endpoint;
    175          
    176             // Sanity check
    177             if (usbSetupHeader.length || (usbfwData.usbState != DEV_CONFIGURED) && (usbSetupHeader.index != 0)) {
   \   000007   90....       MOV     DPTR,#usbSetupHeader + 6
   \   00000A   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00000D   6003         JZ      $+5
   \   00000F   02....       LJMP    ??ChangeFeature_1 & 0xFFFF
   \   000012   90....       MOV     DPTR,#usbfwData
   \   000015   E0           MOVX    A,@DPTR
   \   000016   6404         XRL     A,#0x4
   \   000018   600B         JZ      ??ChangeFeature_2
   \   00001A   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00001D   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000020   6003         JZ      $+5
   \   000022   02....       LJMP    ??ChangeFeature_1 & 0xFFFF
    178                usbfwData.ep0Status = EP_STALL;
    179          
    180                // Handle based on recipient
    181             } else {
    182                switch (usbSetupHeader.requestType & RT_MASK_RECIP) {
   \                     ??ChangeFeature_2:
   \   000025   90....       MOV     DPTR,#usbSetupHeader
   \   000028   E0           MOVX    A,@DPTR
   \   000029   541F         ANL     A,#0x1f
   \   00002B   6009         JZ      ??ChangeFeature_3
   \   00002D   14           DEC     A
   \   00002E   6030         JZ      ??ChangeFeature_4
   \   000030   14           DEC     A
   \   000031   6020         JZ      ??ChangeFeature_5
   \   000033   02....       LJMP    ??ChangeFeature_1 & 0xFFFF
    183          
    184                // Device
    185                case RT_RECIP_DEV:
    186          
    187                   // Sanity check
    188                   if (LO_UINT16(usbSetupHeader.value) != DEVICE_REMOTE_WAKEUP) {
   \                     ??ChangeFeature_3:
   \   000036   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6401         XRL     A,#0x1
   \   00003C   7022         JNZ     ??ChangeFeature_4
    189                      return FALSE;
    190                   } else {
    191                      usbfwData.remoteWakeup = set;
   \   00003E   EE           MOV     A,R6
   \   00003F   90....       MOV     DPTR,#usbfwData + 18
   \   000042   F0           MOVX    @DPTR,A
    192                      usbsrHookProcessEvent(set ? USBSR_EVENT_REMOTE_WAKEUP_ENABLED : USBSR_EVENT_REMOTE_WAKEUP_DISABLED, 0);
   \   000043   6004         JZ      ??ChangeFeature_6
   \   000045   7905         MOV     R1,#0x5
   \   000047   8002         SJMP    ??ChangeFeature_7
   \                     ??ChangeFeature_6:
   \   000049   7906         MOV     R1,#0x6
   \                     ??ChangeFeature_7:
   \   00004B                ; Setup parameters for call to function usbsrHookProcessEvent
   \   00004B   7A00         MOV     R2,#0x0
   \   00004D   12....       LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
    193                   }
    194                   break;
   \   000050   02....       LJMP    ??ChangeFeature_8 & 0xFFFF
    195          
    196                // Endpoint
    197                case RT_RECIP_IF:
    198                   return FALSE;
    199          
    200                // Endpoint
    201                case RT_RECIP_EP:
    202                   endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
   \                     ??ChangeFeature_5:
   \   000053   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000056   E0           MOVX    A,@DPTR
   \   000057   547F         ANL     A,#0x7f
   \   000059   FA           MOV     R2,A
    203          
    204                   // Sanity check
    205                   if (LO_UINT16(usbSetupHeader.value) != ENDPOINT_HALT) {
   \   00005A   90....       MOV     DPTR,#usbSetupHeader + 2
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   6005         JZ      ??ChangeFeature_9
    206                      return FALSE;
   \                     ??ChangeFeature_4:
   \   000060   7900         MOV     R1,#0x0
   \   000062   02....       LJMP    ??ChangeFeature_10 & 0xFFFF
    207                   } else if (endpoint > 5) {
   \                     ??ChangeFeature_9:
   \   000065   EA           MOV     A,R2
   \   000066   C3           CLR     C
   \   000067   9406         SUBB    A,#0x6
   \   000069   5077         JNC     ??ChangeFeature_1
    208                      usbfwData.ep0Status = EP_STALL;
    209                   } else {
    210                      USBFW_SELECT_ENDPOINT(endpoint);
   \   00006B   EA           MOV     A,R2
   \   00006C   90620E       MOV     DPTR,#0x620e
   \   00006F   F0           MOVX    @DPTR,A
    211          
    212                      // IN
    213                      if (LO_UINT16(usbSetupHeader.index) & 0x80) {
   \   000070   74..         MOV     A,#usbfwData & 0xff
   \   000072   2A           ADD     A,R2
   \   000073   F8           MOV     R0,A
   \   000074   E4           CLR     A
   \   000075   34..         ADDC    A,#(usbfwData >> 8) & 0xff
   \   000077   F9           MOV     R1,A
   \   000078   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   5480         ANL     A,#0x80
   \   00007E   602E         JZ      ??ChangeFeature_11
    214                         USBCSIL = set ? USBCSIL_SEND_STALL : USBCSIL_CLR_DATA_TOG;
   \   000080   EE           MOV     A,R6
   \   000081   6004         JZ      ??ChangeFeature_12
   \   000083   7410         MOV     A,#0x10
   \   000085   8002         SJMP    ??ChangeFeature_13
   \                     ??ChangeFeature_12:
   \   000087   7440         MOV     A,#0x40
   \                     ??ChangeFeature_13:
   \   000089   906211       MOV     DPTR,#0x6211
   \   00008C   F0           MOVX    @DPTR,A
    215                         usbfwData.pEpInStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
   \   00008D   EE           MOV     A,R6
   \   00008E   6004         JZ      ??ChangeFeature_14
   \   000090   7B03         MOV     R3,#0x3
   \   000092   8002         SJMP    ??ChangeFeature_15
   \                     ??ChangeFeature_14:
   \   000094   7B00         MOV     R3,#0x0
   \                     ??ChangeFeature_15:
   \   000096   EB           MOV     A,R3
   \   000097   8882         MOV     DPL,R0
   \   000099   8983         MOV     DPH,R1
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   F0           MOVX    @DPTR,A
    216                         usbsrHookProcessEvent(set ? USBSR_EVENT_EPIN_STALL_SET : USBSR_EVENT_EPIN_STALL_CLEARED, endpoint);
   \   0000A3   EE           MOV     A,R6
   \   0000A4   6004         JZ      ??ChangeFeature_16
   \   0000A6   7908         MOV     R1,#0x8
   \   0000A8   802F         SJMP    ??ChangeFeature_17
   \                     ??ChangeFeature_16:
   \   0000AA   7907         MOV     R1,#0x7
   \   0000AC                ; Setup parameters for call to function usbsrHookProcessEvent
   \   0000AC   802B         SJMP    ??ChangeFeature_17
    217          
    218                      // OUT
    219                      } else {
    220                         USBCSOL = set ? USBCSOL_SEND_STALL : USBCSOL_CLR_DATA_TOG;
   \                     ??ChangeFeature_11:
   \   0000AE   EE           MOV     A,R6
   \   0000AF   6004         JZ      ??ChangeFeature_18
   \   0000B1   7B20         MOV     R3,#0x20
   \   0000B3   8002         SJMP    ??ChangeFeature_19
   \                     ??ChangeFeature_18:
   \   0000B5   7B80         MOV     R3,#-0x80
   \                     ??ChangeFeature_19:
   \   0000B7   EB           MOV     A,R3
   \   0000B8   906214       MOV     DPTR,#0x6214
   \   0000BB   F0           MOVX    @DPTR,A
    221                         usbfwData.pEpOutStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
   \   0000BC   EE           MOV     A,R6
   \   0000BD   6004         JZ      ??ChangeFeature_20
   \   0000BF   7B03         MOV     R3,#0x3
   \   0000C1   8002         SJMP    ??ChangeFeature_21
   \                     ??ChangeFeature_20:
   \   0000C3   7B00         MOV     R3,#0x0
   \                     ??ChangeFeature_21:
   \   0000C5   E8           MOV     A,R0
   \   0000C6   240C         ADD     A,#0xc
   \   0000C8   F582         MOV     DPL,A
   \   0000CA   E4           CLR     A
   \   0000CB   39           ADDC    A,R1
   \   0000CC   F583         MOV     DPH,A
   \   0000CE   EB           MOV     A,R3
   \   0000CF   F0           MOVX    @DPTR,A
    222                         usbsrHookProcessEvent(set ? USBSR_EVENT_EPOUT_STALL_SET : USBSR_EVENT_EPOUT_STALL_CLEARED, endpoint);
   \   0000D0   EE           MOV     A,R6
   \   0000D1   6004         JZ      ??ChangeFeature_22
   \   0000D3   790A         MOV     R1,#0xa
   \   0000D5   8002         SJMP    ??ChangeFeature_17
   \                     ??ChangeFeature_22:
   \   0000D7   7909         MOV     R1,#0x9
   \                     ??ChangeFeature_17:
   \   0000D9                ; Setup parameters for call to function usbsrHookProcessEvent
   \   0000D9   12....       LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
    223                      }
    224                      USBFW_SELECT_ENDPOINT(0);
   \   0000DC   90620E       MOV     DPTR,#0x620e
   \   0000DF   E4           CLR     A
   \   0000E0   8005         SJMP    ??ChangeFeature_23
    225                   }
    226                   break;
    227          
    228                default:
    229                   usbfwData.ep0Status = EP_STALL;
   \                     ??ChangeFeature_1:
   \   0000E2   90....       MOV     DPTR,#usbfwData + 7
   \   0000E5   7404         MOV     A,#0x4
   \                     ??ChangeFeature_23:
   \   0000E7   F0           MOVX    @DPTR,A
    230                   break;
    231                }
    232             }
    233             return TRUE;
   \                     ??ChangeFeature_8:
   \   0000E8   7901         MOV     R1,#0x1
   \                     ??ChangeFeature_10:
   \   0000EA   02....       LJMP    ?Subroutine4 & 0xFFFF
    234          } // ChangeFeature
    235          
    236          
    237          
    238          
    239          /** \brief Processes the \ref CLEAR_FEATURE request (clears or disables a specific feature)
    240           *
    241           * The feature selector value must be appropriate to the recipient.
    242           *
    243           * <b>Parameters</b>:
    244           * - VALUE: Feature selector:
    245           *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
    246           *     - \c ENDPOINT_HALT(0): Clear the halt feature for the specified endpoint (not endpoint 0!)
    247           * - INDEX: Depends upon the recipient:
    248           *     - DEVICE: Always 0
    249           *     - INTERFACE: Interface number
    250           *     - ENDPOINT: Endpoint address
    251           * - LENGTH: Always 0
    252           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    253          void usbsrClearFeature()
   \                     usbsrClearFeature:
    254          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    255             if (!ChangeFeature(FALSE)) {
   \   000004                ; Setup parameters for call to function ChangeFeature
   \   000004   7900         MOV     R1,#0x0
   \   000006   12....       LCALL   `??ChangeFeature::?relay`; Banked call to: ChangeFeature
   \   000009   E9           MOV     A,R1
   \   00000A   7003         JNZ     ??usbsrClearFeature_0
    256                usbsrHookClearFeature();
   \   00000C                ; Setup parameters for call to function usbsrHookClearFeature
   \   00000C   12....       LCALL   `??usbsrHookClearFeature::?relay`; Banked call to: usbsrHookClearFeature
    257             }
    258          } // usbsrClearFeature
   \                     ??usbsrClearFeature_0:
   \   00000F   02....       LJMP    ??Subroutine26_0 & 0xFFFF
    259          
    260          
    261          
    262          
    263          /** \brief Processes the \ref SET_FEATURE request (sets or enables a specific feature)
    264           *
    265           * The feature selector value must be appropriate to the recipient.
    266           *
    267           * <b>Parameters</b>:
    268           * - VALUE: Feature selector:
    269           *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
    270           *     - \c ENDPOINT_HALT(0): Set the halt feature for the specified endpoint (not endpoint 0!)
    271           * - INDEX: Depends upon the recipient:
    272           *     - DEVICE: Always 0
    273           *     - INTERFACE: Interface number
    274           *     - ENDPOINT: Endpoint address
    275           * - LENGTH: Always 0
    276           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    277          void usbsrSetFeature(void)
   \                     usbsrSetFeature:
    278          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    279             if (!ChangeFeature(TRUE)) {
   \   000004                ; Setup parameters for call to function ChangeFeature
   \   000004   7901         MOV     R1,#0x1
   \   000006   12....       LCALL   `??ChangeFeature::?relay`; Banked call to: ChangeFeature
   \   000009   E9           MOV     A,R1
   \   00000A   7003         JNZ     ??usbsrSetFeature_0
    280                usbsrHookSetFeature();
   \   00000C                ; Setup parameters for call to function usbsrHookSetFeature
   \   00000C   12....       LCALL   `??usbsrHookSetFeature::?relay`; Banked call to: usbsrHookSetFeature
    281             }
    282          } // usbsrSetFeature
   \                     ??usbsrSetFeature_0:
   \   00000F   02....       LJMP    ??Subroutine26_0 & 0xFFFF
    283          
    284          
    285          
    286          
    287          /** \brief Processes the \ref SET_ADDRESS request (sets the device address for all future device
    288           * accesses)
    289           *
    290           * If the value is between 1 and 127 and the device is in the default state, it will enter the address
    291           * state. If it already is in the address state, it starts to use the newly-specified address.
    292           *
    293           * If the value is 0 and the device is in the address state, it will enter the default state. If it
    294           * already is in the default state, nothing happens.
    295           *
    296           * <b>Parameters</b>:
    297           * - VALUE: The device address (0-127)
    298           * - INDEX: Always 0
    299           * - LENGTH: Always 0
    300           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    301          void usbsrSetAddress(void)
   \                     usbsrSetAddress:
    302          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    303          
    304             // Sanity check
    305             if (usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value) || (LO_UINT16(usbSetupHeader.value) & 0x80)) {
   \   000004   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000007   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   00000A   7015         JNZ     ??usbsrSetAddress_0
   \   00000C   A3           INC     DPTR
   \   00000D   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000010   700F         JNZ     ??usbsrSetAddress_0
   \   000012   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000015   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000018   5480         ANL     A,#0x80
   \   00001A   FA           MOV     R2,A
   \   00001B   E9           MOV     A,R1
   \   00001C   FB           MOV     R3,A
   \   00001D   EA           MOV     A,R2
   \   00001E   4B           ORL     A,R3
   \   00001F   6007         JZ      ??usbsrSetAddress_1
    306                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetAddress_0:
   \   000021   90....       MOV     DPTR,#usbfwData + 7
   \   000024   7404         MOV     A,#0x4
   \   000026   801A         SJMP    ??usbsrSetAddress_2
    307          
    308             // Update the device address
    309             } else {
    310                USBADDR = LO_UINT16(usbSetupHeader.value);
   \                     ??usbsrSetAddress_1:
   \   000028   E8           MOV     A,R0
   \   000029   906200       MOV     DPTR,#0x6200
   \   00002C   F0           MOVX    @DPTR,A
    311                if (LO_UINT16(usbSetupHeader.value) != 0) {
   \   00002D   90....       MOV     DPTR,#usbfwData
   \   000030   6009         JZ      ??usbsrSetAddress_3
    312                   if (usbfwData.usbState == DEV_DEFAULT) usbfwData.usbState = DEV_ADDRESS;
   \   000032   E0           MOVX    A,@DPTR
   \   000033   6402         XRL     A,#0x2
   \   000035   700C         JNZ     ??usbsrSetAddress_4
   \   000037   7403         MOV     A,#0x3
   \   000039   8007         SJMP    ??usbsrSetAddress_2
    313                } else {
    314                   if (usbfwData.usbState == DEV_ADDRESS) usbfwData.usbState = DEV_DEFAULT;
   \                     ??usbsrSetAddress_3:
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   6403         XRL     A,#0x3
   \   00003E   7003         JNZ     ??usbsrSetAddress_4
   \   000040   7402         MOV     A,#0x2
   \                     ??usbsrSetAddress_2:
   \   000042   F0           MOVX    @DPTR,A
    315                }
    316             }
    317          
    318          } // usbsrSetAddress
   \                     ??usbsrSetAddress_4:
   \   000043   02....       LJMP    ??Subroutine26_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET
    319          
    320          
    321          
    322          
    323          /** \brief Processes the \ref GET_DESCRIPTOR request (returns the specified USB descriptor)
    324           *
    325           * The \ref module_usb_descriptor_parser module is used to locate device, configuration and string
    326           * descriptors. Note that configuration descriptors also include interface, endpoint and other
    327           * "similar" descriptor types (e.g. HID descriptor), with the total descriptor length specified by
    328           * the \ref USB_CONFIGURATION_DESCRIPTOR.wTotalLength field.
    329           *
    330           * Other descriptor types that are not returned with the configuration descriptor, must be defined in
    331           * the usbDescriptorMarker.pUsbDescLut lookup-table. This table specifies the values of the VALUE and INDEX fields, and
    332           * gives a pointer to the descriptor along with it's length.
    333           *
    334           * <b>Parameters</b>:
    335           * - VALUE.MSB: Descriptor type
    336           * - VALUE.LSB: Descriptor index
    337           * - INDEX: 0, or language ID for string descriptors (currently not supported)
    338           * - LENGTH: Descriptor length (either the requested number of bytes, or the length of the descriptor,
    339           *           whichever is the smallest)
    340           *
    341           * <b>Data (IN)</b>:
    342           * The descriptor(s)
    343           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    344          void usbsrGetDescriptor(void)
   \                     usbsrGetDescriptor:
    345          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
    346             uint8 n;
    347          
    348             // Which descriptor?
    349             switch (HI_UINT16(usbSetupHeader.value)) {
   \   000005   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FA           MOV     R2,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   14           DEC     A
   \   00000F   6008         JZ      ??usbsrGetDescriptor_0
   \   000011   14           DEC     A
   \   000012   6010         JZ      ??usbsrGetDescriptor_1
   \   000014   14           DEC     A
   \   000015   6039         JZ      ??usbsrGetDescriptor_2
   \   000017   8057         SJMP    ??usbsrGetDescriptor_3
    350          
    351             // Device descriptor
    352             case DESC_TYPE_DEVICE:
    353                usbSetupData.pBuffer = (uint8 __code*) usbdpGetDeviceDesc();
   \                     ??usbsrGetDescriptor_0:
   \   000019                ; Setup parameters for call to function usbdpGetDeviceDesc
   \   000019   12....       LCALL   `??usbdpGetDeviceDesc::?relay`; Banked call to: usbdpGetDeviceDesc
   \   00001C   12....       LCALL   ?Subroutine16 & 0xFFFF
    354                usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
   \                     ??CrossCallReturnLabel_18:
   \   00001F   A3           INC     DPTR
   \   000020   7B80         MOV     R3,#-0x80
   \   000022   8041         SJMP    ??usbsrGetDescriptor_4
    355                break;
    356          
    357             // Configuration descriptor
    358             case DESC_TYPE_CONFIG:
    359                usbSetupData.pBuffer = (uint8 __code*) usbdpGetConfigurationDesc(0, LO_UINT16(usbSetupHeader.value));
   \                     ??usbsrGetDescriptor_1:
   \   000024                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   000024   7900         MOV     R1,#0x0
   \   000026   12....       LCALL   `??usbdpGetConfigurationDesc::?relay`; Banked call to: usbdpGetConfigurationDesc
   \   000029   12....       LCALL   ?Subroutine16 & 0xFFFF
    360                usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_CONFIG_LENGTH_LSB_IDX] +
    361                                         usbSetupData.pBuffer[DESC_CONFIG_LENGTH_MSB_IDX] * 256;
   \                     ??CrossCallReturnLabel_19:
   \   00002C   7B80         MOV     R3,#-0x80
   \   00002E   E9           MOV     A,R1
   \   00002F   2402         ADD     A,#0x2
   \   000031   F9           MOV     R1,A
   \   000032   E4           CLR     A
   \   000033   3A           ADDC    A,R2
   \   000034   FA           MOV     R2,A
   \   000035   12....       LCALL   ?C_GPTR_LOAD
   \   000038   FC           MOV     R4,A
   \   000039   19           DEC     R1
   \   00003A   19           DEC     R1
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FA           MOV     R2,A
   \   00003D   A3           INC     DPTR
   \   00003E   E9           MOV     A,R1
   \   00003F   2403         ADD     A,#0x3
   \   000041   F9           MOV     R1,A
   \   000042   E4           CLR     A
   \   000043   3A           ADDC    A,R2
   \   000044   FA           MOV     R2,A
   \   000045   12....       LCALL   ?C_GPTR_LOAD
   \   000048   F9           MOV     R1,A
   \   000049   EC           MOV     A,R4
   \   00004A   A3           INC     DPTR
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   E9           MOV     A,R1
   \   00004E   801C         SJMP    ??usbsrGetDescriptor_5
    362                break;
    363          
    364             // String descriptor
    365             case DESC_TYPE_STRING:
    366                // OPT: Implement language ID
    367                usbSetupData.pBuffer = (uint8*) usbdpGetStringDesc(LO_UINT16(usbSetupHeader.value));
   \                     ??usbsrGetDescriptor_2:
   \   000050                ; Setup parameters for call to function usbdpGetStringDesc
   \   000050   EA           MOV     A,R2
   \   000051   F9           MOV     R1,A
   \   000052   12....       LCALL   `??usbdpGetStringDesc::?relay`; Banked call to: usbdpGetStringDesc
   \   000055   90....       MOV     DPTR,#usbSetupData
   \   000058   EA           MOV     A,R2
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   EB           MOV     A,R3
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   E4           CLR     A
   \   00005F   12....       LCALL   ?Subroutine21 & 0xFFFF
    368                usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
   \                     ??CrossCallReturnLabel_26:
   \   000062   A3           INC     DPTR
   \   000063   7B00         MOV     R3,#0x0
   \                     ??usbsrGetDescriptor_4:
   \   000065   12....       LCALL   ?C_GPTR_LOAD
   \   000068   A3           INC     DPTR
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   E4           CLR     A
   \                     ??usbsrGetDescriptor_5:
   \   00006C   F0           MOVX    @DPTR,A
    369                break;
   \   00006D   02....       LJMP    ??usbsrGetDescriptor_6 & 0xFFFF
    370          
    371             // Other descriptor type
    372             default:
    373                // Perform a table search (on index and value)
    374                usbSetupData.pBuffer = NULL;
   \                     ??usbsrGetDescriptor_3:
   \   000070   90....       MOV     DPTR,#usbSetupData
   \   000073   E4           CLR     A
   \   000074   F0           MOVX    @DPTR,A
   \   000075   A3           INC     DPTR
   \   000076   F0           MOVX    @DPTR,A
   \   000077   A3           INC     DPTR
   \   000078   F0           MOVX    @DPTR,A
    375                for (n = 0; n < ((uint16)usbDescriptorMarker.pUsbDescLutEnd - (uint16)usbDescriptorMarker.pUsbDescLut) / sizeof(DESC_LUT_INFO); n++) {
   \   000079   75..00       MOV     ?V6,#0x0
   \   00007C   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F5..         MOV     ?V4,A
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   F5..         MOV     ?V5,A
   \   000086   90....       MOV     DPTR,#usbDescriptorMarker + 4
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   FC           MOV     R4,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   FD           MOV     R5,A
   \   00008E   02....       LJMP    ??usbsrGetDescriptor_7 & 0xFFFF
    376                   if ((usbDescriptorMarker.pUsbDescLut[n].valueMsb == HI_UINT16(usbSetupHeader.value))
    377                       && (usbDescriptorMarker.pUsbDescLut[n].valueLsb == LO_UINT16(usbSetupHeader.value))
    378                       && (usbDescriptorMarker.pUsbDescLut[n].indexMsb == HI_UINT16(usbSetupHeader.index))
    379                       && (usbDescriptorMarker.pUsbDescLut[n].indexLsb == LO_UINT16(usbSetupHeader.index)) )
   \                     ??usbsrGetDescriptor_8:
   \   000091   85....       MOV     ?V0,?V6
   \   000094   75..00       MOV     ?V1,#0x0
   \   000097   7403         MOV     A,#0x3
   \   000099   78..         MOV     R0,#?V0
   \   00009B   12....       LCALL   ?S_SHL
   \   00009E   EC           MOV     A,R4
   \   00009F   25..         ADD     A,?V0
   \   0000A1   F8           MOV     R0,A
   \   0000A2   ED           MOV     A,R5
   \   0000A3   35..         ADDC    A,?V1
   \   0000A5   F9           MOV     R1,A
   \   0000A6   8882         MOV     DPL,R0
   \   0000A8   8983         MOV     DPH,R1
   \   0000AA   E4           CLR     A
   \   0000AB   93           MOVC    A,@A+DPTR
   \   0000AC   65..         XRL     A,?V3
   \   0000AE   705F         JNZ     ??usbsrGetDescriptor_9
   \   0000B0   A3           INC     DPTR
   \   0000B1   E4           CLR     A
   \   0000B2   93           MOVC    A,@A+DPTR
   \   0000B3   C0E0         PUSH    A
   \   0000B5   EA           MOV     A,R2
   \   0000B6   FE           MOV     R6,A
   \   0000B7   D0E0         POP     A
   \   0000B9   6E           XRL     A,R6
   \   0000BA   7053         JNZ     ??usbsrGetDescriptor_9
   \   0000BC   8882         MOV     DPL,R0
   \   0000BE   8983         MOV     DPH,R1
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   E4           CLR     A
   \   0000C3   93           MOVC    A,@A+DPTR
   \   0000C4   AE..         MOV     R6,?V5
   \   0000C6   6E           XRL     A,R6
   \   0000C7   7046         JNZ     ??usbsrGetDescriptor_9
   \   0000C9   8882         MOV     DPL,R0
   \   0000CB   8983         MOV     DPH,R1
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   E4           CLR     A
   \   0000D1   93           MOVC    A,@A+DPTR
   \   0000D2   AE..         MOV     R6,?V4
   \   0000D4   6E           XRL     A,R6
   \   0000D5   7038         JNZ     ??usbsrGetDescriptor_9
    380                   {
    381                      usbSetupData.pBuffer = usbDescriptorMarker.pUsbDescLut[n].pDescStart;
   \   0000D7   8882         MOV     DPL,R0
   \   0000D9   8983         MOV     DPH,R1
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   E4           CLR     A
   \   0000E0   93           MOVC    A,@A+DPTR
   \   0000E1   F5..         MOV     ?V0,A
   \   0000E3   7401         MOV     A,#0x1
   \   0000E5   93           MOVC    A,@A+DPTR
   \   0000E6   F5..         MOV     ?V1,A
   \   0000E8   90....       MOV     DPTR,#usbSetupData
   \   0000EB   E5..         MOV     A,?V0
   \   0000ED   F0           MOVX    @DPTR,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E5..         MOV     A,?V1
   \   0000F1   F0           MOVX    @DPTR,A
   \   0000F2   A3           INC     DPTR
   \   0000F3   7480         MOV     A,#-0x80
   \   0000F5   F0           MOVX    @DPTR,A
    382                      usbSetupData.bytesLeft = usbDescriptorMarker.pUsbDescLut[n].length;
   \   0000F6   8882         MOV     DPL,R0
   \   0000F8   8983         MOV     DPH,R1
   \   0000FA   A3           INC     DPTR
   \   0000FB   A3           INC     DPTR
   \   0000FC   A3           INC     DPTR
   \   0000FD   A3           INC     DPTR
   \   0000FE   A3           INC     DPTR
   \   0000FF   A3           INC     DPTR
   \   000100   E4           CLR     A
   \   000101   93           MOVC    A,@A+DPTR
   \   000102   F8           MOV     R0,A
   \   000103   7401         MOV     A,#0x1
   \   000105   93           MOVC    A,@A+DPTR
   \   000106   F9           MOV     R1,A
   \   000107   90....       MOV     DPTR,#usbSetupData + 3
   \   00010A   E8           MOV     A,R0
   \   00010B   F0           MOVX    @DPTR,A
   \   00010C   A3           INC     DPTR
   \   00010D   E9           MOV     A,R1
   \   00010E   F0           MOVX    @DPTR,A
    383                   }
    384                }
   \                     ??usbsrGetDescriptor_9:
   \   00010F   05..         INC     ?V6
   \                     ??usbsrGetDescriptor_7:
   \   000111   90....       MOV     DPTR,#usbDescriptorMarker + 6
   \   000114   12....       LCALL   ?Subroutine13 & 0xFFFF
    385             }
   \                     ??CrossCallReturnLabel_14:
   \   000117   C3           CLR     C
   \   000118   9C           SUBB    A,R4
   \   000119   F5..         MOV     ?V0,A
   \   00011B   E9           MOV     A,R1
   \   00011C   9D           SUBB    A,R5
   \   00011D   F5..         MOV     ?V1,A
   \   00011F   7403         MOV     A,#0x3
   \   000121   78..         MOV     R0,#?V0
   \   000123   12....       LCALL   ?US_SHR
   \   000126   C3           CLR     C
   \   000127   E5..         MOV     A,?V6
   \   000129   95..         SUBB    A,?V0
   \   00012B   E4           CLR     A
   \   00012C   95..         SUBB    A,?V1
   \   00012E   5003         JNC     $+5
   \   000130   02....       LJMP    ??usbsrGetDescriptor_8 & 0xFFFF
    386          
    387             // Stall EP0 if no descriptor was found
    388             if (usbSetupData.pBuffer == NULL) usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetDescriptor_6:
   \   000133   90....       MOV     DPTR,#usbSetupData
   \   000136   E0           MOVX    A,@DPTR
   \   000137   FC           MOV     R4,A
   \   000138   A3           INC     DPTR
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   FD           MOV     R5,A
   \   00013B   A3           INC     DPTR
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   FE           MOV     R6,A
   \   00013E   EC           MOV     A,R4
   \   00013F   4D           ORL     A,R5
   \   000140   4E           ORL     A,R6
   \   000141   90....       MOV     DPTR,#usbfwData + 7
   \   000144   7004         JNZ     ??usbsrGetDescriptor_10
   \   000146   7404         MOV     A,#0x4
   \   000148   8022         SJMP    ??usbsrGetDescriptor_11
    389          
    390             if (usbfwData.ep0Status != EP_STALL) {
   \                     ??usbsrGetDescriptor_10:
   \   00014A   E0           MOVX    A,@DPTR
   \   00014B   6404         XRL     A,#0x4
   \   00014D   601E         JZ      ??usbsrGetDescriptor_12
    391          
    392                // Limit the returned descriptor size (the PC wants to know about sizes before
    393                // polling the complete descriptors)
    394                if (usbSetupData.bytesLeft > usbSetupHeader.length) {
   \   00014F   90....       MOV     DPTR,#usbSetupHeader + 6
   \   000152   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000155   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000158   C3           CLR     C
   \   000159   EA           MOV     A,R2
   \   00015A   98           SUBB    A,R0
   \   00015B   EB           MOV     A,R3
   \   00015C   99           SUBB    A,R1
   \   00015D   5008         JNC     ??usbsrGetDescriptor_13
    395                   usbSetupData.bytesLeft = usbSetupHeader.length;
   \   00015F   90....       MOV     DPTR,#usbSetupData + 3
   \   000162   EA           MOV     A,R2
   \   000163   F0           MOVX    @DPTR,A
   \   000164   A3           INC     DPTR
   \   000165   EB           MOV     A,R3
   \   000166   F0           MOVX    @DPTR,A
    396                }
    397          
    398                usbfwData.ep0Status = EP_TX;
   \                     ??usbsrGetDescriptor_13:
   \   000167   90....       MOV     DPTR,#usbfwData + 7
   \   00016A   7401         MOV     A,#0x1
   \                     ??usbsrGetDescriptor_11:
   \   00016C   F0           MOVX    @DPTR,A
    399             }
    400          
    401          } // usbsrGetDescriptor
   \                     ??usbsrGetDescriptor_12:
   \   00016D   7F07         MOV     R7,#0x7
   \   00016F   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   90....       MOV     DPTR,#usbSetupData
   \   000003   EA           MOV     A,R2
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   EB           MOV     A,R3
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   7480         MOV     A,#-0x80
   \   00000B   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#usbSetupData
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FA           MOV     R2,A
   \   000009   22           RET
    402          
    403          
    404          
    405          /** \brief Internally used function that configures all endpoints for the specified interface
    406           *
    407           * The new endpoint setup overwrites the old, without any warning. Unused endpoints keep their current
    408           * setup. The user is responsible for ensuring that no endpoint buffers overwrite each other, and that
    409           * interfaces do not cause conflicts. The pUsbDblbufLutInfo table must contain an entry for each
    410           * interface descriptor to define endpoint double-buffering.
    411           *
    412           * \param[in]       *pInterface
    413           *     A pointer to the interface descriptor
    414           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    415          static void ConfigureEndpoints(USB_INTERFACE_DESCRIPTOR __code *pInterface)
   \                     ??ConfigureEndpoints:
    416          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
    417             uint8 n;
    418             uint16 maxpRegValue;
    419             uint8 csRegValue;
    420             uint8 endpoint;
    421             USB_ENDPOINT_DESCRIPTOR __code *pEndpoint;
    422             DBLBUF_LUT_INFO __code *pUsbDblbufLutInfo;
    423          
    424             // Locate the double buffer settings
    425             if (pInterface->bNumEndpoints) {
   \   000005   EA           MOV     A,R2
   \   000006   2404         ADD     A,#0x4
   \   000008   F5..         MOV     ?V0,A
   \   00000A   E4           CLR     A
   \   00000B   3B           ADDC    A,R3
   \   00000C   F5..         MOV     ?V1,A
   \   00000E   85..82       MOV     DPL,?V0
   \   000011   F583         MOV     DPH,A
   \   000013   E4           CLR     A
   \   000014   93           MOVC    A,@A+DPTR
   \   000015   6025         JZ      ??ConfigureEndpoints_1
    426                 pUsbDblbufLutInfo = (DBLBUF_LUT_INFO __code*) usbDescriptorMarker.pUsbDblbufLut;
   \   000017   90....       MOV     DPTR,#usbDescriptorMarker + 8
   \   00001A   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00001D   FE           MOV     R6,A
   \   00001E   E9           MOV     A,R1
   \   00001F   FF           MOV     R7,A
   \   000020   8007         SJMP    ??ConfigureEndpoints_2
    427                 while (pUsbDblbufLutInfo->pInterface != pInterface) {
    428                    pUsbDblbufLutInfo++;
   \                     ??ConfigureEndpoints_3:
   \   000022   EE           MOV     A,R6
   \   000023   2404         ADD     A,#0x4
   \   000025   FE           MOV     R6,A
   \   000026   5001         JNC     ??ConfigureEndpoints_2
   \   000028   0F           INC     R7
    429                 }
   \                     ??ConfigureEndpoints_2:
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   E4           CLR     A
   \   00002E   93           MOVC    A,@A+DPTR
   \   00002F   F8           MOV     R0,A
   \   000030   7401         MOV     A,#0x1
   \   000032   93           MOVC    A,@A+DPTR
   \   000033   F9           MOV     R1,A
   \   000034   EA           MOV     A,R2
   \   000035   68           XRL     A,R0
   \   000036   7002         JNZ     ??ConfigureEndpoints_4
   \   000038   EB           MOV     A,R3
   \   000039   69           XRL     A,R1
   \                     ??ConfigureEndpoints_4:
   \   00003A   70E6         JNZ     ??ConfigureEndpoints_3
    430             }
    431          
    432             // For each endpoint in this interface
    433             for (n = 0; n < pInterface->bNumEndpoints; n++) {
   \                     ??ConfigureEndpoints_1:
   \   00003C   75..00       MOV     ?V3,#0x0
   \   00003F   803F         SJMP    ??ConfigureEndpoints_5
    434                if (pEndpoint = usbdpFindNext(DESC_TYPE_ENDPOINT, 0)) {
    435          
    436                   // Get the endpoint index
    437                   endpoint = pEndpoint->bEndpointAddress & 0x0F;
    438                   USBFW_SELECT_ENDPOINT(endpoint);
    439          
    440                   csRegValue = 0x00;
    441                   maxpRegValue = (pEndpoint->wMaxPacketSize + 7) >> 3;
    442          
    443                   // For IN endpoints...
    444                   if (pEndpoint->bEndpointAddress & 0x80) {
    445          
    446                      // Clear data toggle, and flush twice (due to double buffering)
    447                      USBCSIL = USBCSIL_CLR_DATA_TOG | USBCSIL_FLUSH_PACKET;
    448                      USBCSIL = USBCSIL_FLUSH_PACKET;
    449          
    450                      // USBCSIH
    451                      if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSIH_ISO;  // ISO flag
    452                      if (pUsbDblbufLutInfo->inMask & (1 << endpoint)) csRegValue |= USBCSIH_IN_DBL_BUF;          // Double buffering
    453                      USBCSIH = csRegValue;
    454          
    455                      // Max transfer size
    456                      USBMAXI = maxpRegValue;
    457          
    458                      // Endpoint status
    459                      usbfwData.pEpInStatus[endpoint - 1] = EP_IDLE;
    460          
    461                   // For OUT endpoints...
    462                   } else {
    463          
    464                      // Clear data toggle, and flush twice (due to double buffering)
    465                      USBCSOL = USBCSOL_CLR_DATA_TOG | USBCSOL_FLUSH_PACKET;
   \                     ??ConfigureEndpoints_6:
   \   000041   906214       MOV     DPTR,#0x6214
   \   000044   7490         MOV     A,#-0x70
   \   000046   F0           MOVX    @DPTR,A
    466                      USBCSOL = USBCSOL_FLUSH_PACKET;
   \   000047   7410         MOV     A,#0x10
   \   000049   12....       LCALL   ?Subroutine18 & 0xFFFF
    467          
    468                      // USBCSOH
    469                      if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSOH_ISO;  // ISO flag
   \                     ??CrossCallReturnLabel_22:
   \   00004C   7003         JNZ     ??ConfigureEndpoints_7
   \   00004E   75..40       MOV     ?V2,#0x40
    470                      if (pUsbDblbufLutInfo->outMask & (1 << endpoint)) csRegValue |= USBCSOH_OUT_DBL_BUF;        // Double buffering
   \                     ??ConfigureEndpoints_7:
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   E4           CLR     A
   \   000059   93           MOVC    A,@A+DPTR
   \   00005A   55..         ANL     A,?V6
   \   00005C   6006         JZ      ??ConfigureEndpoints_8
   \   00005E   E5..         MOV     A,?V2
   \   000060   D2E0         SETB    0xE0 /* A   */.0
   \   000062   F5..         MOV     ?V2,A
    471                      USBCSOH = csRegValue;
   \                     ??ConfigureEndpoints_8:
   \   000064   E5..         MOV     A,?V2
   \   000066   906215       MOV     DPTR,#0x6215
   \   000069   F0           MOVX    @DPTR,A
    472          
    473                      // Max transfer size
    474                      USBMAXO = maxpRegValue;
   \   00006A   EA           MOV     A,R2
   \   00006B   906213       MOV     DPTR,#0x6213
   \   00006E   F0           MOVX    @DPTR,A
    475          
    476                      // Endpoint status
    477                      usbfwData.pEpOutStatus[endpoint - 1] = EP_IDLE;
   \   00006F   EC           MOV     A,R4
   \   000070   240C         ADD     A,#0xc
   \   000072   F582         MOV     DPL,A
   \   000074   E4           CLR     A
   \   000075   3D           ADDC    A,R5
   \   000076   F583         MOV     DPH,A
   \                     ??ConfigureEndpoints_9:
   \   000078   E4           CLR     A
   \   000079   F0           MOVX    @DPTR,A
    478                   }
    479                   USBFW_SELECT_ENDPOINT(0);
   \   00007A   90620E       MOV     DPTR,#0x620e
   \   00007D   F0           MOVX    @DPTR,A
   \                     ??ConfigureEndpoints_10:
   \   00007E   05..         INC     ?V3
   \                     ??ConfigureEndpoints_5:
   \   000080   85..82       MOV     DPL,?V0
   \   000083   85..83       MOV     DPH,?V1
   \   000086   E4           CLR     A
   \   000087   93           MOVC    A,@A+DPTR
   \   000088   F8           MOV     R0,A
   \   000089   E5..         MOV     A,?V3
   \   00008B   C3           CLR     C
   \   00008C   98           SUBB    A,R0
   \   00008D   4003         JC      $+5
   \   00008F   02....       LJMP    ??ConfigureEndpoints_11 & 0xFFFF
   \   000092                ; Setup parameters for call to function usbdpFindNext
   \   000092   7A00         MOV     R2,#0x0
   \   000094   7905         MOV     R1,#0x5
   \   000096   12....       LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
   \   000099   8A..         MOV     ?V4,R2
   \   00009B   8B..         MOV     ?V5,R3
   \   00009D   EA           MOV     A,R2
   \   00009E   45..         ORL     A,?V5
   \   0000A0   60DC         JZ      ??ConfigureEndpoints_10
   \   0000A2   EA           MOV     A,R2
   \   0000A3   2402         ADD     A,#0x2
   \   0000A5   F8           MOV     R0,A
   \   0000A6   E4           CLR     A
   \   0000A7   35..         ADDC    A,?V5
   \   0000A9   F9           MOV     R1,A
   \   0000AA   88..         MOV     ?V8,R0
   \   0000AC   89..         MOV     ?V9,R1
   \   0000AE   8882         MOV     DPL,R0
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   E4           CLR     A
   \   0000B3   93           MOVC    A,@A+DPTR
   \   0000B4   540F         ANL     A,#0xf
   \   0000B6   F5..         MOV     ?V10,A
   \   0000B8   90620E       MOV     DPTR,#0x620e
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   75..00       MOV     ?V2,#0x0
   \   0000BF   8A82         MOV     DPL,R2
   \   0000C1   8B83         MOV     DPH,R3
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   E4           CLR     A
   \   0000C8   93           MOVC    A,@A+DPTR
   \   0000C9   2407         ADD     A,#0x7
   \   0000CB   F5..         MOV     ?V6,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   E4           CLR     A
   \   0000CF   93           MOVC    A,@A+DPTR
   \   0000D0   3400         ADDC    A,#0x0
   \   0000D2   F5..         MOV     ?V7,A
   \   0000D4   7403         MOV     A,#0x3
   \   0000D6   78..         MOV     R0,#?V6
   \   0000D8   12....       LCALL   ?US_SHR
   \   0000DB   AA..         MOV     R2,?V6
   \   0000DD   A8..         MOV     R0,?V10
   \   0000DF   74..         MOV     A,#usbfwData & 0xff
   \   0000E1   28           ADD     A,R0
   \   0000E2   F8           MOV     R0,A
   \   0000E3   E4           CLR     A
   \   0000E4   34..         ADDC    A,#(usbfwData >> 8) & 0xff
   \   0000E6   F9           MOV     R1,A
   \   0000E7   E8           MOV     A,R0
   \   0000E8   FC           MOV     R4,A
   \   0000E9   E9           MOV     A,R1
   \   0000EA   FD           MOV     R5,A
   \   0000EB   75..01       MOV     ?V6,#0x1
   \   0000EE   75..00       MOV     ?V7,#0x0
   \   0000F1   E5..         MOV     A,?V10
   \   0000F3   78..         MOV     R0,#?V6
   \   0000F5   12....       LCALL   ?S_SHL
   \   0000F8   E5..         MOV     A,?V6
   \   0000FA   F5..         MOV     ?V6,A
   \   0000FC   E5..         MOV     A,?V4
   \   0000FE   2403         ADD     A,#0x3
   \   000100   F8           MOV     R0,A
   \   000101   E4           CLR     A
   \   000102   35..         ADDC    A,?V5
   \   000104   F9           MOV     R1,A
   \   000105   85..82       MOV     DPL,?V8
   \   000108   85..83       MOV     DPH,?V9
   \   00010B   E4           CLR     A
   \   00010C   93           MOVC    A,@A+DPTR
   \   00010D   A2E7         MOV     C,0xE0 /* A   */.7
   \   00010F   4003         JC      $+5
   \   000111   02....       LJMP    ??ConfigureEndpoints_6 & 0xFFFF
   \   000114   906211       MOV     DPTR,#0x6211
   \   000117   7448         MOV     A,#0x48
   \   000119   F0           MOVX    @DPTR,A
   \   00011A   7408         MOV     A,#0x8
   \   00011C   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00011F   7003         JNZ     ??ConfigureEndpoints_12
   \   000121   75..40       MOV     ?V2,#0x40
   \                     ??ConfigureEndpoints_12:
   \   000124   8E82         MOV     DPL,R6
   \   000126   8F83         MOV     DPH,R7
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   E4           CLR     A
   \   00012B   93           MOVC    A,@A+DPTR
   \   00012C   55..         ANL     A,?V6
   \   00012E   6006         JZ      ??ConfigureEndpoints_13
   \   000130   E5..         MOV     A,?V2
   \   000132   D2E0         SETB    0xE0 /* A   */.0
   \   000134   F5..         MOV     ?V2,A
   \                     ??ConfigureEndpoints_13:
   \   000136   E5..         MOV     A,?V2
   \   000138   906212       MOV     DPTR,#0x6212
   \   00013B   F0           MOVX    @DPTR,A
   \   00013C   EA           MOV     A,R2
   \   00013D   906210       MOV     DPTR,#0x6210
   \   000140   F0           MOVX    @DPTR,A
   \   000141   8C82         MOV     DPL,R4
   \   000143   8D83         MOV     DPH,R5
   \   000145   A3           INC     DPTR
   \   000146   A3           INC     DPTR
   \   000147   A3           INC     DPTR
   \   000148   A3           INC     DPTR
   \   000149   A3           INC     DPTR
   \   00014A   A3           INC     DPTR
   \   00014B   A3           INC     DPTR
   \   00014C   02....       LJMP    ??ConfigureEndpoints_9 & 0xFFFF
    480                }
    481             }
    482          } // ConfigureEndpoints
   \                     ??ConfigureEndpoints_11:
   \   00014F   7F0B         MOV     R7,#0xb
   \   000151   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   E4           CLR     A
   \   000006   93           MOVC    A,@A+DPTR
   \   000007   5403         ANL     A,#0x3
   \   000009   6401         XRL     A,#0x1
   \   00000B   22           RET
    483          
    484          
    485          
    486          
    487          /** \brief Processes the \ref GET_CONFIGURATION request (returns the current device configuration value)
    488           *
    489           * If the returned value is 0, the device is not configured (not in the configured state)
    490           *
    491           * <b>Parameters</b>:
    492           * - VALUE: Always 0
    493           * - INDEX: Always 0
    494           * - LENGTH: Always 1
    495           *
    496           * <b>Data (IN)</b>:
    497           * The non-zero \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue of the currently selected
    498           * configuration.
    499           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    500          void usbsrGetConfiguration(void)
   \                     usbsrGetConfiguration:
    501          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    502          
    503             // Sanity check
    504             if (usbSetupHeader.value || usbSetupHeader.index || (usbSetupHeader.length != 1)) {
   \   000004   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000007   7010         JNZ     ??usbsrGetConfiguration_0
   \   000009   A3           INC     DPTR
   \   00000A   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   00000D   700A         JNZ     ??usbsrGetConfiguration_0
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6401         XRL     A,#0x1
   \   000013   7002         JNZ     ??usbsrGetConfiguration_1
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??usbsrGetConfiguration_1:
   \   000017   6007         JZ      ??usbsrGetConfiguration_2
    505                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetConfiguration_0:
   \   000019   90....       MOV     DPTR,#usbfwData + 7
   \   00001C   7404         MOV     A,#0x4
   \   00001E   800C         SJMP    ??CrossCallReturnLabel_20
    506          
    507             // Return the current configuration
    508             } else {
    509                usbSetupData.pBuffer = &usbfwData.configurationValue;
   \                     ??usbsrGetConfiguration_2:
   \   000020   90....       MOV     DPTR,#usbSetupData
   \   000023   74..         MOV     A,#(usbfwData + 1) & 0xff
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   74..         MOV     A,#((usbfwData + 1) >> 8) & 0xff
   \   000029   12....       LCALL   ?Subroutine17 & 0xFFFF
    510                usbSetupData.bytesLeft = 1;
    511                usbfwData.ep0Status = EP_TX;
    512             }
   \                     ??CrossCallReturnLabel_20:
   \   00002C   02....       LJMP    ??Subroutine25_0 & 0xFFFF
    513          
    514          } // usbsrGetConfiguration

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E4           CLR     A
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   04           INC     A
   \   000006   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000009   22           RET
    515          
    516          
    517          
    518          
    519          /** \brief Processes the \ref SET_CONFIGURATION request (sets the device configuration)
    520           *
    521           * The configuration value must either be 0, in which case the device enters the address state, or it
    522           * must match a configuration value from one of the USB configuration descriptors. If there is a match,
    523           * the device enters the configured state.
    524           *
    525           * This request resets all interfaces to alternate setting 0, and uses the \c ConfigureEndpoints()
    526           * function to automatically setup all endpoint registers.
    527           *
    528           * <b>Parameters</b>:
    529           * - VALUE: The configuration value (0-255)
    530           * - INDEX: Always 0
    531           * - LENGTH: Always 0
    532           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    533          void usbsrSetConfiguration(void)
   \                     usbsrSetConfiguration:
    534          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    535             uint8 n;
    536             USB_CONFIGURATION_DESCRIPTOR __code *pConfiguration;
    537             USB_INTERFACE_DESCRIPTOR __code *pInterface;
    538          
    539             // Sanity check
    540             if ((usbfwData.usbState == DEV_DEFAULT) || usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value)) {
   \   000005   90....       MOV     DPTR,#usbfwData
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6402         XRL     A,#0x2
   \   00000B   6014         JZ      ??usbsrSetConfiguration_0
   \   00000D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000010   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000013   700C         JNZ     ??usbsrSetConfiguration_0
   \   000015   A3           INC     DPTR
   \   000016   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000019   7006         JNZ     ??usbsrSetConfiguration_0
   \   00001B   90....       MOV     DPTR,#usbSetupHeader + 3
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6008         JZ      ??usbsrSetConfiguration_1
    541                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetConfiguration_0:
   \   000021   90....       MOV     DPTR,#usbfwData + 7
   \   000024   7404         MOV     A,#0x4
   \   000026   F0           MOVX    @DPTR,A
   \   000027   807D         SJMP    ??usbsrSetConfiguration_2
    542          
    543             // Default endpoint setup
    544             } else {
    545                usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGING, 0);
   \                     ??usbsrSetConfiguration_1:
   \   000029                ; Setup parameters for call to function usbsrHookProcessEvent
   \   000029   7A00         MOV     R2,#0x0
   \   00002B   7901         MOV     R1,#0x1
   \   00002D   12....       LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
    546          
    547                // Configure relevant endpoints
    548                if (LO_UINT16(usbSetupHeader.value)) {
   \   000030   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FE           MOV     R6,A
   \   000035   605A         JZ      ??usbsrSetConfiguration_3
    549          
    550                   // Find the correct configuration descriptor...
    551                   pConfiguration = usbdpGetConfigurationDesc(LO_UINT16(usbSetupHeader.value), 0);
   \   000037                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   000037   7A00         MOV     R2,#0x0
   \   000039   F9           MOV     R1,A
   \   00003A   12....       LCALL   `??usbdpGetConfigurationDesc::?relay`; Banked call to: usbdpGetConfigurationDesc
   \   00003D   8A..         MOV     ?V0,R2
   \   00003F   8B..         MOV     ?V1,R3
    552          
    553                   // If it exists...
    554                   if (pConfiguration) {
   \   000041   EA           MOV     A,R2
   \   000042   45..         ORL     A,?V1
   \   000044   6043         JZ      ??usbsrSetConfiguration_4
    555                      usbfwData.usbState = DEV_CONFIGURED;
   \   000046   90....       MOV     DPTR,#usbfwData
   \   000049   7404         MOV     A,#0x4
   \   00004B   F0           MOVX    @DPTR,A
    556                      usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
   \   00004C   EE           MOV     A,R6
   \   00004D   A3           INC     DPTR
   \   00004E   F0           MOVX    @DPTR,A
    557          
    558                      // For each interface...
    559                      for (n = 0; n < pConfiguration->bNumInterfaces; n++) {
   \   00004F   7E00         MOV     R6,#0x0
   \                     ??usbsrSetConfiguration_5:
   \   000051   85..82       MOV     DPL,?V0
   \   000054   85..83       MOV     DPH,?V1
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   E4           CLR     A
   \   00005C   93           MOVC    A,@A+DPTR
   \   00005D   F8           MOV     R0,A
   \   00005E   EE           MOV     A,R6
   \   00005F   C3           CLR     C
   \   000060   98           SUBB    A,R0
   \   000061   503C         JNC     ??usbsrSetConfiguration_6
    560                         usbfwData.pAlternateSetting[n] = 0x00;
   \   000063   EE           MOV     A,R6
   \   000064   F8           MOV     R0,A
   \   000065   74..         MOV     A,#(usbfwData + 2) & 0xff
   \   000067   28           ADD     A,R0
   \   000068   F582         MOV     DPL,A
   \   00006A   E4           CLR     A
   \   00006B   34..         ADDC    A,#((usbfwData + 2) >> 8) & 0xff
   \   00006D   F583         MOV     DPH,A
   \   00006F   E4           CLR     A
   \   000070   F0           MOVX    @DPTR,A
    561          
    562                         // Look only for alternate setting 0
    563                         do {
    564                            pInterface = usbdpFindNext(DESC_TYPE_INTERFACE, 0);
   \                     ??usbsrSetConfiguration_7:
   \   000071                ; Setup parameters for call to function usbdpFindNext
   \   000071   7A00         MOV     R2,#0x0
   \   000073   7904         MOV     R1,#0x4
   \   000075   12....       LCALL   `??usbdpFindNext::?relay`; Banked call to: usbdpFindNext
    565                         } while (pInterface->bAlternateSetting != usbfwData.pAlternateSetting[n]);
   \   000078   8A82         MOV     DPL,R2
   \   00007A   8B83         MOV     DPH,R3
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   E4           CLR     A
   \   000080   93           MOVC    A,@A+DPTR
   \   000081   70EE         JNZ     ??usbsrSetConfiguration_7
    566          
    567                         // Configure all endpoints in this interface
    568                         ConfigureEndpoints(pInterface);
   \   000083                ; Setup parameters for call to function ConfigureEndpoints
   \   000083   12....       LCALL   `??ConfigureEndpoints::?relay`; Banked call to: ConfigureEndpoints
    569                      }
   \   000086   0E           INC     R6
   \   000087   80C8         SJMP    ??usbsrSetConfiguration_5
    570          
    571                   // If not, then stall the endpoint
    572                   } else {
    573                      usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetConfiguration_4:
   \   000089   90....       MOV     DPTR,#usbfwData + 7
   \   00008C   7404         MOV     A,#0x4
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   800E         SJMP    ??usbsrSetConfiguration_6
    574                   }
    575          
    576                // Unconfigure endpoints
    577                } else {
    578                   usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
   \                     ??usbsrSetConfiguration_3:
   \   000091   90....       MOV     DPTR,#usbfwData + 1
   \   000094   F0           MOVX    @DPTR,A
    579                   usbfwData.usbState = DEV_ADDRESS;
   \   000095   90....       MOV     DPTR,#usbfwData
   \   000098   7403         MOV     A,#0x3
   \   00009A   F0           MOVX    @DPTR,A
    580                   usbfwSetAllEpStatus(EP_HALT);
   \   00009B                ; Setup parameters for call to function usbfwSetAllEpStatus
   \   00009B   F9           MOV     R1,A
   \   00009C   12....       LCALL   `??usbfwSetAllEpStatus::?relay`; Banked call to: usbfwSetAllEpStatus
    581                }
    582                usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGED, 0);
   \                     ??usbsrSetConfiguration_6:
   \   00009F                ; Setup parameters for call to function usbsrHookProcessEvent
   \   00009F   7A00         MOV     R2,#0x0
   \   0000A1   7902         MOV     R1,#0x2
   \   0000A3   12....       LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
    583             }
    584          
    585          } // usbsrSetConfiguration
   \                     ??usbsrSetConfiguration_2:
   \   0000A6                REQUIRE ?Subroutine3
   \   0000A6                ; // Fall through to label ?Subroutine3
    586          
    587          
    588          
    589          
    590          /** \brief Processes the \ref GET_INTERFACE request (returns the selected alternate setting for the
    591           * specified interface)
    592           *
    593           * Some USB devices have configurations with mutually exclusive interface settings. This request allows
    594           * the host to determine the currently selected alternate setting.
    595           *
    596           * <b>Parameters</b>:
    597           * - VALUE: Always 0
    598           * - INDEX: Interface number
    599           * - LENGTH: Always 1
    600           *
    601           * <b>Data (IN)</b>:
    602           * The alternate setting for the selected interface
    603           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    604          void usbsrGetInterface(void)
   \                     usbsrGetInterface:
    605          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    606          
    607             // Sanity check
    608             if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_IN_INTERFACE) || usbSetupHeader.value || (usbSetupHeader.length != 1)) {
   \   000005   90....       MOV     DPTR,#usbfwData
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6404         XRL     A,#0x4
   \   00000B   7019         JNZ     ??usbsrGetInterface_0
   \   00000D   90....       MOV     DPTR,#usbSetupHeader
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6481         XRL     A,#0x81
   \   000013   7011         JNZ     ??usbsrGetInterface_0
   \   000015   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000018   700C         JNZ     ??usbsrGetInterface_0
   \   00001A   90....       MOV     DPTR,#usbSetupHeader + 6
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6401         XRL     A,#0x1
   \   000020   7002         JNZ     ??usbsrGetInterface_1
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \                     ??usbsrGetInterface_1:
   \   000024   6007         JZ      ??usbsrGetInterface_2
    609                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetInterface_0:
   \   000026   90....       MOV     DPTR,#usbfwData + 7
   \   000029   7404         MOV     A,#0x4
   \   00002B   801A         SJMP    ??CrossCallReturnLabel_21
    610          
    611             // Return the current alternate setting
    612             } else {
    613                usbSetupData.pBuffer = &usbfwData.pAlternateSetting[usbSetupHeader.index];
   \                     ??usbsrGetInterface_2:
   \   00002D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000030   E0           MOVX    A,@DPTR
   \   000031   24..         ADD     A,#(usbfwData + 2) & 0xff
   \   000033   F5..         MOV     ?V0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   34..         ADDC    A,#((usbfwData + 2) >> 8) & 0xff
   \   000039   F5..         MOV     ?V1,A
   \   00003B   90....       MOV     DPTR,#usbSetupData
   \   00003E   E5..         MOV     A,?V0
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   E5..         MOV     A,?V1
   \   000044   12....       LCALL   ?Subroutine17 & 0xFFFF
    614                usbSetupData.bytesLeft = 1;
    615                usbfwData.ep0Status = EP_TX;
    616             }
   \                     ??CrossCallReturnLabel_21:
   \   000047   02....       LJMP    ?Subroutine0 & 0xFFFF
    617          
    618          } // usbsrGetInterface
    619          
    620          
    621          
    622          
    623          /** \brief Processes the \ref SET_INTERFACE request (selects an alternate setting for the specified
    624           * interface)
    625           *
    626           * Some USB devices have configurations with mutually exclusive interface settings. This request allows
    627           * the host to select the desired alternate setting.
    628           *
    629           * This function uses the \c ConfigureEndpoints() to automatically setup the relevant endpoint
    630           * registers.
    631           *
    632           * <b>Parameters</b>:
    633           * - VALUE: Alternate setting
    634           * - INDEX: Interface number
    635           * - LENGTH: Always 0
    636           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    637          void usbsrSetInterface(void)
   \                     usbsrSetInterface:
    638          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    639             USB_INTERFACE_DESCRIPTOR __code *pInterface;
    640          
    641             // Sanity check
    642             if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_OUT_INTERFACE) || usbSetupHeader.length) {
   \   000005   90....       MOV     DPTR,#usbfwData
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6404         XRL     A,#0x4
   \   00000B   7060         JNZ     ??usbsrSetInterface_0
   \   00000D   90....       MOV     DPTR,#usbSetupHeader
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6401         XRL     A,#0x1
   \   000013   7058         JNZ     ??usbsrSetInterface_0
   \   000015   90....       MOV     DPTR,#usbSetupHeader + 6
   \   000018   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00001B   7050         JNZ     ??usbsrSetInterface_0
    643                usbfwData.ep0Status = EP_STALL;
    644          
    645             // Verify that the desired alternate setting is available, and then make the switch
    646             } else {
    647                if (pInterface = usbdpGetInterfaceDesc(usbfwData.configurationValue, usbSetupHeader.index, usbSetupHeader.value)) {
   \   00001D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000020   E0           MOVX    A,@DPTR
   \   000021   FE           MOV     R6,A
   \   000022                ; Setup parameters for call to function usbdpGetInterfaceDesc
   \   000022   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000025   E0           MOVX    A,@DPTR
   \   000026   FB           MOV     R3,A
   \   000027   EE           MOV     A,R6
   \   000028   FA           MOV     R2,A
   \   000029   90....       MOV     DPTR,#usbfwData + 1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F9           MOV     R1,A
   \   00002E   12....       LCALL   `??usbdpGetInterfaceDesc::?relay`; Banked call to: usbdpGetInterfaceDesc
   \   000031   8A..         MOV     ?V0,R2
   \   000033   8B..         MOV     ?V1,R3
   \   000035   EA           MOV     A,R2
   \   000036   45..         ORL     A,?V1
   \   000038   6033         JZ      ??usbsrSetInterface_0
    648                   usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGING, usbSetupHeader.index);
   \   00003A                ; Setup parameters for call to function usbsrHookProcessEvent
   \   00003A   EE           MOV     A,R6
   \   00003B   FA           MOV     R2,A
   \   00003C   7903         MOV     R1,#0x3
   \   00003E   12....       LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
    649                   usbfwData.pAlternateSetting[usbSetupHeader.index] = usbSetupHeader.value;
   \   000041   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000044   E0           MOVX    A,@DPTR
   \   000045   C0E0         PUSH    A
   \   000047   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   24..         ADD     A,#(usbfwData + 2) & 0xff
   \   00004D   F8           MOV     R0,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   34..         ADDC    A,#((usbfwData + 2) >> 8) & 0xff
   \   000052   F9           MOV     R1,A
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   D0E0         POP     A
   \   000059   F0           MOVX    @DPTR,A
    650          
    651                   // Configure all endpoints in this interface
    652                   ConfigureEndpoints(pInterface);
   \   00005A                ; Setup parameters for call to function ConfigureEndpoints
   \   00005A   AA..         MOV     R2,?V0
   \   00005C   AB..         MOV     R3,?V1
   \   00005E   12....       LCALL   `??ConfigureEndpoints::?relay`; Banked call to: ConfigureEndpoints
    653                   usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGED, usbSetupHeader.index);
   \   000061                ; Setup parameters for call to function usbsrHookProcessEvent
   \   000061   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000064   E0           MOVX    A,@DPTR
   \   000065   FA           MOV     R2,A
   \   000066   7904         MOV     R1,#0x4
   \   000068   12....       LCALL   `??usbsrHookProcessEvent::?relay`; Banked call to: usbsrHookProcessEvent
   \   00006B   8006         SJMP    ??usbsrSetInterface_1
    654          
    655                // This interface does not exist
    656                } else {
    657                   usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetInterface_0:
   \   00006D   90....       MOV     DPTR,#usbfwData + 7
   \   000070   7404         MOV     A,#0x4
   \   000072   F0           MOVX    @DPTR,A
    658                }
    659             }
    660          
    661          } // usbsrSetInterface
   \                     ??usbsrSetInterface_1:
   \   000073   02....       LJMP    ?Subroutine3 & 0xFFFF
    662          
    663          //@}
    664          
    665          
C:\BLE-CC254x-1.4.2.2.200_200\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_suspend.c
      1          /******************************************************************************
      2          
      3           @file  usb_suspend.c
      4          
      5           @brief USB library common functionality.
      6          
      7           Group: WCS, BTS
      8           Target Device: CC2540, CC2541
      9          
     10           ******************************************************************************
     11           
     12           Copyright (c) 2008-2016, Texas Instruments Incorporated
     13           All rights reserved.
     14          
     15           IMPORTANT: Your use of this Software is limited to those specific rights
     16           granted under the terms of a software license agreement between the user
     17           who downloaded the software, his/her employer (which must be your employer)
     18           and Texas Instruments Incorporated (the "License"). You may not use this
     19           Software unless you agree to abide by the terms of the License. The License
     20           limits your use, and you acknowledge, that the Software may not be modified,
     21           copied or distributed unless embedded on a Texas Instruments microcontroller
     22           or used solely and exclusively in conjunction with a Texas Instruments radio
     23           frequency transceiver, which is integrated into your product. Other than for
     24           the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25           works of, modify, distribute, perform, display or sell this Software and/or
     26           its documentation for any purpose.
     27          
     28           YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29           PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30           INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31           NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32           TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33           NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34           LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35           INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36           OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37           OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38           (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40           Should you have any questions regarding your right to use this Software,
     41           contact Texas Instruments Incorporated at www.TI.com.
     42          
     43           ******************************************************************************
     44           Release Name: ble_sdk_1.4.2.2
     45           Release Date: 2016-06-09 06:57:10
     46           *****************************************************************************/
     47          /// \addtogroup module_usb_suspend
     48          /// @{
     49          #include "usb_firmware_library_headers.h"
     50          #include "hal_board.h"
     51          #include "hal_mcu.h"
     52          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     53          __xdata VFPTR pFnSuspendEnterHook=  NULL;
   \                     pFnSuspendEnterHook:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     54          __xdata VFPTR pFnSuspendExitHook=   NULL;
   \                     pFnSuspendExitHook:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     55          
     56          #if HAL_UART_USB_SUSPEND
     57          extern void halEnterPowerMode(void);
     58          
     59          /** \brief Puts the chip into power mode 1 during USB suspend.
     60           *
     61           * This function must be called from main (i.e. not from interrupt context) upon the reception of a
     62           * \ref USBIRQ_EVENT_SUSPEND event. To comply with the USB specification, this must happen within 10 ms
     63           * after the event occurs. The chip will stay in power mode 1 until a USB resume or USB reset is detected
     64           * on the USB bus, or remote wakeup is used. During this period, the MCU can only run code from
     65           * interrupt context.
     66           */
     67          void usbsuspEnter(void)
     68          {
     69              if (pFnSuspendEnterHook!=NULL)
     70                  pFnSuspendEnterHook();
     71          
     72              HAL_USB_INT_CLEAR();
     73              HAL_USB_INT_ENABLE();
     74          
     75              // Disable USB clock (PLL) before entering PM1
     76              HAL_USB_PLL_DISABLE();
     77          
     78              HAL_LED_CLR_1();
     79          
     80              do {
     81                  // Enter PM1, in prescribed manner as explained in CC253x User's Guide
     82                  SLEEPCMD = 0x05;
     83                  halEnterPowerMode();
     84              } while ( usbirqData.inSuspend );
     85          
     86              // .... we are now up and running again
     87          
     88              // First make sure that the crystal oscillator is stable
     89              while (!CC2530_IS_XOSC_STABLE());
     90          
     91              // Restart the USB clock (PLL)
     92              HAL_USB_ENABLE();
     93          
     94              if (pFnSuspendExitHook!=NULL)
     95                  pFnSuspendExitHook();
     96          } // usbsuspEnter
     97          #endif
     98          
     99          
    100          
    101          /** \brief Attempts USB remote wakeup.
    102           *
    103           * This function can be called from interrupt context while the USB device is suspend mode. If the device
    104           * is privileged to do so (see \c usbfwData.remoteWakeup and the \ref USBSR_EVENT_REMOTE_WAKEUP_ENABLED
    105           * and \ref USBSR_EVENT_REMOTE_WAKEUP_DISABLED events), remote wakeup will be performed. Note that this
    106           * function will block for 10 ms while the resume signal is set on the bus. Note: This function can only
    107           * be called when the 48 MHz XOSC is stable.
    108           *
    109           * \return
    110           *     \c TRUE if the remote wakeup was performed (the privilege had been granted), otherwise \c FALSE
    111           *     (the device is still in suspend mode).
    112           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    113          uint8 usbsuspDoRemoteWakeup(void)
   \                     usbsuspDoRemoteWakeup:
    114          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    115             extern void halMcuWaitMs(uint16 msec);
    116             halIntState_t   intState;
    117          
    118             // Make sure that it's OK
    119             if (!usbfwData.remoteWakeup) return FALSE;
   \   000005   90....       MOV     DPTR,#usbfwData + 18
   \   000008   E0           MOVX    A,@DPTR
   \   000009   7004         JNZ     ??usbsuspDoRemoteWakeup_0
   \   00000B   7900         MOV     R1,#0x0
   \   00000D   802E         SJMP    ??usbsuspDoRemoteWakeup_1
    120          
    121             HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??usbsuspDoRemoteWakeup_0:
   \   00000F   AEA8         MOV     R6,0xa8+0x0
   \   000011   C2AF         CLR     0xa8.7
    122          
    123             // Make sure that the suspend loop does not power down the chip again
    124             usbirqData.inSuspend = FALSE;
   \   000013   75..00       MOV     usbirqData + 2,#0x0
    125          
    126             // Perform remote wakeup by holding the USB resume signal for 10 ms
    127             USBPOW |= USBPOW_RESUME;
   \   000016   906201       MOV     DPTR,#0x6201
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   D2E2         SETB    0xE0 /* A   */.2
   \   00001C   F0           MOVX    @DPTR,A
    128             halMcuWaitMs(10);
   \   00001D                ; Setup parameters for call to function halMcuWaitMs
   \   00001D   7A0A         MOV     R2,#0xa
   \   00001F   7B00         MOV     R3,#0x0
   \   000021   12....       LCALL   `??halMcuWaitMs::?relay`; Banked call to: halMcuWaitMs
    129             USBPOW &= ~USBPOW_RESUME;
   \   000024   906201       MOV     DPTR,#0x6201
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E2         CLR     0xE0 /* A   */.2
   \   00002A   F0           MOVX    @DPTR,A
    130          
    131             // Clear the interrupt flag
    132             HAL_USB_INT_CLEAR();
   \   00002B   758B00       MOV     0x8b,#0x0
   \   00002E   C2E8         CLR     0xe8.0
    133          
    134             HAL_EXIT_CRITICAL_SECTION(intState);
   \   000030   EE           MOV     A,R6
   \   000031   A2E7         MOV     C,0xE0 /* A   */.7
   \   000033   E4           CLR     A
   \   000034   33           RLC     A
   \   000035   F8           MOV     R0,A
   \   000036   EE           MOV     A,R6
   \   000037   A2E7         MOV     C,0xE0 /* A   */.7
   \   000039   92AF         MOV     0xa8.7,C
    135          
    136             return TRUE;
   \   00003B   7901         MOV     R1,#0x1
   \                     ??usbsuspDoRemoteWakeup_1:
   \   00003D   02....       LJMP    ?Subroutine4 & 0xFFFF
   \   000040                REQUIRE _A_IEN0
   \   000040                REQUIRE P2IFG
   \   000040                REQUIRE _A_IRCON2
    137          
    138          } // usbsuspDoRemoteWakeup

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   90....       MOV     DPTR,#usbDescriptorMarker
   \   000003   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000006   90....       MOV     DPTR,#??usbdpData
   \   000009   E8           MOV     A,R0
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   E9           MOV     A,R1
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for serialNumber>`:
   \   000000   00           DB 0
   \   000001   03           DB 3
   \   000002   5F           DB 95
   \   000003   00           DB 0
   \   000004   5F           DB 95
   \   000005   00           DB 0
   \   000006   30           DB 48
   \   000007   00           DB 0
   \   000008   58           DB 88
   \   000009   00           DB 0
   \   00000A   00           DB 0
   \   00000B   00           DB 0
   \   00000C   00           DB 0
   \   00000D   00           DB 0
   \   00000E   00           DB 0
   \   00000F   00           DB 0
   \   000010   00           DB 0
   \   000011   00           DB 0
   \   000012   00           DB 0
   \   000013   00           DB 0
   \   000014   00           DB 0
   \   000015   00           DB 0
   \   000016   00           DB 0
   \   000017   00           DB 0
   \   000018   00           DB 0
   \   000019   00           DB 0
   \   00001A   00           DB 0
   \   00001B   00           DB 0
   \   00001C   00           DB 0
   \   00001D   00           DB 0
   \   00001E   00           DB 0
   \   00001F   00           DB 0
   \   000020   00           DB 0
   \   000021   00           DB 0
   \   000022   00           DB 0
   \   000023   00           DB 0
   \   000024   00           DB 0
   \   000025   00           DB 0
   \   000026   00           DB 0
   \   000027   00           DB 0
   \   000028   00           DB 0
   \   000029   00           DB 0

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalFlashRead::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalFlashWrite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalFlashErase::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashErase

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ublAesAuth::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublAesAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ublAesCrypt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublAesCrypt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ublCfg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublCfg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ublExec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublExec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ublInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ublJump::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublJump

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ublMassErase::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublMassErase

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??main::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    main

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbdpInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbdpFindNext::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpFindNext

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbdpGetDeviceDesc::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpGetDeviceDesc

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbdpGetConfigurationDesc::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpGetConfigurationDesc

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbdpGetInterfaceDesc::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpGetInterfaceDesc

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbdpGetStringDesc::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpGetStringDesc

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbfwInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbfwResetHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwResetHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbfwSetupHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwSetupHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbfwSetAllEpStatus::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwSetAllEpStatus

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbfwReadFifo::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwReadFifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbfwWriteFifo::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwWriteFifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbirqInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbirqInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbirqHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbirqHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsrGetStatus::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrGetStatus

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ChangeFeature::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??ChangeFeature

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsrClearFeature::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrClearFeature

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsrSetFeature::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrSetFeature

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsrSetAddress::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrSetAddress

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsrGetDescriptor::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrGetDescriptor

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ConfigureEndpoints::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??ConfigureEndpoints

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsrGetConfiguration::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrGetConfiguration

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsrSetConfiguration::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrSetConfiguration

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsrGetInterface::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrGetInterface

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsrSetInterface::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrSetInterface

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??usbsuspDoRemoteWakeup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsuspDoRemoteWakeup

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255}>`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255}>_1`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255, 255, 255, 255,`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_7d:
   \   000000   7D000000     DD 125
    139          
    140          
    141          
    142          //@}
    143          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1      9   ChangeFeature
        0      9   -> usbsrHookProcessEvent
      0     31   ConfigureEndpoints
        0     19   -> usbdpFindNext
      2      0   HalFlashErase
      1     33   HalFlashRead
      0     32   HalFlashWrite
      0     11   __low_level_init
        0     11   -> HalFlashRead
        0      9   -> ublJump
      0      0   main
        0      0   -> ublExec
        0      0   -> ublInit
      0     12   ublAesAuth
        0     12   -> HalFlashRead
        0     12   -> HalFlashWrite
      0      0   ublAesCrypt
      0     16   ublCfg
        0     16   -> HalFlashWrite
        0     16   -> memcmp
        0     16   -> memcpy
        0     14   -> ublMassErase
      1     16   ublExec
        0     16   -> ublJump
        0     16   -> usb_msd_poll
        0     16   -> usb_msd_uninit
      0     22   ublInit
        0     22   -> HalFlashRead
        0     22   -> HalFlashWrite
        0     22   -> memcmp
        0     20   -> ublJump
        0     20   -> usb_msd_init
      0     20   ublJump
      3     14   ublMassErase
      2     19   usbdpFindNext
      0     25   usbdpGetConfigurationDesc
        0     10   -> usbdpFindNext
      2     15   usbdpGetDeviceDesc
        2      0   -> usbdpFindNext
      0     24   usbdpGetInterfaceDesc
        0     12   -> usbdpFindNext
        0     12   -> usbdpGetConfigurationDesc
      1     32   usbdpGetStringDesc
      2      0   usbdpInit
      0     10   usbfwInit
        0     10   -> usbdpGetConfigurationDesc
      1     23   usbfwReadFifo
      2      0   usbfwResetHandler
        2      0   -> usbfwSetAllEpStatus
      2     12   usbfwSetAllEpStatus
      0     14   usbfwSetupHandler
        0     11   -> usbcrHookProcessIn
        0     11   -> usbcrHookProcessOut
        0     14   -> usbfwReadFifo
        0     14   -> usbfwWriteFifo
        0     11   -> usbsrClearFeature
        0     11   -> usbsrGetConfiguration
        0     11   -> usbsrGetDescriptor
        0     11   -> usbsrGetInterface
        0     11   -> usbsrGetStatus
        0     11   -> usbsrSetAddress
        0     11   -> usbsrSetConfiguration
        0     11   -> usbsrSetFeature
        0     11   -> usbsrSetInterface
        0     11   -> usbvrHookProcessIn
        0     11   -> usbvrHookProcessOut
      1     23   usbfwWriteFifo
      0     10   usbirqHandler
        0     10   -> usbirqHookProcessEvents
      0     10   usbirqInit
      2     11   usbsrClearFeature
        2      0   -> ChangeFeature
        2      0   -> usbsrHookClearFeature
      2     11   usbsrGetConfiguration
      1     26   usbsrGetDescriptor
        0     15   -> usbdpGetConfigurationDesc
        0     15   -> usbdpGetDeviceDesc
        0     15   -> usbdpGetStringDesc
      0     22   usbsrGetInterface
      2     11   usbsrGetStatus
      2     11   usbsrSetAddress
      0     23   usbsrSetConfiguration
        0     12   -> ConfigureEndpoints
        0     12   -> usbdpFindNext
        0     12   -> usbdpGetConfigurationDesc
        0     12   -> usbfwSetAllEpStatus
        0     12   -> usbsrHookProcessEvent
      2     11   usbsrSetFeature
        2      0   -> ChangeFeature
        2      0   -> usbsrHookSetFeature
      1     23   usbsrSetInterface
        0     12   -> ConfigureEndpoints
        0     12   -> usbdpGetInterfaceDesc
        0     12   -> usbsrHookProcessEvent
      0      9   usbsuspDoRemoteWakeup
        0      9   -> halMcuWaitMs


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {255, 255, 255, 255, 255, 255, 255,
       4  ?<Constant {255, 255, 255, 255}>
       4  ?<Constant {255, 255, 255, 255}>_1
      42  ?<Initializer for serialNumber>
       5  ??Subroutine23_0
       4  ??Subroutine24_0
       1  ??Subroutine25_0
       7  ??Subroutine26_0
       5  ??Subroutine27_0
       3  ??Subroutine28_0
       6  ??Subroutine29_0
       6  ??Subroutine30_0
       1  ?Subroutine0
       5  ?Subroutine1
      15  ?Subroutine10
      18  ?Subroutine11
      10  ?Subroutine12
       5  ?Subroutine13
       3  ?Subroutine14
      10  ?Subroutine15
      15  ?Subroutine16
      10  ?Subroutine17
      12  ?Subroutine18
      16  ?Subroutine19
       7  ?Subroutine2
       6  ?Subroutine20
      10  ?Subroutine21
       9  ?Subroutine22
       5  ?Subroutine3
       5  ?Subroutine4
      15  ?Subroutine5
       3  ?Subroutine6
      34  ?Subroutine7
       3  ?Subroutine8
       7  ?Subroutine9
       1  ADCCON1
       1  ADCCON3
       1  ADCH
       1  CLKCONCMD
     237  ChangeFeature
       6  ChangeFeature::?relay
     340  ConfigureEndpoints
       6  ConfigureEndpoints::?relay
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMAARM
       1  DMAIRQ
      13  HalFlashErase
       6  HalFlashErase::?relay
     128  HalFlashRead
       6  HalFlashRead::?relay
      93  HalFlashWrite
       6  HalFlashWrite::?relay
       1  IEN2
       1  MEMCTR
       1  P0DIR
       1  P0INP
       1  P0SEL
       1  P1DIR
       1  P1INP
       1  P1SEL
       1  P2DIR
       1  P2IFG
       1  P2INP
       1  P2SEL
       2  ProcessFunc
       1  SLEEPSTA
       1  ST0
       1  ST1
       1  ST2
       1  UBL_RC_IMG_PG_BEG
       1  UBL_RC_IMG_PG_END
       1  WDCTL
       1  _A_IEN0
       1  _A_IEN1
       1  _A_IRCON2
       4  __Constant_7d
     336  __low_level_init
       8  dmaCh0
      16  hexDigit
       4  languageId
      23  main
       6  main::?relay
      36  manufacturer
       2  pFnSuspendEnterHook
       2  pFnSuspendExitHook
    2048  pgBuf
      36  product
      42  serialNumber
       4  stDelay
       4  stStart
       2  status
      82  ublAesAuth
       6  ublAesAuth::?relay
       5  ublAesCrypt
       6  ublAesCrypt::?relay
     184  ublCfg
       6  ublCfg::?relay
     194  ublExec
       6  ublExec::?relay
     286  ublInit
       6  ublInit::?relay
      13  ublJump
       6  ublJump::?relay
     100  ublMD
      77  ublMassErase
       6  ublMassErase::?relay
      32  unlockedSecKey
       5  usbSetupData
       8  usbSetupHeader
       2  usbdpData
      71  usbdpFindNext
       6  usbdpFindNext::?relay
      54  usbdpGetConfigurationDesc
       6  usbdpGetConfigurationDesc::?relay
      16  usbdpGetDeviceDesc
       6  usbdpGetDeviceDesc::?relay
      52  usbdpGetInterfaceDesc
       6  usbdpGetInterfaceDesc::?relay
     156  usbdpGetStringDesc
       6  usbdpGetStringDesc::?relay
      20  usbdpInit
       6  usbdpInit::?relay
      20  usbfwData
      57  usbfwInit
       6  usbfwInit::?relay
      41  usbfwReadFifo
       6  usbfwReadFifo::?relay
      31  usbfwResetHandler
       6  usbfwResetHandler::?relay
      26  usbfwSetAllEpStatus
       6  usbfwSetAllEpStatus::?relay
     521  usbfwSetupHandler
       6  usbfwSetupHandler::?relay
      39  usbfwWriteFifo
       6  usbfwWriteFifo::?relay
       5  usbirqData
     160  usbirqHandler
       6  usbirqHandler::?relay
      62  usbirqInit
       6  usbirqInit::?relay
      18  usbsrClearFeature
       6  usbsrClearFeature::?relay
      47  usbsrGetConfiguration
       6  usbsrGetConfiguration::?relay
     370  usbsrGetDescriptor
       6  usbsrGetDescriptor::?relay
      74  usbsrGetInterface
       6  usbsrGetInterface::?relay
     217  usbsrGetStatus
       6  usbsrGetStatus::?relay
      70  usbsrSetAddress
       6  usbsrSetAddress::?relay
     166  usbsrSetConfiguration
       6  usbsrSetConfiguration::?relay
      18  usbsrSetFeature
       6  usbsrSetFeature::?relay
     118  usbsrSetInterface
       6  usbsrSetInterface::?relay
      64  usbsuspDoRemoteWakeup
       6  usbsuspDoRemoteWakeup::?relay

 
 4 404 bytes in segment BANKED_CODE
   222 bytes in segment BANK_RELAYS
     7 bytes in segment DATA_Z
   336 bytes in segment NEAR_CODE
    28 bytes in segment SFR_AN
    42 bytes in segment XDATA_I
    42 bytes in segment XDATA_ID
 2 164 bytes in segment XDATA_N
   146 bytes in segment XDATA_ROM_C
    41 bytes in segment XDATA_Z
 
 5 004 bytes of CODE  memory
   142 bytes of CONST memory (+  4 bytes shared)
     7 bytes of DATA  memory (+ 28 bytes shared)
 2 247 bytes of XDATA memory

Errors: none
Warnings: none
